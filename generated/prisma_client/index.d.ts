
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Passenger
 * 
 */
export type Passenger = $Result.DefaultSelection<Prisma.$PassengerPayload>
/**
 * Model Locations
 * 
 */
export type Locations = $Result.DefaultSelection<Prisma.$LocationsPayload>
/**
 * Model ConferenceDates
 * 
 */
export type ConferenceDates = $Result.DefaultSelection<Prisma.$ConferenceDatesPayload>
/**
 * Model ConferenceOrganizations
 * 
 */
export type ConferenceOrganizations = $Result.DefaultSelection<Prisma.$ConferenceOrganizationsPayload>
/**
 * Model ConferenceTopics
 * 
 */
export type ConferenceTopics = $Result.DefaultSelection<Prisma.$ConferenceTopicsPayload>
/**
 * Model Topics
 * 
 */
export type Topics = $Result.DefaultSelection<Prisma.$TopicsPayload>
/**
 * Model Conferences
 * 
 */
export type Conferences = $Result.DefaultSelection<Prisma.$ConferencesPayload>
/**
 * Model ConferenceRanks
 * 
 */
export type ConferenceRanks = $Result.DefaultSelection<Prisma.$ConferenceRanksPayload>
/**
 * Model FieldOfResearchs
 * 
 */
export type FieldOfResearchs = $Result.DefaultSelection<Prisma.$FieldOfResearchsPayload>
/**
 * Model Ranks
 * 
 */
export type Ranks = $Result.DefaultSelection<Prisma.$RanksPayload>
/**
 * Model Sources
 * 
 */
export type Sources = $Result.DefaultSelection<Prisma.$SourcesPayload>
/**
 * Model JournalTopics
 * 
 */
export type JournalTopics = $Result.DefaultSelection<Prisma.$JournalTopicsPayload>
/**
 * Model JournalRanks
 * 
 */
export type JournalRanks = $Result.DefaultSelection<Prisma.$JournalRanksPayload>
/**
 * Model Journals
 * 
 */
export type Journals = $Result.DefaultSelection<Prisma.$JournalsPayload>
/**
 * Model ConferenceFollows
 * 
 */
export type ConferenceFollows = $Result.DefaultSelection<Prisma.$ConferenceFollowsPayload>
/**
 * Model ConferenceLikes
 * 
 */
export type ConferenceLikes = $Result.DefaultSelection<Prisma.$ConferenceLikesPayload>
/**
 * Model ConferenceFeedbacks
 * 
 */
export type ConferenceFeedbacks = $Result.DefaultSelection<Prisma.$ConferenceFeedbacksPayload>
/**
 * Model ConferenceCalendars
 * 
 */
export type ConferenceCalendars = $Result.DefaultSelection<Prisma.$ConferenceCalendarsPayload>
/**
 * Model JournalLikes
 * 
 */
export type JournalLikes = $Result.DefaultSelection<Prisma.$JournalLikesPayload>
/**
 * Model JournalFollows
 * 
 */
export type JournalFollows = $Result.DefaultSelection<Prisma.$JournalFollowsPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model ConferenceCrawlJobs
 * 
 */
export type ConferenceCrawlJobs = $Result.DefaultSelection<Prisma.$ConferenceCrawlJobsPayload>
/**
 * Model JournalCrawlJobs
 * 
 */
export type JournalCrawlJobs = $Result.DefaultSelection<Prisma.$JournalCrawlJobsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Passengers
 * const passengers = await prisma.passenger.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Passengers
   * const passengers = await prisma.passenger.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.passenger`: Exposes CRUD operations for the **Passenger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passengers
    * const passengers = await prisma.passenger.findMany()
    * ```
    */
  get passenger(): Prisma.PassengerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **Locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): Prisma.LocationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceDates`: Exposes CRUD operations for the **ConferenceDates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceDates
    * const conferenceDates = await prisma.conferenceDates.findMany()
    * ```
    */
  get conferenceDates(): Prisma.ConferenceDatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceOrganizations`: Exposes CRUD operations for the **ConferenceOrganizations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceOrganizations
    * const conferenceOrganizations = await prisma.conferenceOrganizations.findMany()
    * ```
    */
  get conferenceOrganizations(): Prisma.ConferenceOrganizationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceTopics`: Exposes CRUD operations for the **ConferenceTopics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceTopics
    * const conferenceTopics = await prisma.conferenceTopics.findMany()
    * ```
    */
  get conferenceTopics(): Prisma.ConferenceTopicsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topics`: Exposes CRUD operations for the **Topics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topics.findMany()
    * ```
    */
  get topics(): Prisma.TopicsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferences`: Exposes CRUD operations for the **Conferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conferences
    * const conferences = await prisma.conferences.findMany()
    * ```
    */
  get conferences(): Prisma.ConferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceRanks`: Exposes CRUD operations for the **ConferenceRanks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceRanks
    * const conferenceRanks = await prisma.conferenceRanks.findMany()
    * ```
    */
  get conferenceRanks(): Prisma.ConferenceRanksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fieldOfResearchs`: Exposes CRUD operations for the **FieldOfResearchs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldOfResearchs
    * const fieldOfResearchs = await prisma.fieldOfResearchs.findMany()
    * ```
    */
  get fieldOfResearchs(): Prisma.FieldOfResearchsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ranks`: Exposes CRUD operations for the **Ranks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ranks
    * const ranks = await prisma.ranks.findMany()
    * ```
    */
  get ranks(): Prisma.RanksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sources`: Exposes CRUD operations for the **Sources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.sources.findMany()
    * ```
    */
  get sources(): Prisma.SourcesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalTopics`: Exposes CRUD operations for the **JournalTopics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalTopics
    * const journalTopics = await prisma.journalTopics.findMany()
    * ```
    */
  get journalTopics(): Prisma.JournalTopicsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalRanks`: Exposes CRUD operations for the **JournalRanks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalRanks
    * const journalRanks = await prisma.journalRanks.findMany()
    * ```
    */
  get journalRanks(): Prisma.JournalRanksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journals`: Exposes CRUD operations for the **Journals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Journals
    * const journals = await prisma.journals.findMany()
    * ```
    */
  get journals(): Prisma.JournalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceFollows`: Exposes CRUD operations for the **ConferenceFollows** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceFollows
    * const conferenceFollows = await prisma.conferenceFollows.findMany()
    * ```
    */
  get conferenceFollows(): Prisma.ConferenceFollowsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceLikes`: Exposes CRUD operations for the **ConferenceLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceLikes
    * const conferenceLikes = await prisma.conferenceLikes.findMany()
    * ```
    */
  get conferenceLikes(): Prisma.ConferenceLikesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceFeedbacks`: Exposes CRUD operations for the **ConferenceFeedbacks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceFeedbacks
    * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findMany()
    * ```
    */
  get conferenceFeedbacks(): Prisma.ConferenceFeedbacksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceCalendars`: Exposes CRUD operations for the **ConferenceCalendars** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceCalendars
    * const conferenceCalendars = await prisma.conferenceCalendars.findMany()
    * ```
    */
  get conferenceCalendars(): Prisma.ConferenceCalendarsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalLikes`: Exposes CRUD operations for the **JournalLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalLikes
    * const journalLikes = await prisma.journalLikes.findMany()
    * ```
    */
  get journalLikes(): Prisma.JournalLikesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalFollows`: Exposes CRUD operations for the **JournalFollows** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalFollows
    * const journalFollows = await prisma.journalFollows.findMany()
    * ```
    */
  get journalFollows(): Prisma.JournalFollowsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conferenceCrawlJobs`: Exposes CRUD operations for the **ConferenceCrawlJobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConferenceCrawlJobs
    * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findMany()
    * ```
    */
  get conferenceCrawlJobs(): Prisma.ConferenceCrawlJobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalCrawlJobs`: Exposes CRUD operations for the **JournalCrawlJobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalCrawlJobs
    * const journalCrawlJobs = await prisma.journalCrawlJobs.findMany()
    * ```
    */
  get journalCrawlJobs(): Prisma.JournalCrawlJobsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Passenger: 'Passenger',
    Locations: 'Locations',
    ConferenceDates: 'ConferenceDates',
    ConferenceOrganizations: 'ConferenceOrganizations',
    ConferenceTopics: 'ConferenceTopics',
    Topics: 'Topics',
    Conferences: 'Conferences',
    ConferenceRanks: 'ConferenceRanks',
    FieldOfResearchs: 'FieldOfResearchs',
    Ranks: 'Ranks',
    Sources: 'Sources',
    JournalTopics: 'JournalTopics',
    JournalRanks: 'JournalRanks',
    Journals: 'Journals',
    ConferenceFollows: 'ConferenceFollows',
    ConferenceLikes: 'ConferenceLikes',
    ConferenceFeedbacks: 'ConferenceFeedbacks',
    ConferenceCalendars: 'ConferenceCalendars',
    JournalLikes: 'JournalLikes',
    JournalFollows: 'JournalFollows',
    Users: 'Users',
    ConferenceCrawlJobs: 'ConferenceCrawlJobs',
    JournalCrawlJobs: 'JournalCrawlJobs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "passenger" | "locations" | "conferenceDates" | "conferenceOrganizations" | "conferenceTopics" | "topics" | "conferences" | "conferenceRanks" | "fieldOfResearchs" | "ranks" | "sources" | "journalTopics" | "journalRanks" | "journals" | "conferenceFollows" | "conferenceLikes" | "conferenceFeedbacks" | "conferenceCalendars" | "journalLikes" | "journalFollows" | "users" | "conferenceCrawlJobs" | "journalCrawlJobs"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Passenger: {
        payload: Prisma.$PassengerPayload<ExtArgs>
        fields: Prisma.PassengerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PassengerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PassengerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          findFirst: {
            args: Prisma.PassengerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PassengerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          findMany: {
            args: Prisma.PassengerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          create: {
            args: Prisma.PassengerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          createMany: {
            args: Prisma.PassengerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PassengerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          delete: {
            args: Prisma.PassengerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          update: {
            args: Prisma.PassengerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          deleteMany: {
            args: Prisma.PassengerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PassengerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PassengerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          upsert: {
            args: Prisma.PassengerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          aggregate: {
            args: Prisma.PassengerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassenger>
          }
          groupBy: {
            args: Prisma.PassengerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PassengerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PassengerCountArgs<ExtArgs>
            result: $Utils.Optional<PassengerCountAggregateOutputType> | number
          }
        }
      }
      Locations: {
        payload: Prisma.$LocationsPayload<ExtArgs>
        fields: Prisma.LocationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          findFirst: {
            args: Prisma.LocationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          findMany: {
            args: Prisma.LocationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>[]
          }
          create: {
            args: Prisma.LocationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          createMany: {
            args: Prisma.LocationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>[]
          }
          delete: {
            args: Prisma.LocationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          update: {
            args: Prisma.LocationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          deleteMany: {
            args: Prisma.LocationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>[]
          }
          upsert: {
            args: Prisma.LocationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          aggregate: {
            args: Prisma.LocationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocations>
          }
          groupBy: {
            args: Prisma.LocationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationsCountArgs<ExtArgs>
            result: $Utils.Optional<LocationsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceDates: {
        payload: Prisma.$ConferenceDatesPayload<ExtArgs>
        fields: Prisma.ConferenceDatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceDatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceDatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          findFirst: {
            args: Prisma.ConferenceDatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceDatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          findMany: {
            args: Prisma.ConferenceDatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>[]
          }
          create: {
            args: Prisma.ConferenceDatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          createMany: {
            args: Prisma.ConferenceDatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceDatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>[]
          }
          delete: {
            args: Prisma.ConferenceDatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          update: {
            args: Prisma.ConferenceDatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceDatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceDatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceDatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceDatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceDatesPayload>
          }
          aggregate: {
            args: Prisma.ConferenceDatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceDates>
          }
          groupBy: {
            args: Prisma.ConferenceDatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceDatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceDatesCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceDatesCountAggregateOutputType> | number
          }
        }
      }
      ConferenceOrganizations: {
        payload: Prisma.$ConferenceOrganizationsPayload<ExtArgs>
        fields: Prisma.ConferenceOrganizationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceOrganizationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceOrganizationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceOrganizationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceOrganizationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          findMany: {
            args: Prisma.ConferenceOrganizationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>[]
          }
          create: {
            args: Prisma.ConferenceOrganizationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          createMany: {
            args: Prisma.ConferenceOrganizationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceOrganizationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceOrganizationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          update: {
            args: Prisma.ConferenceOrganizationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceOrganizationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceOrganizationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceOrganizationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceOrganizationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceOrganizationsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceOrganizationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceOrganizations>
          }
          groupBy: {
            args: Prisma.ConferenceOrganizationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceOrganizationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceOrganizationsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceOrganizationsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceTopics: {
        payload: Prisma.$ConferenceTopicsPayload<ExtArgs>
        fields: Prisma.ConferenceTopicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceTopicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceTopicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceTopicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceTopicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          findMany: {
            args: Prisma.ConferenceTopicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>[]
          }
          create: {
            args: Prisma.ConferenceTopicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          createMany: {
            args: Prisma.ConferenceTopicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceTopicsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceTopicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          update: {
            args: Prisma.ConferenceTopicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceTopicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceTopicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceTopicsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceTopicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceTopicsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceTopicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceTopics>
          }
          groupBy: {
            args: Prisma.ConferenceTopicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceTopicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceTopicsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceTopicsCountAggregateOutputType> | number
          }
        }
      }
      Topics: {
        payload: Prisma.$TopicsPayload<ExtArgs>
        fields: Prisma.TopicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          findFirst: {
            args: Prisma.TopicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          findMany: {
            args: Prisma.TopicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>[]
          }
          create: {
            args: Prisma.TopicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          createMany: {
            args: Prisma.TopicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>[]
          }
          delete: {
            args: Prisma.TopicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          update: {
            args: Prisma.TopicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          deleteMany: {
            args: Prisma.TopicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>[]
          }
          upsert: {
            args: Prisma.TopicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicsPayload>
          }
          aggregate: {
            args: Prisma.TopicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopics>
          }
          groupBy: {
            args: Prisma.TopicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicsCountArgs<ExtArgs>
            result: $Utils.Optional<TopicsCountAggregateOutputType> | number
          }
        }
      }
      Conferences: {
        payload: Prisma.$ConferencesPayload<ExtArgs>
        fields: Prisma.ConferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          findFirst: {
            args: Prisma.ConferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          findMany: {
            args: Prisma.ConferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>[]
          }
          create: {
            args: Prisma.ConferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          createMany: {
            args: Prisma.ConferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>[]
          }
          delete: {
            args: Prisma.ConferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          update: {
            args: Prisma.ConferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          deleteMany: {
            args: Prisma.ConferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>[]
          }
          upsert: {
            args: Prisma.ConferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferencesPayload>
          }
          aggregate: {
            args: Prisma.ConferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferences>
          }
          groupBy: {
            args: Prisma.ConferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferencesCountArgs<ExtArgs>
            result: $Utils.Optional<ConferencesCountAggregateOutputType> | number
          }
        }
      }
      ConferenceRanks: {
        payload: Prisma.$ConferenceRanksPayload<ExtArgs>
        fields: Prisma.ConferenceRanksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceRanksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceRanksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          findFirst: {
            args: Prisma.ConferenceRanksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceRanksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          findMany: {
            args: Prisma.ConferenceRanksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>[]
          }
          create: {
            args: Prisma.ConferenceRanksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          createMany: {
            args: Prisma.ConferenceRanksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceRanksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>[]
          }
          delete: {
            args: Prisma.ConferenceRanksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          update: {
            args: Prisma.ConferenceRanksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceRanksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceRanksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceRanksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceRanksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceRanksPayload>
          }
          aggregate: {
            args: Prisma.ConferenceRanksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceRanks>
          }
          groupBy: {
            args: Prisma.ConferenceRanksGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceRanksGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceRanksCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceRanksCountAggregateOutputType> | number
          }
        }
      }
      FieldOfResearchs: {
        payload: Prisma.$FieldOfResearchsPayload<ExtArgs>
        fields: Prisma.FieldOfResearchsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldOfResearchsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldOfResearchsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          findFirst: {
            args: Prisma.FieldOfResearchsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldOfResearchsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          findMany: {
            args: Prisma.FieldOfResearchsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>[]
          }
          create: {
            args: Prisma.FieldOfResearchsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          createMany: {
            args: Prisma.FieldOfResearchsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FieldOfResearchsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>[]
          }
          delete: {
            args: Prisma.FieldOfResearchsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          update: {
            args: Prisma.FieldOfResearchsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          deleteMany: {
            args: Prisma.FieldOfResearchsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldOfResearchsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FieldOfResearchsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>[]
          }
          upsert: {
            args: Prisma.FieldOfResearchsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldOfResearchsPayload>
          }
          aggregate: {
            args: Prisma.FieldOfResearchsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFieldOfResearchs>
          }
          groupBy: {
            args: Prisma.FieldOfResearchsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldOfResearchsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FieldOfResearchsCountArgs<ExtArgs>
            result: $Utils.Optional<FieldOfResearchsCountAggregateOutputType> | number
          }
        }
      }
      Ranks: {
        payload: Prisma.$RanksPayload<ExtArgs>
        fields: Prisma.RanksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RanksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RanksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          findFirst: {
            args: Prisma.RanksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RanksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          findMany: {
            args: Prisma.RanksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>[]
          }
          create: {
            args: Prisma.RanksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          createMany: {
            args: Prisma.RanksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RanksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>[]
          }
          delete: {
            args: Prisma.RanksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          update: {
            args: Prisma.RanksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          deleteMany: {
            args: Prisma.RanksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RanksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RanksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>[]
          }
          upsert: {
            args: Prisma.RanksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RanksPayload>
          }
          aggregate: {
            args: Prisma.RanksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRanks>
          }
          groupBy: {
            args: Prisma.RanksGroupByArgs<ExtArgs>
            result: $Utils.Optional<RanksGroupByOutputType>[]
          }
          count: {
            args: Prisma.RanksCountArgs<ExtArgs>
            result: $Utils.Optional<RanksCountAggregateOutputType> | number
          }
        }
      }
      Sources: {
        payload: Prisma.$SourcesPayload<ExtArgs>
        fields: Prisma.SourcesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourcesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourcesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          findFirst: {
            args: Prisma.SourcesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourcesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          findMany: {
            args: Prisma.SourcesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>[]
          }
          create: {
            args: Prisma.SourcesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          createMany: {
            args: Prisma.SourcesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourcesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>[]
          }
          delete: {
            args: Prisma.SourcesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          update: {
            args: Prisma.SourcesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          deleteMany: {
            args: Prisma.SourcesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourcesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourcesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>[]
          }
          upsert: {
            args: Prisma.SourcesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcesPayload>
          }
          aggregate: {
            args: Prisma.SourcesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSources>
          }
          groupBy: {
            args: Prisma.SourcesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourcesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourcesCountArgs<ExtArgs>
            result: $Utils.Optional<SourcesCountAggregateOutputType> | number
          }
        }
      }
      JournalTopics: {
        payload: Prisma.$JournalTopicsPayload<ExtArgs>
        fields: Prisma.JournalTopicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalTopicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalTopicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          findFirst: {
            args: Prisma.JournalTopicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalTopicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          findMany: {
            args: Prisma.JournalTopicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>[]
          }
          create: {
            args: Prisma.JournalTopicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          createMany: {
            args: Prisma.JournalTopicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalTopicsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>[]
          }
          delete: {
            args: Prisma.JournalTopicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          update: {
            args: Prisma.JournalTopicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          deleteMany: {
            args: Prisma.JournalTopicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalTopicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalTopicsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>[]
          }
          upsert: {
            args: Prisma.JournalTopicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTopicsPayload>
          }
          aggregate: {
            args: Prisma.JournalTopicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalTopics>
          }
          groupBy: {
            args: Prisma.JournalTopicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalTopicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalTopicsCountArgs<ExtArgs>
            result: $Utils.Optional<JournalTopicsCountAggregateOutputType> | number
          }
        }
      }
      JournalRanks: {
        payload: Prisma.$JournalRanksPayload<ExtArgs>
        fields: Prisma.JournalRanksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalRanksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalRanksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          findFirst: {
            args: Prisma.JournalRanksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalRanksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          findMany: {
            args: Prisma.JournalRanksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>[]
          }
          create: {
            args: Prisma.JournalRanksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          createMany: {
            args: Prisma.JournalRanksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalRanksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>[]
          }
          delete: {
            args: Prisma.JournalRanksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          update: {
            args: Prisma.JournalRanksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          deleteMany: {
            args: Prisma.JournalRanksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalRanksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalRanksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>[]
          }
          upsert: {
            args: Prisma.JournalRanksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalRanksPayload>
          }
          aggregate: {
            args: Prisma.JournalRanksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalRanks>
          }
          groupBy: {
            args: Prisma.JournalRanksGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalRanksGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalRanksCountArgs<ExtArgs>
            result: $Utils.Optional<JournalRanksCountAggregateOutputType> | number
          }
        }
      }
      Journals: {
        payload: Prisma.$JournalsPayload<ExtArgs>
        fields: Prisma.JournalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          findFirst: {
            args: Prisma.JournalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          findMany: {
            args: Prisma.JournalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>[]
          }
          create: {
            args: Prisma.JournalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          createMany: {
            args: Prisma.JournalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>[]
          }
          delete: {
            args: Prisma.JournalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          update: {
            args: Prisma.JournalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          deleteMany: {
            args: Prisma.JournalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>[]
          }
          upsert: {
            args: Prisma.JournalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalsPayload>
          }
          aggregate: {
            args: Prisma.JournalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournals>
          }
          groupBy: {
            args: Prisma.JournalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalsCountArgs<ExtArgs>
            result: $Utils.Optional<JournalsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceFollows: {
        payload: Prisma.$ConferenceFollowsPayload<ExtArgs>
        fields: Prisma.ConferenceFollowsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceFollowsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceFollowsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceFollowsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceFollowsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          findMany: {
            args: Prisma.ConferenceFollowsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>[]
          }
          create: {
            args: Prisma.ConferenceFollowsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          createMany: {
            args: Prisma.ConferenceFollowsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceFollowsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceFollowsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          update: {
            args: Prisma.ConferenceFollowsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceFollowsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceFollowsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceFollowsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceFollowsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFollowsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceFollowsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceFollows>
          }
          groupBy: {
            args: Prisma.ConferenceFollowsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceFollowsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceFollowsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceFollowsCountAggregateOutputType> | number
          }
        }
      }
      ConferenceLikes: {
        payload: Prisma.$ConferenceLikesPayload<ExtArgs>
        fields: Prisma.ConferenceLikesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceLikesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceLikesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          findFirst: {
            args: Prisma.ConferenceLikesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceLikesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          findMany: {
            args: Prisma.ConferenceLikesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>[]
          }
          create: {
            args: Prisma.ConferenceLikesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          createMany: {
            args: Prisma.ConferenceLikesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceLikesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>[]
          }
          delete: {
            args: Prisma.ConferenceLikesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          update: {
            args: Prisma.ConferenceLikesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceLikesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceLikesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceLikesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceLikesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceLikesPayload>
          }
          aggregate: {
            args: Prisma.ConferenceLikesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceLikes>
          }
          groupBy: {
            args: Prisma.ConferenceLikesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceLikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceLikesCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceLikesCountAggregateOutputType> | number
          }
        }
      }
      ConferenceFeedbacks: {
        payload: Prisma.$ConferenceFeedbacksPayload<ExtArgs>
        fields: Prisma.ConferenceFeedbacksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceFeedbacksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceFeedbacksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          findFirst: {
            args: Prisma.ConferenceFeedbacksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceFeedbacksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          findMany: {
            args: Prisma.ConferenceFeedbacksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>[]
          }
          create: {
            args: Prisma.ConferenceFeedbacksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          createMany: {
            args: Prisma.ConferenceFeedbacksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceFeedbacksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>[]
          }
          delete: {
            args: Prisma.ConferenceFeedbacksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          update: {
            args: Prisma.ConferenceFeedbacksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceFeedbacksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceFeedbacksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceFeedbacksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceFeedbacksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceFeedbacksPayload>
          }
          aggregate: {
            args: Prisma.ConferenceFeedbacksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceFeedbacks>
          }
          groupBy: {
            args: Prisma.ConferenceFeedbacksGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceFeedbacksGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceFeedbacksCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceFeedbacksCountAggregateOutputType> | number
          }
        }
      }
      ConferenceCalendars: {
        payload: Prisma.$ConferenceCalendarsPayload<ExtArgs>
        fields: Prisma.ConferenceCalendarsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceCalendarsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceCalendarsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceCalendarsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceCalendarsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          findMany: {
            args: Prisma.ConferenceCalendarsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>[]
          }
          create: {
            args: Prisma.ConferenceCalendarsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          createMany: {
            args: Prisma.ConferenceCalendarsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceCalendarsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceCalendarsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          update: {
            args: Prisma.ConferenceCalendarsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceCalendarsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceCalendarsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceCalendarsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceCalendarsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCalendarsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceCalendarsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceCalendars>
          }
          groupBy: {
            args: Prisma.ConferenceCalendarsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceCalendarsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceCalendarsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceCalendarsCountAggregateOutputType> | number
          }
        }
      }
      JournalLikes: {
        payload: Prisma.$JournalLikesPayload<ExtArgs>
        fields: Prisma.JournalLikesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalLikesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalLikesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          findFirst: {
            args: Prisma.JournalLikesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalLikesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          findMany: {
            args: Prisma.JournalLikesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>[]
          }
          create: {
            args: Prisma.JournalLikesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          createMany: {
            args: Prisma.JournalLikesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalLikesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>[]
          }
          delete: {
            args: Prisma.JournalLikesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          update: {
            args: Prisma.JournalLikesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          deleteMany: {
            args: Prisma.JournalLikesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalLikesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalLikesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>[]
          }
          upsert: {
            args: Prisma.JournalLikesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLikesPayload>
          }
          aggregate: {
            args: Prisma.JournalLikesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalLikes>
          }
          groupBy: {
            args: Prisma.JournalLikesGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalLikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalLikesCountArgs<ExtArgs>
            result: $Utils.Optional<JournalLikesCountAggregateOutputType> | number
          }
        }
      }
      JournalFollows: {
        payload: Prisma.$JournalFollowsPayload<ExtArgs>
        fields: Prisma.JournalFollowsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalFollowsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalFollowsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          findFirst: {
            args: Prisma.JournalFollowsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalFollowsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          findMany: {
            args: Prisma.JournalFollowsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>[]
          }
          create: {
            args: Prisma.JournalFollowsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          createMany: {
            args: Prisma.JournalFollowsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalFollowsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>[]
          }
          delete: {
            args: Prisma.JournalFollowsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          update: {
            args: Prisma.JournalFollowsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          deleteMany: {
            args: Prisma.JournalFollowsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalFollowsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalFollowsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>[]
          }
          upsert: {
            args: Prisma.JournalFollowsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalFollowsPayload>
          }
          aggregate: {
            args: Prisma.JournalFollowsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalFollows>
          }
          groupBy: {
            args: Prisma.JournalFollowsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalFollowsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalFollowsCountArgs<ExtArgs>
            result: $Utils.Optional<JournalFollowsCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      ConferenceCrawlJobs: {
        payload: Prisma.$ConferenceCrawlJobsPayload<ExtArgs>
        fields: Prisma.ConferenceCrawlJobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConferenceCrawlJobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConferenceCrawlJobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          findFirst: {
            args: Prisma.ConferenceCrawlJobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConferenceCrawlJobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          findMany: {
            args: Prisma.ConferenceCrawlJobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>[]
          }
          create: {
            args: Prisma.ConferenceCrawlJobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          createMany: {
            args: Prisma.ConferenceCrawlJobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConferenceCrawlJobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>[]
          }
          delete: {
            args: Prisma.ConferenceCrawlJobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          update: {
            args: Prisma.ConferenceCrawlJobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          deleteMany: {
            args: Prisma.ConferenceCrawlJobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConferenceCrawlJobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConferenceCrawlJobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>[]
          }
          upsert: {
            args: Prisma.ConferenceCrawlJobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConferenceCrawlJobsPayload>
          }
          aggregate: {
            args: Prisma.ConferenceCrawlJobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConferenceCrawlJobs>
          }
          groupBy: {
            args: Prisma.ConferenceCrawlJobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConferenceCrawlJobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConferenceCrawlJobsCountArgs<ExtArgs>
            result: $Utils.Optional<ConferenceCrawlJobsCountAggregateOutputType> | number
          }
        }
      }
      JournalCrawlJobs: {
        payload: Prisma.$JournalCrawlJobsPayload<ExtArgs>
        fields: Prisma.JournalCrawlJobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalCrawlJobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalCrawlJobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          findFirst: {
            args: Prisma.JournalCrawlJobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalCrawlJobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          findMany: {
            args: Prisma.JournalCrawlJobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>[]
          }
          create: {
            args: Prisma.JournalCrawlJobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          createMany: {
            args: Prisma.JournalCrawlJobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalCrawlJobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>[]
          }
          delete: {
            args: Prisma.JournalCrawlJobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          update: {
            args: Prisma.JournalCrawlJobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          deleteMany: {
            args: Prisma.JournalCrawlJobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalCrawlJobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalCrawlJobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>[]
          }
          upsert: {
            args: Prisma.JournalCrawlJobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalCrawlJobsPayload>
          }
          aggregate: {
            args: Prisma.JournalCrawlJobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalCrawlJobs>
          }
          groupBy: {
            args: Prisma.JournalCrawlJobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalCrawlJobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalCrawlJobsCountArgs<ExtArgs>
            result: $Utils.Optional<JournalCrawlJobsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    passenger?: PassengerOmit
    locations?: LocationsOmit
    conferenceDates?: ConferenceDatesOmit
    conferenceOrganizations?: ConferenceOrganizationsOmit
    conferenceTopics?: ConferenceTopicsOmit
    topics?: TopicsOmit
    conferences?: ConferencesOmit
    conferenceRanks?: ConferenceRanksOmit
    fieldOfResearchs?: FieldOfResearchsOmit
    ranks?: RanksOmit
    sources?: SourcesOmit
    journalTopics?: JournalTopicsOmit
    journalRanks?: JournalRanksOmit
    journals?: JournalsOmit
    conferenceFollows?: ConferenceFollowsOmit
    conferenceLikes?: ConferenceLikesOmit
    conferenceFeedbacks?: ConferenceFeedbacksOmit
    conferenceCalendars?: ConferenceCalendarsOmit
    journalLikes?: JournalLikesOmit
    journalFollows?: JournalFollowsOmit
    users?: UsersOmit
    conferenceCrawlJobs?: ConferenceCrawlJobsOmit
    journalCrawlJobs?: JournalCrawlJobsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ConferenceOrganizationsCountOutputType
   */

  export type ConferenceOrganizationsCountOutputType = {
    conferenceDates: number
    locations: number
    topics: number
  }

  export type ConferenceOrganizationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conferenceDates?: boolean | ConferenceOrganizationsCountOutputTypeCountConferenceDatesArgs
    locations?: boolean | ConferenceOrganizationsCountOutputTypeCountLocationsArgs
    topics?: boolean | ConferenceOrganizationsCountOutputTypeCountTopicsArgs
  }

  // Custom InputTypes
  /**
   * ConferenceOrganizationsCountOutputType without action
   */
  export type ConferenceOrganizationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizationsCountOutputType
     */
    select?: ConferenceOrganizationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConferenceOrganizationsCountOutputType without action
   */
  export type ConferenceOrganizationsCountOutputTypeCountConferenceDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceDatesWhereInput
  }

  /**
   * ConferenceOrganizationsCountOutputType without action
   */
  export type ConferenceOrganizationsCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationsWhereInput
  }

  /**
   * ConferenceOrganizationsCountOutputType without action
   */
  export type ConferenceOrganizationsCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceTopicsWhereInput
  }


  /**
   * Count Type TopicsCountOutputType
   */

  export type TopicsCountOutputType = {
    inConferenceTopics: number
    inJournalTopics: number
  }

  export type TopicsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inConferenceTopics?: boolean | TopicsCountOutputTypeCountInConferenceTopicsArgs
    inJournalTopics?: boolean | TopicsCountOutputTypeCountInJournalTopicsArgs
  }

  // Custom InputTypes
  /**
   * TopicsCountOutputType without action
   */
  export type TopicsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicsCountOutputType
     */
    select?: TopicsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicsCountOutputType without action
   */
  export type TopicsCountOutputTypeCountInConferenceTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceTopicsWhereInput
  }

  /**
   * TopicsCountOutputType without action
   */
  export type TopicsCountOutputTypeCountInJournalTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalTopicsWhereInput
  }


  /**
   * Count Type ConferencesCountOutputType
   */

  export type ConferencesCountOutputType = {
    follows: number
    likes: number
    calendars: number
    organizations: number
    ranks: number
    crawlJobs: number
    feedbacks: number
  }

  export type ConferencesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follows?: boolean | ConferencesCountOutputTypeCountFollowsArgs
    likes?: boolean | ConferencesCountOutputTypeCountLikesArgs
    calendars?: boolean | ConferencesCountOutputTypeCountCalendarsArgs
    organizations?: boolean | ConferencesCountOutputTypeCountOrganizationsArgs
    ranks?: boolean | ConferencesCountOutputTypeCountRanksArgs
    crawlJobs?: boolean | ConferencesCountOutputTypeCountCrawlJobsArgs
    feedbacks?: boolean | ConferencesCountOutputTypeCountFeedbacksArgs
  }

  // Custom InputTypes
  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferencesCountOutputType
     */
    select?: ConferencesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFollowsWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceLikesWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceCalendarsWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceOrganizationsWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceRanksWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountCrawlJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceCrawlJobsWhereInput
  }

  /**
   * ConferencesCountOutputType without action
   */
  export type ConferencesCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFeedbacksWhereInput
  }


  /**
   * Count Type FieldOfResearchsCountOutputType
   */

  export type FieldOfResearchsCountOutputType = {
    journalRanks: number
    conferenceRanks: number
  }

  export type FieldOfResearchsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalRanks?: boolean | FieldOfResearchsCountOutputTypeCountJournalRanksArgs
    conferenceRanks?: boolean | FieldOfResearchsCountOutputTypeCountConferenceRanksArgs
  }

  // Custom InputTypes
  /**
   * FieldOfResearchsCountOutputType without action
   */
  export type FieldOfResearchsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchsCountOutputType
     */
    select?: FieldOfResearchsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FieldOfResearchsCountOutputType without action
   */
  export type FieldOfResearchsCountOutputTypeCountJournalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalRanksWhereInput
  }

  /**
   * FieldOfResearchsCountOutputType without action
   */
  export type FieldOfResearchsCountOutputTypeCountConferenceRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceRanksWhereInput
  }


  /**
   * Count Type RanksCountOutputType
   */

  export type RanksCountOutputType = {
    conferenceRanks: number
    journalRanks: number
  }

  export type RanksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conferenceRanks?: boolean | RanksCountOutputTypeCountConferenceRanksArgs
    journalRanks?: boolean | RanksCountOutputTypeCountJournalRanksArgs
  }

  // Custom InputTypes
  /**
   * RanksCountOutputType without action
   */
  export type RanksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RanksCountOutputType
     */
    select?: RanksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RanksCountOutputType without action
   */
  export type RanksCountOutputTypeCountConferenceRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceRanksWhereInput
  }

  /**
   * RanksCountOutputType without action
   */
  export type RanksCountOutputTypeCountJournalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalRanksWhereInput
  }


  /**
   * Count Type SourcesCountOutputType
   */

  export type SourcesCountOutputType = {
    ranks: number
  }

  export type SourcesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ranks?: boolean | SourcesCountOutputTypeCountRanksArgs
  }

  // Custom InputTypes
  /**
   * SourcesCountOutputType without action
   */
  export type SourcesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcesCountOutputType
     */
    select?: SourcesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourcesCountOutputType without action
   */
  export type SourcesCountOutputTypeCountRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RanksWhereInput
  }


  /**
   * Count Type JournalsCountOutputType
   */

  export type JournalsCountOutputType = {
    topics: number
    journalRanks: number
    journalLikes: number
    journalFollows: number
    crawlJobs: number
  }

  export type JournalsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | JournalsCountOutputTypeCountTopicsArgs
    journalRanks?: boolean | JournalsCountOutputTypeCountJournalRanksArgs
    journalLikes?: boolean | JournalsCountOutputTypeCountJournalLikesArgs
    journalFollows?: boolean | JournalsCountOutputTypeCountJournalFollowsArgs
    crawlJobs?: boolean | JournalsCountOutputTypeCountCrawlJobsArgs
  }

  // Custom InputTypes
  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalsCountOutputType
     */
    select?: JournalsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalTopicsWhereInput
  }

  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeCountJournalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalRanksWhereInput
  }

  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeCountJournalLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLikesWhereInput
  }

  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeCountJournalFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalFollowsWhereInput
  }

  /**
   * JournalsCountOutputType without action
   */
  export type JournalsCountOutputTypeCountCrawlJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalCrawlJobsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    followConference: number
    likes: number
    calendar: number
    createdConferences: number
    createdJournals: number
    journalLikes: number
    journalFollows: number
    feedbacks: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followConference?: boolean | UsersCountOutputTypeCountFollowConferenceArgs
    likes?: boolean | UsersCountOutputTypeCountLikesArgs
    calendar?: boolean | UsersCountOutputTypeCountCalendarArgs
    createdConferences?: boolean | UsersCountOutputTypeCountCreatedConferencesArgs
    createdJournals?: boolean | UsersCountOutputTypeCountCreatedJournalsArgs
    journalLikes?: boolean | UsersCountOutputTypeCountJournalLikesArgs
    journalFollows?: boolean | UsersCountOutputTypeCountJournalFollowsArgs
    feedbacks?: boolean | UsersCountOutputTypeCountFeedbacksArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFollowConferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFollowsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceLikesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceCalendarsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCreatedConferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferencesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCreatedJournalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountJournalLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLikesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountJournalFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalFollowsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFeedbacksWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Passenger
   */

  export type AggregatePassenger = {
    _count: PassengerCountAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  export type PassengerMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
  }

  export type PassengerMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
  }

  export type PassengerCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    _all: number
  }


  export type PassengerMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
  }

  export type PassengerMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
  }

  export type PassengerCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    _all?: true
  }

  export type PassengerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passenger to aggregate.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passengers
    **/
    _count?: true | PassengerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassengerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassengerMaxAggregateInputType
  }

  export type GetPassengerAggregateType<T extends PassengerAggregateArgs> = {
        [P in keyof T & keyof AggregatePassenger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassenger[P]>
      : GetScalarType<T[P], AggregatePassenger[P]>
  }




  export type PassengerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerWhereInput
    orderBy?: PassengerOrderByWithAggregationInput | PassengerOrderByWithAggregationInput[]
    by: PassengerScalarFieldEnum[] | PassengerScalarFieldEnum
    having?: PassengerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassengerCountAggregateInputType | true
    _min?: PassengerMinAggregateInputType
    _max?: PassengerMaxAggregateInputType
  }

  export type PassengerGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    _count: PassengerCountAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  type GetPassengerGroupByPayload<T extends PassengerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PassengerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassengerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassengerGroupByOutputType[P]>
            : GetScalarType<T[P], PassengerGroupByOutputType[P]>
        }
      >
    >


  export type PassengerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
  }

  export type PassengerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName", ExtArgs["result"]["passenger"]>

  export type $PassengerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Passenger"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
    }, ExtArgs["result"]["passenger"]>
    composites: {}
  }

  type PassengerGetPayload<S extends boolean | null | undefined | PassengerDefaultArgs> = $Result.GetResult<Prisma.$PassengerPayload, S>

  type PassengerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PassengerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PassengerCountAggregateInputType | true
    }

  export interface PassengerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Passenger'], meta: { name: 'Passenger' } }
    /**
     * Find zero or one Passenger that matches the filter.
     * @param {PassengerFindUniqueArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PassengerFindUniqueArgs>(args: SelectSubset<T, PassengerFindUniqueArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Passenger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PassengerFindUniqueOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PassengerFindUniqueOrThrowArgs>(args: SelectSubset<T, PassengerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PassengerFindFirstArgs>(args?: SelectSubset<T, PassengerFindFirstArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PassengerFindFirstOrThrowArgs>(args?: SelectSubset<T, PassengerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passengers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passengers
     * const passengers = await prisma.passenger.findMany()
     * 
     * // Get first 10 Passengers
     * const passengers = await prisma.passenger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passengerWithIdOnly = await prisma.passenger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PassengerFindManyArgs>(args?: SelectSubset<T, PassengerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Passenger.
     * @param {PassengerCreateArgs} args - Arguments to create a Passenger.
     * @example
     * // Create one Passenger
     * const Passenger = await prisma.passenger.create({
     *   data: {
     *     // ... data to create a Passenger
     *   }
     * })
     * 
     */
    create<T extends PassengerCreateArgs>(args: SelectSubset<T, PassengerCreateArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passengers.
     * @param {PassengerCreateManyArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PassengerCreateManyArgs>(args?: SelectSubset<T, PassengerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Passengers and returns the data saved in the database.
     * @param {PassengerCreateManyAndReturnArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Passengers and only return the `id`
     * const passengerWithIdOnly = await prisma.passenger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PassengerCreateManyAndReturnArgs>(args?: SelectSubset<T, PassengerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Passenger.
     * @param {PassengerDeleteArgs} args - Arguments to delete one Passenger.
     * @example
     * // Delete one Passenger
     * const Passenger = await prisma.passenger.delete({
     *   where: {
     *     // ... filter to delete one Passenger
     *   }
     * })
     * 
     */
    delete<T extends PassengerDeleteArgs>(args: SelectSubset<T, PassengerDeleteArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Passenger.
     * @param {PassengerUpdateArgs} args - Arguments to update one Passenger.
     * @example
     * // Update one Passenger
     * const passenger = await prisma.passenger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PassengerUpdateArgs>(args: SelectSubset<T, PassengerUpdateArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passengers.
     * @param {PassengerDeleteManyArgs} args - Arguments to filter Passengers to delete.
     * @example
     * // Delete a few Passengers
     * const { count } = await prisma.passenger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PassengerDeleteManyArgs>(args?: SelectSubset<T, PassengerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PassengerUpdateManyArgs>(args: SelectSubset<T, PassengerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers and returns the data updated in the database.
     * @param {PassengerUpdateManyAndReturnArgs} args - Arguments to update many Passengers.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Passengers and only return the `id`
     * const passengerWithIdOnly = await prisma.passenger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PassengerUpdateManyAndReturnArgs>(args: SelectSubset<T, PassengerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Passenger.
     * @param {PassengerUpsertArgs} args - Arguments to update or create a Passenger.
     * @example
     * // Update or create a Passenger
     * const passenger = await prisma.passenger.upsert({
     *   create: {
     *     // ... data to create a Passenger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passenger we want to update
     *   }
     * })
     */
    upsert<T extends PassengerUpsertArgs>(args: SelectSubset<T, PassengerUpsertArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerCountArgs} args - Arguments to filter Passengers to count.
     * @example
     * // Count the number of Passengers
     * const count = await prisma.passenger.count({
     *   where: {
     *     // ... the filter for the Passengers we want to count
     *   }
     * })
    **/
    count<T extends PassengerCountArgs>(
      args?: Subset<T, PassengerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassengerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassengerAggregateArgs>(args: Subset<T, PassengerAggregateArgs>): Prisma.PrismaPromise<GetPassengerAggregateType<T>>

    /**
     * Group by Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PassengerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PassengerGroupByArgs['orderBy'] }
        : { orderBy?: PassengerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PassengerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassengerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Passenger model
   */
  readonly fields: PassengerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Passenger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PassengerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Passenger model
   */ 
  interface PassengerFieldRefs {
    readonly id: FieldRef<"Passenger", 'String'>
    readonly firstName: FieldRef<"Passenger", 'String'>
    readonly lastName: FieldRef<"Passenger", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Passenger findUnique
   */
  export type PassengerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findUniqueOrThrow
   */
  export type PassengerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findFirst
   */
  export type PassengerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger findFirstOrThrow
   */
  export type PassengerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger findMany
   */
  export type PassengerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter, which Passengers to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger create
   */
  export type PassengerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data needed to create a Passenger.
     */
    data: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
  }

  /**
   * Passenger createMany
   */
  export type PassengerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passengers.
     */
    data: PassengerCreateManyInput | PassengerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Passenger createManyAndReturn
   */
  export type PassengerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data used to create many Passengers.
     */
    data: PassengerCreateManyInput | PassengerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Passenger update
   */
  export type PassengerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data needed to update a Passenger.
     */
    data: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
    /**
     * Choose, which Passenger to update.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger updateMany
   */
  export type PassengerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to update.
     */
    limit?: number
  }

  /**
   * Passenger updateManyAndReturn
   */
  export type PassengerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to update.
     */
    limit?: number
  }

  /**
   * Passenger upsert
   */
  export type PassengerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The filter to search for the Passenger to update in case it exists.
     */
    where: PassengerWhereUniqueInput
    /**
     * In case the Passenger found by the `where` argument doesn't exist, create a new Passenger with this data.
     */
    create: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
    /**
     * In case the Passenger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
  }

  /**
   * Passenger delete
   */
  export type PassengerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Filter which Passenger to delete.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger deleteMany
   */
  export type PassengerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passengers to delete
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to delete.
     */
    limit?: number
  }

  /**
   * Passenger without action
   */
  export type PassengerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
  }


  /**
   * Model Locations
   */

  export type AggregateLocations = {
    _count: LocationsCountAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  export type LocationsMinAggregateOutputType = {
    id: string | null
    address: string | null
    cityStateProvince: string | null
    country: string | null
    continent: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isAvailable: boolean | null
    organizeId: string | null
  }

  export type LocationsMaxAggregateOutputType = {
    id: string | null
    address: string | null
    cityStateProvince: string | null
    country: string | null
    continent: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isAvailable: boolean | null
    organizeId: string | null
  }

  export type LocationsCountAggregateOutputType = {
    id: number
    address: number
    cityStateProvince: number
    country: number
    continent: number
    createdAt: number
    updatedAt: number
    isAvailable: number
    organizeId: number
    _all: number
  }


  export type LocationsMinAggregateInputType = {
    id?: true
    address?: true
    cityStateProvince?: true
    country?: true
    continent?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
    organizeId?: true
  }

  export type LocationsMaxAggregateInputType = {
    id?: true
    address?: true
    cityStateProvince?: true
    country?: true
    continent?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
    organizeId?: true
  }

  export type LocationsCountAggregateInputType = {
    id?: true
    address?: true
    cityStateProvince?: true
    country?: true
    continent?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
    organizeId?: true
    _all?: true
  }

  export type LocationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to aggregate.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationsMaxAggregateInputType
  }

  export type GetLocationsAggregateType<T extends LocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocations[P]>
      : GetScalarType<T[P], AggregateLocations[P]>
  }




  export type LocationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationsWhereInput
    orderBy?: LocationsOrderByWithAggregationInput | LocationsOrderByWithAggregationInput[]
    by: LocationsScalarFieldEnum[] | LocationsScalarFieldEnum
    having?: LocationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationsCountAggregateInputType | true
    _min?: LocationsMinAggregateInputType
    _max?: LocationsMaxAggregateInputType
  }

  export type LocationsGroupByOutputType = {
    id: string
    address: string | null
    cityStateProvince: string | null
    country: string | null
    continent: string | null
    createdAt: Date
    updatedAt: Date
    isAvailable: boolean
    organizeId: string
    _count: LocationsCountAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  type GetLocationsGroupByPayload<T extends LocationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationsGroupByOutputType[P]>
        }
      >
    >


  export type LocationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    cityStateProvince?: boolean
    country?: boolean
    continent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    organizeId?: boolean
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type LocationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    cityStateProvince?: boolean
    country?: boolean
    continent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    organizeId?: boolean
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type LocationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    cityStateProvince?: boolean
    country?: boolean
    continent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    organizeId?: boolean
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>

  export type LocationsSelectScalar = {
    id?: boolean
    address?: boolean
    cityStateProvince?: boolean
    country?: boolean
    continent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    organizeId?: boolean
  }

  export type LocationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "address" | "cityStateProvince" | "country" | "continent" | "createdAt" | "updatedAt" | "isAvailable" | "organizeId", ExtArgs["result"]["locations"]>
  export type LocationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }
  export type LocationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }
  export type LocationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }

  export type $LocationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Locations"
    objects: {
      belongsTo: Prisma.$ConferenceOrganizationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string | null
      cityStateProvince: string | null
      country: string | null
      continent: string | null
      createdAt: Date
      updatedAt: Date
      isAvailable: boolean
      organizeId: string
    }, ExtArgs["result"]["locations"]>
    composites: {}
  }

  type LocationsGetPayload<S extends boolean | null | undefined | LocationsDefaultArgs> = $Result.GetResult<Prisma.$LocationsPayload, S>

  type LocationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationsCountAggregateInputType | true
    }

  export interface LocationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Locations'], meta: { name: 'Locations' } }
    /**
     * Find zero or one Locations that matches the filter.
     * @param {LocationsFindUniqueArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationsFindUniqueArgs>(args: SelectSubset<T, LocationsFindUniqueArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Locations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationsFindUniqueOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationsFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsFindFirstArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationsFindFirstArgs>(args?: SelectSubset<T, LocationsFindFirstArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsFindFirstOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationsFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.locations.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationsFindManyArgs>(args?: SelectSubset<T, LocationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Locations.
     * @param {LocationsCreateArgs} args - Arguments to create a Locations.
     * @example
     * // Create one Locations
     * const Locations = await prisma.locations.create({
     *   data: {
     *     // ... data to create a Locations
     *   }
     * })
     * 
     */
    create<T extends LocationsCreateArgs>(args: SelectSubset<T, LocationsCreateArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationsCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationsCreateManyArgs>(args?: SelectSubset<T, LocationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationsCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationsWithIdOnly = await prisma.locations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationsCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Locations.
     * @param {LocationsDeleteArgs} args - Arguments to delete one Locations.
     * @example
     * // Delete one Locations
     * const Locations = await prisma.locations.delete({
     *   where: {
     *     // ... filter to delete one Locations
     *   }
     * })
     * 
     */
    delete<T extends LocationsDeleteArgs>(args: SelectSubset<T, LocationsDeleteArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Locations.
     * @param {LocationsUpdateArgs} args - Arguments to update one Locations.
     * @example
     * // Update one Locations
     * const locations = await prisma.locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationsUpdateArgs>(args: SelectSubset<T, LocationsUpdateArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationsDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationsDeleteManyArgs>(args?: SelectSubset<T, LocationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationsUpdateManyArgs>(args: SelectSubset<T, LocationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationsUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationsWithIdOnly = await prisma.locations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationsUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Locations.
     * @param {LocationsUpsertArgs} args - Arguments to update or create a Locations.
     * @example
     * // Update or create a Locations
     * const locations = await prisma.locations.upsert({
     *   create: {
     *     // ... data to create a Locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locations we want to update
     *   }
     * })
     */
    upsert<T extends LocationsUpsertArgs>(args: SelectSubset<T, LocationsUpsertArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.locations.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationsCountArgs>(
      args?: Subset<T, LocationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationsAggregateArgs>(args: Subset<T, LocationsAggregateArgs>): Prisma.PrismaPromise<GetLocationsAggregateType<T>>

    /**
     * Group by Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationsGroupByArgs['orderBy'] }
        : { orderBy?: LocationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Locations model
   */
  readonly fields: LocationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends ConferenceOrganizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizationsDefaultArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Locations model
   */ 
  interface LocationsFieldRefs {
    readonly id: FieldRef<"Locations", 'String'>
    readonly address: FieldRef<"Locations", 'String'>
    readonly cityStateProvince: FieldRef<"Locations", 'String'>
    readonly country: FieldRef<"Locations", 'String'>
    readonly continent: FieldRef<"Locations", 'String'>
    readonly createdAt: FieldRef<"Locations", 'DateTime'>
    readonly updatedAt: FieldRef<"Locations", 'DateTime'>
    readonly isAvailable: FieldRef<"Locations", 'Boolean'>
    readonly organizeId: FieldRef<"Locations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Locations findUnique
   */
  export type LocationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations findUniqueOrThrow
   */
  export type LocationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations findFirst
   */
  export type LocationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * Locations findFirstOrThrow
   */
  export type LocationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * Locations findMany
   */
  export type LocationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * Locations create
   */
  export type LocationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Locations.
     */
    data: XOR<LocationsCreateInput, LocationsUncheckedCreateInput>
  }

  /**
   * Locations createMany
   */
  export type LocationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationsCreateManyInput | LocationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Locations createManyAndReturn
   */
  export type LocationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationsCreateManyInput | LocationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Locations update
   */
  export type LocationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Locations.
     */
    data: XOR<LocationsUpdateInput, LocationsUncheckedUpdateInput>
    /**
     * Choose, which Locations to update.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations updateMany
   */
  export type LocationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationsUpdateManyMutationInput, LocationsUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationsWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Locations updateManyAndReturn
   */
  export type LocationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationsUpdateManyMutationInput, LocationsUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationsWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Locations upsert
   */
  export type LocationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Locations to update in case it exists.
     */
    where: LocationsWhereUniqueInput
    /**
     * In case the Locations found by the `where` argument doesn't exist, create a new Locations with this data.
     */
    create: XOR<LocationsCreateInput, LocationsUncheckedCreateInput>
    /**
     * In case the Locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationsUpdateInput, LocationsUncheckedUpdateInput>
  }

  /**
   * Locations delete
   */
  export type LocationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter which Locations to delete.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations deleteMany
   */
  export type LocationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationsWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Locations without action
   */
  export type LocationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceDates
   */

  export type AggregateConferenceDates = {
    _count: ConferenceDatesCountAggregateOutputType | null
    _min: ConferenceDatesMinAggregateOutputType | null
    _max: ConferenceDatesMaxAggregateOutputType | null
  }

  export type ConferenceDatesMinAggregateOutputType = {
    id: string | null
    organizedId: string | null
    fromDate: Date | null
    toDate: Date | null
    type: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isAvailable: boolean | null
  }

  export type ConferenceDatesMaxAggregateOutputType = {
    id: string | null
    organizedId: string | null
    fromDate: Date | null
    toDate: Date | null
    type: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isAvailable: boolean | null
  }

  export type ConferenceDatesCountAggregateOutputType = {
    id: number
    organizedId: number
    fromDate: number
    toDate: number
    type: number
    name: number
    createdAt: number
    updatedAt: number
    isAvailable: number
    _all: number
  }


  export type ConferenceDatesMinAggregateInputType = {
    id?: true
    organizedId?: true
    fromDate?: true
    toDate?: true
    type?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
  }

  export type ConferenceDatesMaxAggregateInputType = {
    id?: true
    organizedId?: true
    fromDate?: true
    toDate?: true
    type?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
  }

  export type ConferenceDatesCountAggregateInputType = {
    id?: true
    organizedId?: true
    fromDate?: true
    toDate?: true
    type?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isAvailable?: true
    _all?: true
  }

  export type ConferenceDatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceDates to aggregate.
     */
    where?: ConferenceDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceDates to fetch.
     */
    orderBy?: ConferenceDatesOrderByWithRelationInput | ConferenceDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceDates
    **/
    _count?: true | ConferenceDatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceDatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceDatesMaxAggregateInputType
  }

  export type GetConferenceDatesAggregateType<T extends ConferenceDatesAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceDates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceDates[P]>
      : GetScalarType<T[P], AggregateConferenceDates[P]>
  }




  export type ConferenceDatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceDatesWhereInput
    orderBy?: ConferenceDatesOrderByWithAggregationInput | ConferenceDatesOrderByWithAggregationInput[]
    by: ConferenceDatesScalarFieldEnum[] | ConferenceDatesScalarFieldEnum
    having?: ConferenceDatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceDatesCountAggregateInputType | true
    _min?: ConferenceDatesMinAggregateInputType
    _max?: ConferenceDatesMaxAggregateInputType
  }

  export type ConferenceDatesGroupByOutputType = {
    id: string
    organizedId: string
    fromDate: Date
    toDate: Date
    type: string
    name: string
    createdAt: Date
    updatedAt: Date
    isAvailable: boolean
    _count: ConferenceDatesCountAggregateOutputType | null
    _min: ConferenceDatesMinAggregateOutputType | null
    _max: ConferenceDatesMaxAggregateOutputType | null
  }

  type GetConferenceDatesGroupByPayload<T extends ConferenceDatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceDatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceDatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceDatesGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceDatesGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceDatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizedId?: boolean
    fromDate?: boolean
    toDate?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceDates"]>

  export type ConferenceDatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizedId?: boolean
    fromDate?: boolean
    toDate?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceDates"]>

  export type ConferenceDatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizedId?: boolean
    fromDate?: boolean
    toDate?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceDates"]>

  export type ConferenceDatesSelectScalar = {
    id?: boolean
    organizedId?: boolean
    fromDate?: boolean
    toDate?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAvailable?: boolean
  }

  export type ConferenceDatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizedId" | "fromDate" | "toDate" | "type" | "name" | "createdAt" | "updatedAt" | "isAvailable", ExtArgs["result"]["conferenceDates"]>
  export type ConferenceDatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }
  export type ConferenceDatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }
  export type ConferenceDatesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
  }

  export type $ConferenceDatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceDates"
    objects: {
      belongsTo: Prisma.$ConferenceOrganizationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizedId: string
      fromDate: Date
      toDate: Date
      type: string
      name: string
      createdAt: Date
      updatedAt: Date
      isAvailable: boolean
    }, ExtArgs["result"]["conferenceDates"]>
    composites: {}
  }

  type ConferenceDatesGetPayload<S extends boolean | null | undefined | ConferenceDatesDefaultArgs> = $Result.GetResult<Prisma.$ConferenceDatesPayload, S>

  type ConferenceDatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceDatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceDatesCountAggregateInputType | true
    }

  export interface ConferenceDatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceDates'], meta: { name: 'ConferenceDates' } }
    /**
     * Find zero or one ConferenceDates that matches the filter.
     * @param {ConferenceDatesFindUniqueArgs} args - Arguments to find a ConferenceDates
     * @example
     * // Get one ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceDatesFindUniqueArgs>(args: SelectSubset<T, ConferenceDatesFindUniqueArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceDates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceDatesFindUniqueOrThrowArgs} args - Arguments to find a ConferenceDates
     * @example
     * // Get one ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceDatesFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceDatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesFindFirstArgs} args - Arguments to find a ConferenceDates
     * @example
     * // Get one ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceDatesFindFirstArgs>(args?: SelectSubset<T, ConferenceDatesFindFirstArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceDates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesFindFirstOrThrowArgs} args - Arguments to find a ConferenceDates
     * @example
     * // Get one ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceDatesFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceDatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findMany()
     * 
     * // Get first 10 ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceDatesWithIdOnly = await prisma.conferenceDates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceDatesFindManyArgs>(args?: SelectSubset<T, ConferenceDatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceDates.
     * @param {ConferenceDatesCreateArgs} args - Arguments to create a ConferenceDates.
     * @example
     * // Create one ConferenceDates
     * const ConferenceDates = await prisma.conferenceDates.create({
     *   data: {
     *     // ... data to create a ConferenceDates
     *   }
     * })
     * 
     */
    create<T extends ConferenceDatesCreateArgs>(args: SelectSubset<T, ConferenceDatesCreateArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceDates.
     * @param {ConferenceDatesCreateManyArgs} args - Arguments to create many ConferenceDates.
     * @example
     * // Create many ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceDatesCreateManyArgs>(args?: SelectSubset<T, ConferenceDatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceDates and returns the data saved in the database.
     * @param {ConferenceDatesCreateManyAndReturnArgs} args - Arguments to create many ConferenceDates.
     * @example
     * // Create many ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceDates and only return the `id`
     * const conferenceDatesWithIdOnly = await prisma.conferenceDates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceDatesCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceDatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceDates.
     * @param {ConferenceDatesDeleteArgs} args - Arguments to delete one ConferenceDates.
     * @example
     * // Delete one ConferenceDates
     * const ConferenceDates = await prisma.conferenceDates.delete({
     *   where: {
     *     // ... filter to delete one ConferenceDates
     *   }
     * })
     * 
     */
    delete<T extends ConferenceDatesDeleteArgs>(args: SelectSubset<T, ConferenceDatesDeleteArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceDates.
     * @param {ConferenceDatesUpdateArgs} args - Arguments to update one ConferenceDates.
     * @example
     * // Update one ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceDatesUpdateArgs>(args: SelectSubset<T, ConferenceDatesUpdateArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceDates.
     * @param {ConferenceDatesDeleteManyArgs} args - Arguments to filter ConferenceDates to delete.
     * @example
     * // Delete a few ConferenceDates
     * const { count } = await prisma.conferenceDates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceDatesDeleteManyArgs>(args?: SelectSubset<T, ConferenceDatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceDatesUpdateManyArgs>(args: SelectSubset<T, ConferenceDatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceDates and returns the data updated in the database.
     * @param {ConferenceDatesUpdateManyAndReturnArgs} args - Arguments to update many ConferenceDates.
     * @example
     * // Update many ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceDates and only return the `id`
     * const conferenceDatesWithIdOnly = await prisma.conferenceDates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceDatesUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceDatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceDates.
     * @param {ConferenceDatesUpsertArgs} args - Arguments to update or create a ConferenceDates.
     * @example
     * // Update or create a ConferenceDates
     * const conferenceDates = await prisma.conferenceDates.upsert({
     *   create: {
     *     // ... data to create a ConferenceDates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceDates we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceDatesUpsertArgs>(args: SelectSubset<T, ConferenceDatesUpsertArgs<ExtArgs>>): Prisma__ConferenceDatesClient<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesCountArgs} args - Arguments to filter ConferenceDates to count.
     * @example
     * // Count the number of ConferenceDates
     * const count = await prisma.conferenceDates.count({
     *   where: {
     *     // ... the filter for the ConferenceDates we want to count
     *   }
     * })
    **/
    count<T extends ConferenceDatesCountArgs>(
      args?: Subset<T, ConferenceDatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceDatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceDatesAggregateArgs>(args: Subset<T, ConferenceDatesAggregateArgs>): Prisma.PrismaPromise<GetConferenceDatesAggregateType<T>>

    /**
     * Group by ConferenceDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceDatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceDatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceDatesGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceDatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceDatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceDatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceDates model
   */
  readonly fields: ConferenceDatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceDates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceDatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends ConferenceOrganizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizationsDefaultArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceDates model
   */ 
  interface ConferenceDatesFieldRefs {
    readonly id: FieldRef<"ConferenceDates", 'String'>
    readonly organizedId: FieldRef<"ConferenceDates", 'String'>
    readonly fromDate: FieldRef<"ConferenceDates", 'DateTime'>
    readonly toDate: FieldRef<"ConferenceDates", 'DateTime'>
    readonly type: FieldRef<"ConferenceDates", 'String'>
    readonly name: FieldRef<"ConferenceDates", 'String'>
    readonly createdAt: FieldRef<"ConferenceDates", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceDates", 'DateTime'>
    readonly isAvailable: FieldRef<"ConferenceDates", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceDates findUnique
   */
  export type ConferenceDatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceDates to fetch.
     */
    where: ConferenceDatesWhereUniqueInput
  }

  /**
   * ConferenceDates findUniqueOrThrow
   */
  export type ConferenceDatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceDates to fetch.
     */
    where: ConferenceDatesWhereUniqueInput
  }

  /**
   * ConferenceDates findFirst
   */
  export type ConferenceDatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceDates to fetch.
     */
    where?: ConferenceDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceDates to fetch.
     */
    orderBy?: ConferenceDatesOrderByWithRelationInput | ConferenceDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceDates.
     */
    cursor?: ConferenceDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceDates.
     */
    distinct?: ConferenceDatesScalarFieldEnum | ConferenceDatesScalarFieldEnum[]
  }

  /**
   * ConferenceDates findFirstOrThrow
   */
  export type ConferenceDatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceDates to fetch.
     */
    where?: ConferenceDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceDates to fetch.
     */
    orderBy?: ConferenceDatesOrderByWithRelationInput | ConferenceDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceDates.
     */
    cursor?: ConferenceDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceDates.
     */
    distinct?: ConferenceDatesScalarFieldEnum | ConferenceDatesScalarFieldEnum[]
  }

  /**
   * ConferenceDates findMany
   */
  export type ConferenceDatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceDates to fetch.
     */
    where?: ConferenceDatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceDates to fetch.
     */
    orderBy?: ConferenceDatesOrderByWithRelationInput | ConferenceDatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceDates.
     */
    cursor?: ConferenceDatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceDates.
     */
    skip?: number
    distinct?: ConferenceDatesScalarFieldEnum | ConferenceDatesScalarFieldEnum[]
  }

  /**
   * ConferenceDates create
   */
  export type ConferenceDatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceDates.
     */
    data: XOR<ConferenceDatesCreateInput, ConferenceDatesUncheckedCreateInput>
  }

  /**
   * ConferenceDates createMany
   */
  export type ConferenceDatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceDates.
     */
    data: ConferenceDatesCreateManyInput | ConferenceDatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceDates createManyAndReturn
   */
  export type ConferenceDatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceDates.
     */
    data: ConferenceDatesCreateManyInput | ConferenceDatesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceDates update
   */
  export type ConferenceDatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceDates.
     */
    data: XOR<ConferenceDatesUpdateInput, ConferenceDatesUncheckedUpdateInput>
    /**
     * Choose, which ConferenceDates to update.
     */
    where: ConferenceDatesWhereUniqueInput
  }

  /**
   * ConferenceDates updateMany
   */
  export type ConferenceDatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceDates.
     */
    data: XOR<ConferenceDatesUpdateManyMutationInput, ConferenceDatesUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceDates to update
     */
    where?: ConferenceDatesWhereInput
    /**
     * Limit how many ConferenceDates to update.
     */
    limit?: number
  }

  /**
   * ConferenceDates updateManyAndReturn
   */
  export type ConferenceDatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceDates.
     */
    data: XOR<ConferenceDatesUpdateManyMutationInput, ConferenceDatesUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceDates to update
     */
    where?: ConferenceDatesWhereInput
    /**
     * Limit how many ConferenceDates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceDates upsert
   */
  export type ConferenceDatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceDates to update in case it exists.
     */
    where: ConferenceDatesWhereUniqueInput
    /**
     * In case the ConferenceDates found by the `where` argument doesn't exist, create a new ConferenceDates with this data.
     */
    create: XOR<ConferenceDatesCreateInput, ConferenceDatesUncheckedCreateInput>
    /**
     * In case the ConferenceDates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceDatesUpdateInput, ConferenceDatesUncheckedUpdateInput>
  }

  /**
   * ConferenceDates delete
   */
  export type ConferenceDatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    /**
     * Filter which ConferenceDates to delete.
     */
    where: ConferenceDatesWhereUniqueInput
  }

  /**
   * ConferenceDates deleteMany
   */
  export type ConferenceDatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceDates to delete
     */
    where?: ConferenceDatesWhereInput
    /**
     * Limit how many ConferenceDates to delete.
     */
    limit?: number
  }

  /**
   * ConferenceDates without action
   */
  export type ConferenceDatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceOrganizations
   */

  export type AggregateConferenceOrganizations = {
    _count: ConferenceOrganizationsCountAggregateOutputType | null
    _avg: ConferenceOrganizationsAvgAggregateOutputType | null
    _sum: ConferenceOrganizationsSumAggregateOutputType | null
    _min: ConferenceOrganizationsMinAggregateOutputType | null
    _max: ConferenceOrganizationsMaxAggregateOutputType | null
  }

  export type ConferenceOrganizationsAvgAggregateOutputType = {
    year: number | null
  }

  export type ConferenceOrganizationsSumAggregateOutputType = {
    year: number | null
  }

  export type ConferenceOrganizationsMinAggregateOutputType = {
    id: string | null
    year: number | null
    accessType: string | null
    isAvailable: boolean | null
    conferenceId: string | null
    publisher: string | null
    summerize: string | null
    callForPaper: string | null
    link: string | null
    cfpLink: string | null
    impLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceOrganizationsMaxAggregateOutputType = {
    id: string | null
    year: number | null
    accessType: string | null
    isAvailable: boolean | null
    conferenceId: string | null
    publisher: string | null
    summerize: string | null
    callForPaper: string | null
    link: string | null
    cfpLink: string | null
    impLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceOrganizationsCountAggregateOutputType = {
    id: number
    year: number
    accessType: number
    isAvailable: number
    conferenceId: number
    publisher: number
    summerize: number
    callForPaper: number
    link: number
    cfpLink: number
    impLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceOrganizationsAvgAggregateInputType = {
    year?: true
  }

  export type ConferenceOrganizationsSumAggregateInputType = {
    year?: true
  }

  export type ConferenceOrganizationsMinAggregateInputType = {
    id?: true
    year?: true
    accessType?: true
    isAvailable?: true
    conferenceId?: true
    publisher?: true
    summerize?: true
    callForPaper?: true
    link?: true
    cfpLink?: true
    impLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceOrganizationsMaxAggregateInputType = {
    id?: true
    year?: true
    accessType?: true
    isAvailable?: true
    conferenceId?: true
    publisher?: true
    summerize?: true
    callForPaper?: true
    link?: true
    cfpLink?: true
    impLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceOrganizationsCountAggregateInputType = {
    id?: true
    year?: true
    accessType?: true
    isAvailable?: true
    conferenceId?: true
    publisher?: true
    summerize?: true
    callForPaper?: true
    link?: true
    cfpLink?: true
    impLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceOrganizationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceOrganizations to aggregate.
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceOrganizations to fetch.
     */
    orderBy?: ConferenceOrganizationsOrderByWithRelationInput | ConferenceOrganizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceOrganizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceOrganizations
    **/
    _count?: true | ConferenceOrganizationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceOrganizationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceOrganizationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceOrganizationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceOrganizationsMaxAggregateInputType
  }

  export type GetConferenceOrganizationsAggregateType<T extends ConferenceOrganizationsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceOrganizations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceOrganizations[P]>
      : GetScalarType<T[P], AggregateConferenceOrganizations[P]>
  }




  export type ConferenceOrganizationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceOrganizationsWhereInput
    orderBy?: ConferenceOrganizationsOrderByWithAggregationInput | ConferenceOrganizationsOrderByWithAggregationInput[]
    by: ConferenceOrganizationsScalarFieldEnum[] | ConferenceOrganizationsScalarFieldEnum
    having?: ConferenceOrganizationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceOrganizationsCountAggregateInputType | true
    _avg?: ConferenceOrganizationsAvgAggregateInputType
    _sum?: ConferenceOrganizationsSumAggregateInputType
    _min?: ConferenceOrganizationsMinAggregateInputType
    _max?: ConferenceOrganizationsMaxAggregateInputType
  }

  export type ConferenceOrganizationsGroupByOutputType = {
    id: string
    year: number
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceOrganizationsCountAggregateOutputType | null
    _avg: ConferenceOrganizationsAvgAggregateOutputType | null
    _sum: ConferenceOrganizationsSumAggregateOutputType | null
    _min: ConferenceOrganizationsMinAggregateOutputType | null
    _max: ConferenceOrganizationsMaxAggregateOutputType | null
  }

  type GetConferenceOrganizationsGroupByPayload<T extends ConferenceOrganizationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceOrganizationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceOrganizationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceOrganizationsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceOrganizationsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceOrganizationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    accessType?: boolean
    isAvailable?: boolean
    conferenceId?: boolean
    publisher?: boolean
    summerize?: boolean
    callForPaper?: boolean
    link?: boolean
    cfpLink?: boolean
    impLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conferenceDates?: boolean | ConferenceOrganizations$conferenceDatesArgs<ExtArgs>
    locations?: boolean | ConferenceOrganizations$locationsArgs<ExtArgs>
    topics?: boolean | ConferenceOrganizations$topicsArgs<ExtArgs>
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    _count?: boolean | ConferenceOrganizationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceOrganizations"]>

  export type ConferenceOrganizationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    accessType?: boolean
    isAvailable?: boolean
    conferenceId?: boolean
    publisher?: boolean
    summerize?: boolean
    callForPaper?: boolean
    link?: boolean
    cfpLink?: boolean
    impLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceOrganizations"]>

  export type ConferenceOrganizationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    accessType?: boolean
    isAvailable?: boolean
    conferenceId?: boolean
    publisher?: boolean
    summerize?: boolean
    callForPaper?: boolean
    link?: boolean
    cfpLink?: boolean
    impLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceOrganizations"]>

  export type ConferenceOrganizationsSelectScalar = {
    id?: boolean
    year?: boolean
    accessType?: boolean
    isAvailable?: boolean
    conferenceId?: boolean
    publisher?: boolean
    summerize?: boolean
    callForPaper?: boolean
    link?: boolean
    cfpLink?: boolean
    impLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceOrganizationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "accessType" | "isAvailable" | "conferenceId" | "publisher" | "summerize" | "callForPaper" | "link" | "cfpLink" | "impLink" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceOrganizations"]>
  export type ConferenceOrganizationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conferenceDates?: boolean | ConferenceOrganizations$conferenceDatesArgs<ExtArgs>
    locations?: boolean | ConferenceOrganizations$locationsArgs<ExtArgs>
    topics?: boolean | ConferenceOrganizations$topicsArgs<ExtArgs>
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    _count?: boolean | ConferenceOrganizationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConferenceOrganizationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }
  export type ConferenceOrganizationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }

  export type $ConferenceOrganizationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceOrganizations"
    objects: {
      conferenceDates: Prisma.$ConferenceDatesPayload<ExtArgs>[]
      locations: Prisma.$LocationsPayload<ExtArgs>[]
      topics: Prisma.$ConferenceTopicsPayload<ExtArgs>[]
      belongsTo: Prisma.$ConferencesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      accessType: string
      isAvailable: boolean
      conferenceId: string
      publisher: string
      summerize: string
      callForPaper: string
      link: string
      cfpLink: string
      impLink: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceOrganizations"]>
    composites: {}
  }

  type ConferenceOrganizationsGetPayload<S extends boolean | null | undefined | ConferenceOrganizationsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceOrganizationsPayload, S>

  type ConferenceOrganizationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceOrganizationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceOrganizationsCountAggregateInputType | true
    }

  export interface ConferenceOrganizationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceOrganizations'], meta: { name: 'ConferenceOrganizations' } }
    /**
     * Find zero or one ConferenceOrganizations that matches the filter.
     * @param {ConferenceOrganizationsFindUniqueArgs} args - Arguments to find a ConferenceOrganizations
     * @example
     * // Get one ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceOrganizationsFindUniqueArgs>(args: SelectSubset<T, ConferenceOrganizationsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceOrganizations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceOrganizationsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceOrganizations
     * @example
     * // Get one ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceOrganizationsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceOrganizationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsFindFirstArgs} args - Arguments to find a ConferenceOrganizations
     * @example
     * // Get one ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceOrganizationsFindFirstArgs>(args?: SelectSubset<T, ConferenceOrganizationsFindFirstArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceOrganizations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsFindFirstOrThrowArgs} args - Arguments to find a ConferenceOrganizations
     * @example
     * // Get one ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceOrganizationsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceOrganizationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceOrganizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findMany()
     * 
     * // Get first 10 ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceOrganizationsWithIdOnly = await prisma.conferenceOrganizations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceOrganizationsFindManyArgs>(args?: SelectSubset<T, ConferenceOrganizationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceOrganizations.
     * @param {ConferenceOrganizationsCreateArgs} args - Arguments to create a ConferenceOrganizations.
     * @example
     * // Create one ConferenceOrganizations
     * const ConferenceOrganizations = await prisma.conferenceOrganizations.create({
     *   data: {
     *     // ... data to create a ConferenceOrganizations
     *   }
     * })
     * 
     */
    create<T extends ConferenceOrganizationsCreateArgs>(args: SelectSubset<T, ConferenceOrganizationsCreateArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceOrganizations.
     * @param {ConferenceOrganizationsCreateManyArgs} args - Arguments to create many ConferenceOrganizations.
     * @example
     * // Create many ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceOrganizationsCreateManyArgs>(args?: SelectSubset<T, ConferenceOrganizationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceOrganizations and returns the data saved in the database.
     * @param {ConferenceOrganizationsCreateManyAndReturnArgs} args - Arguments to create many ConferenceOrganizations.
     * @example
     * // Create many ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceOrganizations and only return the `id`
     * const conferenceOrganizationsWithIdOnly = await prisma.conferenceOrganizations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceOrganizationsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceOrganizationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceOrganizations.
     * @param {ConferenceOrganizationsDeleteArgs} args - Arguments to delete one ConferenceOrganizations.
     * @example
     * // Delete one ConferenceOrganizations
     * const ConferenceOrganizations = await prisma.conferenceOrganizations.delete({
     *   where: {
     *     // ... filter to delete one ConferenceOrganizations
     *   }
     * })
     * 
     */
    delete<T extends ConferenceOrganizationsDeleteArgs>(args: SelectSubset<T, ConferenceOrganizationsDeleteArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceOrganizations.
     * @param {ConferenceOrganizationsUpdateArgs} args - Arguments to update one ConferenceOrganizations.
     * @example
     * // Update one ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceOrganizationsUpdateArgs>(args: SelectSubset<T, ConferenceOrganizationsUpdateArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceOrganizations.
     * @param {ConferenceOrganizationsDeleteManyArgs} args - Arguments to filter ConferenceOrganizations to delete.
     * @example
     * // Delete a few ConferenceOrganizations
     * const { count } = await prisma.conferenceOrganizations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceOrganizationsDeleteManyArgs>(args?: SelectSubset<T, ConferenceOrganizationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceOrganizationsUpdateManyArgs>(args: SelectSubset<T, ConferenceOrganizationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceOrganizations and returns the data updated in the database.
     * @param {ConferenceOrganizationsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceOrganizations.
     * @example
     * // Update many ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceOrganizations and only return the `id`
     * const conferenceOrganizationsWithIdOnly = await prisma.conferenceOrganizations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceOrganizationsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceOrganizationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceOrganizations.
     * @param {ConferenceOrganizationsUpsertArgs} args - Arguments to update or create a ConferenceOrganizations.
     * @example
     * // Update or create a ConferenceOrganizations
     * const conferenceOrganizations = await prisma.conferenceOrganizations.upsert({
     *   create: {
     *     // ... data to create a ConferenceOrganizations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceOrganizations we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceOrganizationsUpsertArgs>(args: SelectSubset<T, ConferenceOrganizationsUpsertArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsCountArgs} args - Arguments to filter ConferenceOrganizations to count.
     * @example
     * // Count the number of ConferenceOrganizations
     * const count = await prisma.conferenceOrganizations.count({
     *   where: {
     *     // ... the filter for the ConferenceOrganizations we want to count
     *   }
     * })
    **/
    count<T extends ConferenceOrganizationsCountArgs>(
      args?: Subset<T, ConferenceOrganizationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceOrganizationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceOrganizationsAggregateArgs>(args: Subset<T, ConferenceOrganizationsAggregateArgs>): Prisma.PrismaPromise<GetConferenceOrganizationsAggregateType<T>>

    /**
     * Group by ConferenceOrganizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceOrganizationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceOrganizationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceOrganizationsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceOrganizationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceOrganizationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceOrganizationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceOrganizations model
   */
  readonly fields: ConferenceOrganizationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceOrganizations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceOrganizationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conferenceDates<T extends ConferenceOrganizations$conferenceDatesArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizations$conferenceDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceDatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends ConferenceOrganizations$locationsArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizations$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    topics<T extends ConferenceOrganizations$topicsArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizations$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    belongsTo<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceOrganizations model
   */ 
  interface ConferenceOrganizationsFieldRefs {
    readonly id: FieldRef<"ConferenceOrganizations", 'String'>
    readonly year: FieldRef<"ConferenceOrganizations", 'Int'>
    readonly accessType: FieldRef<"ConferenceOrganizations", 'String'>
    readonly isAvailable: FieldRef<"ConferenceOrganizations", 'Boolean'>
    readonly conferenceId: FieldRef<"ConferenceOrganizations", 'String'>
    readonly publisher: FieldRef<"ConferenceOrganizations", 'String'>
    readonly summerize: FieldRef<"ConferenceOrganizations", 'String'>
    readonly callForPaper: FieldRef<"ConferenceOrganizations", 'String'>
    readonly link: FieldRef<"ConferenceOrganizations", 'String'>
    readonly cfpLink: FieldRef<"ConferenceOrganizations", 'String'>
    readonly impLink: FieldRef<"ConferenceOrganizations", 'String'>
    readonly createdAt: FieldRef<"ConferenceOrganizations", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceOrganizations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceOrganizations findUnique
   */
  export type ConferenceOrganizationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceOrganizations to fetch.
     */
    where: ConferenceOrganizationsWhereUniqueInput
  }

  /**
   * ConferenceOrganizations findUniqueOrThrow
   */
  export type ConferenceOrganizationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceOrganizations to fetch.
     */
    where: ConferenceOrganizationsWhereUniqueInput
  }

  /**
   * ConferenceOrganizations findFirst
   */
  export type ConferenceOrganizationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceOrganizations to fetch.
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceOrganizations to fetch.
     */
    orderBy?: ConferenceOrganizationsOrderByWithRelationInput | ConferenceOrganizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceOrganizations.
     */
    cursor?: ConferenceOrganizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceOrganizations.
     */
    distinct?: ConferenceOrganizationsScalarFieldEnum | ConferenceOrganizationsScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations findFirstOrThrow
   */
  export type ConferenceOrganizationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceOrganizations to fetch.
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceOrganizations to fetch.
     */
    orderBy?: ConferenceOrganizationsOrderByWithRelationInput | ConferenceOrganizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceOrganizations.
     */
    cursor?: ConferenceOrganizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceOrganizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceOrganizations.
     */
    distinct?: ConferenceOrganizationsScalarFieldEnum | ConferenceOrganizationsScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations findMany
   */
  export type ConferenceOrganizationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceOrganizations to fetch.
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceOrganizations to fetch.
     */
    orderBy?: ConferenceOrganizationsOrderByWithRelationInput | ConferenceOrganizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceOrganizations.
     */
    cursor?: ConferenceOrganizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceOrganizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceOrganizations.
     */
    skip?: number
    distinct?: ConferenceOrganizationsScalarFieldEnum | ConferenceOrganizationsScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations create
   */
  export type ConferenceOrganizationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceOrganizations.
     */
    data: XOR<ConferenceOrganizationsCreateInput, ConferenceOrganizationsUncheckedCreateInput>
  }

  /**
   * ConferenceOrganizations createMany
   */
  export type ConferenceOrganizationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceOrganizations.
     */
    data: ConferenceOrganizationsCreateManyInput | ConferenceOrganizationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceOrganizations createManyAndReturn
   */
  export type ConferenceOrganizationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceOrganizations.
     */
    data: ConferenceOrganizationsCreateManyInput | ConferenceOrganizationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceOrganizations update
   */
  export type ConferenceOrganizationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceOrganizations.
     */
    data: XOR<ConferenceOrganizationsUpdateInput, ConferenceOrganizationsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceOrganizations to update.
     */
    where: ConferenceOrganizationsWhereUniqueInput
  }

  /**
   * ConferenceOrganizations updateMany
   */
  export type ConferenceOrganizationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceOrganizations.
     */
    data: XOR<ConferenceOrganizationsUpdateManyMutationInput, ConferenceOrganizationsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceOrganizations to update
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * Limit how many ConferenceOrganizations to update.
     */
    limit?: number
  }

  /**
   * ConferenceOrganizations updateManyAndReturn
   */
  export type ConferenceOrganizationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceOrganizations.
     */
    data: XOR<ConferenceOrganizationsUpdateManyMutationInput, ConferenceOrganizationsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceOrganizations to update
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * Limit how many ConferenceOrganizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceOrganizations upsert
   */
  export type ConferenceOrganizationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceOrganizations to update in case it exists.
     */
    where: ConferenceOrganizationsWhereUniqueInput
    /**
     * In case the ConferenceOrganizations found by the `where` argument doesn't exist, create a new ConferenceOrganizations with this data.
     */
    create: XOR<ConferenceOrganizationsCreateInput, ConferenceOrganizationsUncheckedCreateInput>
    /**
     * In case the ConferenceOrganizations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceOrganizationsUpdateInput, ConferenceOrganizationsUncheckedUpdateInput>
  }

  /**
   * ConferenceOrganizations delete
   */
  export type ConferenceOrganizationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceOrganizations to delete.
     */
    where: ConferenceOrganizationsWhereUniqueInput
  }

  /**
   * ConferenceOrganizations deleteMany
   */
  export type ConferenceOrganizationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceOrganizations to delete
     */
    where?: ConferenceOrganizationsWhereInput
    /**
     * Limit how many ConferenceOrganizations to delete.
     */
    limit?: number
  }

  /**
   * ConferenceOrganizations.conferenceDates
   */
  export type ConferenceOrganizations$conferenceDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceDates
     */
    select?: ConferenceDatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceDates
     */
    omit?: ConferenceDatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceDatesInclude<ExtArgs> | null
    where?: ConferenceDatesWhereInput
    orderBy?: ConferenceDatesOrderByWithRelationInput | ConferenceDatesOrderByWithRelationInput[]
    cursor?: ConferenceDatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceDatesScalarFieldEnum | ConferenceDatesScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations.locations
   */
  export type ConferenceOrganizations$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Locations
     */
    omit?: LocationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    where?: LocationsWhereInput
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    cursor?: LocationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations.topics
   */
  export type ConferenceOrganizations$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    where?: ConferenceTopicsWhereInput
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    cursor?: ConferenceTopicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceTopicsScalarFieldEnum | ConferenceTopicsScalarFieldEnum[]
  }

  /**
   * ConferenceOrganizations without action
   */
  export type ConferenceOrganizationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceTopics
   */

  export type AggregateConferenceTopics = {
    _count: ConferenceTopicsCountAggregateOutputType | null
    _min: ConferenceTopicsMinAggregateOutputType | null
    _max: ConferenceTopicsMaxAggregateOutputType | null
  }

  export type ConferenceTopicsMinAggregateOutputType = {
    id: string | null
    organizeId: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceTopicsMaxAggregateOutputType = {
    id: string | null
    organizeId: string | null
    topicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceTopicsCountAggregateOutputType = {
    id: number
    organizeId: number
    topicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceTopicsMinAggregateInputType = {
    id?: true
    organizeId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceTopicsMaxAggregateInputType = {
    id?: true
    organizeId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceTopicsCountAggregateInputType = {
    id?: true
    organizeId?: true
    topicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceTopicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceTopics to aggregate.
     */
    where?: ConferenceTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceTopics to fetch.
     */
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceTopics
    **/
    _count?: true | ConferenceTopicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceTopicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceTopicsMaxAggregateInputType
  }

  export type GetConferenceTopicsAggregateType<T extends ConferenceTopicsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceTopics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceTopics[P]>
      : GetScalarType<T[P], AggregateConferenceTopics[P]>
  }




  export type ConferenceTopicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceTopicsWhereInput
    orderBy?: ConferenceTopicsOrderByWithAggregationInput | ConferenceTopicsOrderByWithAggregationInput[]
    by: ConferenceTopicsScalarFieldEnum[] | ConferenceTopicsScalarFieldEnum
    having?: ConferenceTopicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceTopicsCountAggregateInputType | true
    _min?: ConferenceTopicsMinAggregateInputType
    _max?: ConferenceTopicsMaxAggregateInputType
  }

  export type ConferenceTopicsGroupByOutputType = {
    id: string
    organizeId: string
    topicId: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceTopicsCountAggregateOutputType | null
    _min: ConferenceTopicsMinAggregateOutputType | null
    _max: ConferenceTopicsMaxAggregateOutputType | null
  }

  type GetConferenceTopicsGroupByPayload<T extends ConferenceTopicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceTopicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceTopicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceTopicsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceTopicsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceTopicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizeId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    inTopic?: boolean | TopicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceTopics"]>

  export type ConferenceTopicsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizeId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    inTopic?: boolean | TopicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceTopics"]>

  export type ConferenceTopicsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizeId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    inTopic?: boolean | TopicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceTopics"]>

  export type ConferenceTopicsSelectScalar = {
    id?: boolean
    organizeId?: boolean
    topicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceTopicsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizeId" | "topicId" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceTopics"]>
  export type ConferenceTopicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    inTopic?: boolean | TopicsDefaultArgs<ExtArgs>
  }
  export type ConferenceTopicsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    inTopic?: boolean | TopicsDefaultArgs<ExtArgs>
  }
  export type ConferenceTopicsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferenceOrganizationsDefaultArgs<ExtArgs>
    inTopic?: boolean | TopicsDefaultArgs<ExtArgs>
  }

  export type $ConferenceTopicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceTopics"
    objects: {
      belongsTo: Prisma.$ConferenceOrganizationsPayload<ExtArgs>
      inTopic: Prisma.$TopicsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizeId: string
      topicId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceTopics"]>
    composites: {}
  }

  type ConferenceTopicsGetPayload<S extends boolean | null | undefined | ConferenceTopicsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceTopicsPayload, S>

  type ConferenceTopicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceTopicsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceTopicsCountAggregateInputType | true
    }

  export interface ConferenceTopicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceTopics'], meta: { name: 'ConferenceTopics' } }
    /**
     * Find zero or one ConferenceTopics that matches the filter.
     * @param {ConferenceTopicsFindUniqueArgs} args - Arguments to find a ConferenceTopics
     * @example
     * // Get one ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceTopicsFindUniqueArgs>(args: SelectSubset<T, ConferenceTopicsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceTopics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceTopicsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceTopics
     * @example
     * // Get one ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceTopicsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceTopicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsFindFirstArgs} args - Arguments to find a ConferenceTopics
     * @example
     * // Get one ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceTopicsFindFirstArgs>(args?: SelectSubset<T, ConferenceTopicsFindFirstArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceTopics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsFindFirstOrThrowArgs} args - Arguments to find a ConferenceTopics
     * @example
     * // Get one ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceTopicsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceTopicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findMany()
     * 
     * // Get first 10 ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceTopicsWithIdOnly = await prisma.conferenceTopics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceTopicsFindManyArgs>(args?: SelectSubset<T, ConferenceTopicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceTopics.
     * @param {ConferenceTopicsCreateArgs} args - Arguments to create a ConferenceTopics.
     * @example
     * // Create one ConferenceTopics
     * const ConferenceTopics = await prisma.conferenceTopics.create({
     *   data: {
     *     // ... data to create a ConferenceTopics
     *   }
     * })
     * 
     */
    create<T extends ConferenceTopicsCreateArgs>(args: SelectSubset<T, ConferenceTopicsCreateArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceTopics.
     * @param {ConferenceTopicsCreateManyArgs} args - Arguments to create many ConferenceTopics.
     * @example
     * // Create many ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceTopicsCreateManyArgs>(args?: SelectSubset<T, ConferenceTopicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceTopics and returns the data saved in the database.
     * @param {ConferenceTopicsCreateManyAndReturnArgs} args - Arguments to create many ConferenceTopics.
     * @example
     * // Create many ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceTopics and only return the `id`
     * const conferenceTopicsWithIdOnly = await prisma.conferenceTopics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceTopicsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceTopicsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceTopics.
     * @param {ConferenceTopicsDeleteArgs} args - Arguments to delete one ConferenceTopics.
     * @example
     * // Delete one ConferenceTopics
     * const ConferenceTopics = await prisma.conferenceTopics.delete({
     *   where: {
     *     // ... filter to delete one ConferenceTopics
     *   }
     * })
     * 
     */
    delete<T extends ConferenceTopicsDeleteArgs>(args: SelectSubset<T, ConferenceTopicsDeleteArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceTopics.
     * @param {ConferenceTopicsUpdateArgs} args - Arguments to update one ConferenceTopics.
     * @example
     * // Update one ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceTopicsUpdateArgs>(args: SelectSubset<T, ConferenceTopicsUpdateArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceTopics.
     * @param {ConferenceTopicsDeleteManyArgs} args - Arguments to filter ConferenceTopics to delete.
     * @example
     * // Delete a few ConferenceTopics
     * const { count } = await prisma.conferenceTopics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceTopicsDeleteManyArgs>(args?: SelectSubset<T, ConferenceTopicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceTopicsUpdateManyArgs>(args: SelectSubset<T, ConferenceTopicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceTopics and returns the data updated in the database.
     * @param {ConferenceTopicsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceTopics.
     * @example
     * // Update many ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceTopics and only return the `id`
     * const conferenceTopicsWithIdOnly = await prisma.conferenceTopics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceTopicsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceTopicsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceTopics.
     * @param {ConferenceTopicsUpsertArgs} args - Arguments to update or create a ConferenceTopics.
     * @example
     * // Update or create a ConferenceTopics
     * const conferenceTopics = await prisma.conferenceTopics.upsert({
     *   create: {
     *     // ... data to create a ConferenceTopics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceTopics we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceTopicsUpsertArgs>(args: SelectSubset<T, ConferenceTopicsUpsertArgs<ExtArgs>>): Prisma__ConferenceTopicsClient<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsCountArgs} args - Arguments to filter ConferenceTopics to count.
     * @example
     * // Count the number of ConferenceTopics
     * const count = await prisma.conferenceTopics.count({
     *   where: {
     *     // ... the filter for the ConferenceTopics we want to count
     *   }
     * })
    **/
    count<T extends ConferenceTopicsCountArgs>(
      args?: Subset<T, ConferenceTopicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceTopicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceTopicsAggregateArgs>(args: Subset<T, ConferenceTopicsAggregateArgs>): Prisma.PrismaPromise<GetConferenceTopicsAggregateType<T>>

    /**
     * Group by ConferenceTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceTopicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceTopicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceTopicsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceTopicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceTopicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceTopicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceTopics model
   */
  readonly fields: ConferenceTopicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceTopics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceTopicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends ConferenceOrganizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferenceOrganizationsDefaultArgs<ExtArgs>>): Prisma__ConferenceOrganizationsClient<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inTopic<T extends TopicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicsDefaultArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceTopics model
   */ 
  interface ConferenceTopicsFieldRefs {
    readonly id: FieldRef<"ConferenceTopics", 'String'>
    readonly organizeId: FieldRef<"ConferenceTopics", 'String'>
    readonly topicId: FieldRef<"ConferenceTopics", 'String'>
    readonly createdAt: FieldRef<"ConferenceTopics", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceTopics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceTopics findUnique
   */
  export type ConferenceTopicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceTopics to fetch.
     */
    where: ConferenceTopicsWhereUniqueInput
  }

  /**
   * ConferenceTopics findUniqueOrThrow
   */
  export type ConferenceTopicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceTopics to fetch.
     */
    where: ConferenceTopicsWhereUniqueInput
  }

  /**
   * ConferenceTopics findFirst
   */
  export type ConferenceTopicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceTopics to fetch.
     */
    where?: ConferenceTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceTopics to fetch.
     */
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceTopics.
     */
    cursor?: ConferenceTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceTopics.
     */
    distinct?: ConferenceTopicsScalarFieldEnum | ConferenceTopicsScalarFieldEnum[]
  }

  /**
   * ConferenceTopics findFirstOrThrow
   */
  export type ConferenceTopicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceTopics to fetch.
     */
    where?: ConferenceTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceTopics to fetch.
     */
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceTopics.
     */
    cursor?: ConferenceTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceTopics.
     */
    distinct?: ConferenceTopicsScalarFieldEnum | ConferenceTopicsScalarFieldEnum[]
  }

  /**
   * ConferenceTopics findMany
   */
  export type ConferenceTopicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceTopics to fetch.
     */
    where?: ConferenceTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceTopics to fetch.
     */
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceTopics.
     */
    cursor?: ConferenceTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceTopics.
     */
    skip?: number
    distinct?: ConferenceTopicsScalarFieldEnum | ConferenceTopicsScalarFieldEnum[]
  }

  /**
   * ConferenceTopics create
   */
  export type ConferenceTopicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceTopics.
     */
    data: XOR<ConferenceTopicsCreateInput, ConferenceTopicsUncheckedCreateInput>
  }

  /**
   * ConferenceTopics createMany
   */
  export type ConferenceTopicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceTopics.
     */
    data: ConferenceTopicsCreateManyInput | ConferenceTopicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceTopics createManyAndReturn
   */
  export type ConferenceTopicsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceTopics.
     */
    data: ConferenceTopicsCreateManyInput | ConferenceTopicsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceTopics update
   */
  export type ConferenceTopicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceTopics.
     */
    data: XOR<ConferenceTopicsUpdateInput, ConferenceTopicsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceTopics to update.
     */
    where: ConferenceTopicsWhereUniqueInput
  }

  /**
   * ConferenceTopics updateMany
   */
  export type ConferenceTopicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceTopics.
     */
    data: XOR<ConferenceTopicsUpdateManyMutationInput, ConferenceTopicsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceTopics to update
     */
    where?: ConferenceTopicsWhereInput
    /**
     * Limit how many ConferenceTopics to update.
     */
    limit?: number
  }

  /**
   * ConferenceTopics updateManyAndReturn
   */
  export type ConferenceTopicsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceTopics.
     */
    data: XOR<ConferenceTopicsUpdateManyMutationInput, ConferenceTopicsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceTopics to update
     */
    where?: ConferenceTopicsWhereInput
    /**
     * Limit how many ConferenceTopics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceTopics upsert
   */
  export type ConferenceTopicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceTopics to update in case it exists.
     */
    where: ConferenceTopicsWhereUniqueInput
    /**
     * In case the ConferenceTopics found by the `where` argument doesn't exist, create a new ConferenceTopics with this data.
     */
    create: XOR<ConferenceTopicsCreateInput, ConferenceTopicsUncheckedCreateInput>
    /**
     * In case the ConferenceTopics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceTopicsUpdateInput, ConferenceTopicsUncheckedUpdateInput>
  }

  /**
   * ConferenceTopics delete
   */
  export type ConferenceTopicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceTopics to delete.
     */
    where: ConferenceTopicsWhereUniqueInput
  }

  /**
   * ConferenceTopics deleteMany
   */
  export type ConferenceTopicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceTopics to delete
     */
    where?: ConferenceTopicsWhereInput
    /**
     * Limit how many ConferenceTopics to delete.
     */
    limit?: number
  }

  /**
   * ConferenceTopics without action
   */
  export type ConferenceTopicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
  }


  /**
   * Model Topics
   */

  export type AggregateTopics = {
    _count: TopicsCountAggregateOutputType | null
    _min: TopicsMinAggregateOutputType | null
    _max: TopicsMaxAggregateOutputType | null
  }

  export type TopicsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopicsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to aggregate.
     */
    where?: TopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicsOrderByWithRelationInput | TopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicsMaxAggregateInputType
  }

  export type GetTopicsAggregateType<T extends TopicsAggregateArgs> = {
        [P in keyof T & keyof AggregateTopics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopics[P]>
      : GetScalarType<T[P], AggregateTopics[P]>
  }




  export type TopicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicsWhereInput
    orderBy?: TopicsOrderByWithAggregationInput | TopicsOrderByWithAggregationInput[]
    by: TopicsScalarFieldEnum[] | TopicsScalarFieldEnum
    having?: TopicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicsCountAggregateInputType | true
    _min?: TopicsMinAggregateInputType
    _max?: TopicsMaxAggregateInputType
  }

  export type TopicsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TopicsCountAggregateOutputType | null
    _min: TopicsMinAggregateOutputType | null
    _max: TopicsMaxAggregateOutputType | null
  }

  type GetTopicsGroupByPayload<T extends TopicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicsGroupByOutputType[P]>
            : GetScalarType<T[P], TopicsGroupByOutputType[P]>
        }
      >
    >


  export type TopicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inConferenceTopics?: boolean | Topics$inConferenceTopicsArgs<ExtArgs>
    inJournalTopics?: boolean | Topics$inJournalTopicsArgs<ExtArgs>
    _count?: boolean | TopicsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topics"]>

  export type TopicsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["topics"]>

  export type TopicsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["topics"]>

  export type TopicsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TopicsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["topics"]>
  export type TopicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inConferenceTopics?: boolean | Topics$inConferenceTopicsArgs<ExtArgs>
    inJournalTopics?: boolean | Topics$inJournalTopicsArgs<ExtArgs>
    _count?: boolean | TopicsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TopicsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TopicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topics"
    objects: {
      inConferenceTopics: Prisma.$ConferenceTopicsPayload<ExtArgs>[]
      inJournalTopics: Prisma.$JournalTopicsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["topics"]>
    composites: {}
  }

  type TopicsGetPayload<S extends boolean | null | undefined | TopicsDefaultArgs> = $Result.GetResult<Prisma.$TopicsPayload, S>

  type TopicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicsCountAggregateInputType | true
    }

  export interface TopicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topics'], meta: { name: 'Topics' } }
    /**
     * Find zero or one Topics that matches the filter.
     * @param {TopicsFindUniqueArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicsFindUniqueArgs>(args: SelectSubset<T, TopicsFindUniqueArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Topics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicsFindUniqueOrThrowArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicsFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsFindFirstArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicsFindFirstArgs>(args?: SelectSubset<T, TopicsFindFirstArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsFindFirstOrThrowArgs} args - Arguments to find a Topics
     * @example
     * // Get one Topics
     * const topics = await prisma.topics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicsFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topics.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicsWithIdOnly = await prisma.topics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicsFindManyArgs>(args?: SelectSubset<T, TopicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Topics.
     * @param {TopicsCreateArgs} args - Arguments to create a Topics.
     * @example
     * // Create one Topics
     * const Topics = await prisma.topics.create({
     *   data: {
     *     // ... data to create a Topics
     *   }
     * })
     * 
     */
    create<T extends TopicsCreateArgs>(args: SelectSubset<T, TopicsCreateArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Topics.
     * @param {TopicsCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topics = await prisma.topics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicsCreateManyArgs>(args?: SelectSubset<T, TopicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicsCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topics = await prisma.topics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicsWithIdOnly = await prisma.topics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicsCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Topics.
     * @param {TopicsDeleteArgs} args - Arguments to delete one Topics.
     * @example
     * // Delete one Topics
     * const Topics = await prisma.topics.delete({
     *   where: {
     *     // ... filter to delete one Topics
     *   }
     * })
     * 
     */
    delete<T extends TopicsDeleteArgs>(args: SelectSubset<T, TopicsDeleteArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Topics.
     * @param {TopicsUpdateArgs} args - Arguments to update one Topics.
     * @example
     * // Update one Topics
     * const topics = await prisma.topics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicsUpdateArgs>(args: SelectSubset<T, TopicsUpdateArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Topics.
     * @param {TopicsDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicsDeleteManyArgs>(args?: SelectSubset<T, TopicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topics = await prisma.topics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicsUpdateManyArgs>(args: SelectSubset<T, TopicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics and returns the data updated in the database.
     * @param {TopicsUpdateManyAndReturnArgs} args - Arguments to update many Topics.
     * @example
     * // Update many Topics
     * const topics = await prisma.topics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Topics and only return the `id`
     * const topicsWithIdOnly = await prisma.topics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicsUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Topics.
     * @param {TopicsUpsertArgs} args - Arguments to update or create a Topics.
     * @example
     * // Update or create a Topics
     * const topics = await prisma.topics.upsert({
     *   create: {
     *     // ... data to create a Topics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topics we want to update
     *   }
     * })
     */
    upsert<T extends TopicsUpsertArgs>(args: SelectSubset<T, TopicsUpsertArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topics.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicsCountArgs>(
      args?: Subset<T, TopicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicsAggregateArgs>(args: Subset<T, TopicsAggregateArgs>): Prisma.PrismaPromise<GetTopicsAggregateType<T>>

    /**
     * Group by Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicsGroupByArgs['orderBy'] }
        : { orderBy?: TopicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topics model
   */
  readonly fields: TopicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inConferenceTopics<T extends Topics$inConferenceTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Topics$inConferenceTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inJournalTopics<T extends Topics$inJournalTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Topics$inJournalTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topics model
   */ 
  interface TopicsFieldRefs {
    readonly id: FieldRef<"Topics", 'String'>
    readonly name: FieldRef<"Topics", 'String'>
    readonly createdAt: FieldRef<"Topics", 'DateTime'>
    readonly updatedAt: FieldRef<"Topics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Topics findUnique
   */
  export type TopicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where: TopicsWhereUniqueInput
  }

  /**
   * Topics findUniqueOrThrow
   */
  export type TopicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where: TopicsWhereUniqueInput
  }

  /**
   * Topics findFirst
   */
  export type TopicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicsOrderByWithRelationInput | TopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicsScalarFieldEnum | TopicsScalarFieldEnum[]
  }

  /**
   * Topics findFirstOrThrow
   */
  export type TopicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicsOrderByWithRelationInput | TopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicsScalarFieldEnum | TopicsScalarFieldEnum[]
  }

  /**
   * Topics findMany
   */
  export type TopicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicsOrderByWithRelationInput | TopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicsScalarFieldEnum | TopicsScalarFieldEnum[]
  }

  /**
   * Topics create
   */
  export type TopicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * The data needed to create a Topics.
     */
    data: XOR<TopicsCreateInput, TopicsUncheckedCreateInput>
  }

  /**
   * Topics createMany
   */
  export type TopicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicsCreateManyInput | TopicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topics createManyAndReturn
   */
  export type TopicsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicsCreateManyInput | TopicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topics update
   */
  export type TopicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * The data needed to update a Topics.
     */
    data: XOR<TopicsUpdateInput, TopicsUncheckedUpdateInput>
    /**
     * Choose, which Topics to update.
     */
    where: TopicsWhereUniqueInput
  }

  /**
   * Topics updateMany
   */
  export type TopicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicsUpdateManyMutationInput, TopicsUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicsWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topics updateManyAndReturn
   */
  export type TopicsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicsUpdateManyMutationInput, TopicsUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicsWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topics upsert
   */
  export type TopicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * The filter to search for the Topics to update in case it exists.
     */
    where: TopicsWhereUniqueInput
    /**
     * In case the Topics found by the `where` argument doesn't exist, create a new Topics with this data.
     */
    create: XOR<TopicsCreateInput, TopicsUncheckedCreateInput>
    /**
     * In case the Topics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicsUpdateInput, TopicsUncheckedUpdateInput>
  }

  /**
   * Topics delete
   */
  export type TopicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
    /**
     * Filter which Topics to delete.
     */
    where: TopicsWhereUniqueInput
  }

  /**
   * Topics deleteMany
   */
  export type TopicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicsWhereInput
    /**
     * Limit how many Topics to delete.
     */
    limit?: number
  }

  /**
   * Topics.inConferenceTopics
   */
  export type Topics$inConferenceTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceTopics
     */
    select?: ConferenceTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceTopics
     */
    omit?: ConferenceTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceTopicsInclude<ExtArgs> | null
    where?: ConferenceTopicsWhereInput
    orderBy?: ConferenceTopicsOrderByWithRelationInput | ConferenceTopicsOrderByWithRelationInput[]
    cursor?: ConferenceTopicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceTopicsScalarFieldEnum | ConferenceTopicsScalarFieldEnum[]
  }

  /**
   * Topics.inJournalTopics
   */
  export type Topics$inJournalTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    where?: JournalTopicsWhereInput
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    cursor?: JournalTopicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalTopicsScalarFieldEnum | JournalTopicsScalarFieldEnum[]
  }

  /**
   * Topics without action
   */
  export type TopicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topics
     */
    select?: TopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topics
     */
    omit?: TopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicsInclude<ExtArgs> | null
  }


  /**
   * Model Conferences
   */

  export type AggregateConferences = {
    _count: ConferencesCountAggregateOutputType | null
    _min: ConferencesMinAggregateOutputType | null
    _max: ConferencesMaxAggregateOutputType | null
  }

  export type ConferencesMinAggregateOutputType = {
    id: string | null
    title: string | null
    acronym: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type ConferencesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    acronym: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
  }

  export type ConferencesCountAggregateOutputType = {
    id: number
    title: number
    acronym: number
    creatorId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type ConferencesMinAggregateInputType = {
    id?: true
    title?: true
    acronym?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ConferencesMaxAggregateInputType = {
    id?: true
    title?: true
    acronym?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ConferencesCountAggregateInputType = {
    id?: true
    title?: true
    acronym?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type ConferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conferences to aggregate.
     */
    where?: ConferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conferences
    **/
    _count?: true | ConferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferencesMaxAggregateInputType
  }

  export type GetConferencesAggregateType<T extends ConferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateConferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferences[P]>
      : GetScalarType<T[P], AggregateConferences[P]>
  }




  export type ConferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferencesWhereInput
    orderBy?: ConferencesOrderByWithAggregationInput | ConferencesOrderByWithAggregationInput[]
    by: ConferencesScalarFieldEnum[] | ConferencesScalarFieldEnum
    having?: ConferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferencesCountAggregateInputType | true
    _min?: ConferencesMinAggregateInputType
    _max?: ConferencesMaxAggregateInputType
  }

  export type ConferencesGroupByOutputType = {
    id: string
    title: string
    acronym: string
    creatorId: string
    createdAt: Date
    updatedAt: Date
    status: string
    _count: ConferencesCountAggregateOutputType | null
    _min: ConferencesMinAggregateOutputType | null
    _max: ConferencesMaxAggregateOutputType | null
  }

  type GetConferencesGroupByPayload<T extends ConferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferencesGroupByOutputType[P]>
            : GetScalarType<T[P], ConferencesGroupByOutputType[P]>
        }
      >
    >


  export type ConferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    acronym?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    follows?: boolean | Conferences$followsArgs<ExtArgs>
    likes?: boolean | Conferences$likesArgs<ExtArgs>
    calendars?: boolean | Conferences$calendarsArgs<ExtArgs>
    organizations?: boolean | Conferences$organizationsArgs<ExtArgs>
    ranks?: boolean | Conferences$ranksArgs<ExtArgs>
    crawlJobs?: boolean | Conferences$crawlJobsArgs<ExtArgs>
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
    feedbacks?: boolean | Conferences$feedbacksArgs<ExtArgs>
    _count?: boolean | ConferencesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferences"]>

  export type ConferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    acronym?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferences"]>

  export type ConferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    acronym?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferences"]>

  export type ConferencesSelectScalar = {
    id?: boolean
    title?: boolean
    acronym?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type ConferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "acronym" | "creatorId" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["conferences"]>
  export type ConferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follows?: boolean | Conferences$followsArgs<ExtArgs>
    likes?: boolean | Conferences$likesArgs<ExtArgs>
    calendars?: boolean | Conferences$calendarsArgs<ExtArgs>
    organizations?: boolean | Conferences$organizationsArgs<ExtArgs>
    ranks?: boolean | Conferences$ranksArgs<ExtArgs>
    crawlJobs?: boolean | Conferences$crawlJobsArgs<ExtArgs>
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
    feedbacks?: boolean | Conferences$feedbacksArgs<ExtArgs>
    _count?: boolean | ConferencesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conferences"
    objects: {
      follows: Prisma.$ConferenceFollowsPayload<ExtArgs>[]
      likes: Prisma.$ConferenceLikesPayload<ExtArgs>[]
      calendars: Prisma.$ConferenceCalendarsPayload<ExtArgs>[]
      organizations: Prisma.$ConferenceOrganizationsPayload<ExtArgs>[]
      ranks: Prisma.$ConferenceRanksPayload<ExtArgs>[]
      crawlJobs: Prisma.$ConferenceCrawlJobsPayload<ExtArgs>[]
      createdByUser: Prisma.$UsersPayload<ExtArgs>
      feedbacks: Prisma.$ConferenceFeedbacksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      acronym: string
      creatorId: string
      createdAt: Date
      updatedAt: Date
      status: string
    }, ExtArgs["result"]["conferences"]>
    composites: {}
  }

  type ConferencesGetPayload<S extends boolean | null | undefined | ConferencesDefaultArgs> = $Result.GetResult<Prisma.$ConferencesPayload, S>

  type ConferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferencesCountAggregateInputType | true
    }

  export interface ConferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conferences'], meta: { name: 'Conferences' } }
    /**
     * Find zero or one Conferences that matches the filter.
     * @param {ConferencesFindUniqueArgs} args - Arguments to find a Conferences
     * @example
     * // Get one Conferences
     * const conferences = await prisma.conferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferencesFindUniqueArgs>(args: SelectSubset<T, ConferencesFindUniqueArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferencesFindUniqueOrThrowArgs} args - Arguments to find a Conferences
     * @example
     * // Get one Conferences
     * const conferences = await prisma.conferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesFindFirstArgs} args - Arguments to find a Conferences
     * @example
     * // Get one Conferences
     * const conferences = await prisma.conferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferencesFindFirstArgs>(args?: SelectSubset<T, ConferencesFindFirstArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesFindFirstOrThrowArgs} args - Arguments to find a Conferences
     * @example
     * // Get one Conferences
     * const conferences = await prisma.conferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conferences
     * const conferences = await prisma.conferences.findMany()
     * 
     * // Get first 10 Conferences
     * const conferences = await prisma.conferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferencesWithIdOnly = await prisma.conferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferencesFindManyArgs>(args?: SelectSubset<T, ConferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conferences.
     * @param {ConferencesCreateArgs} args - Arguments to create a Conferences.
     * @example
     * // Create one Conferences
     * const Conferences = await prisma.conferences.create({
     *   data: {
     *     // ... data to create a Conferences
     *   }
     * })
     * 
     */
    create<T extends ConferencesCreateArgs>(args: SelectSubset<T, ConferencesCreateArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conferences.
     * @param {ConferencesCreateManyArgs} args - Arguments to create many Conferences.
     * @example
     * // Create many Conferences
     * const conferences = await prisma.conferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferencesCreateManyArgs>(args?: SelectSubset<T, ConferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conferences and returns the data saved in the database.
     * @param {ConferencesCreateManyAndReturnArgs} args - Arguments to create many Conferences.
     * @example
     * // Create many Conferences
     * const conferences = await prisma.conferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conferences and only return the `id`
     * const conferencesWithIdOnly = await prisma.conferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conferences.
     * @param {ConferencesDeleteArgs} args - Arguments to delete one Conferences.
     * @example
     * // Delete one Conferences
     * const Conferences = await prisma.conferences.delete({
     *   where: {
     *     // ... filter to delete one Conferences
     *   }
     * })
     * 
     */
    delete<T extends ConferencesDeleteArgs>(args: SelectSubset<T, ConferencesDeleteArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conferences.
     * @param {ConferencesUpdateArgs} args - Arguments to update one Conferences.
     * @example
     * // Update one Conferences
     * const conferences = await prisma.conferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferencesUpdateArgs>(args: SelectSubset<T, ConferencesUpdateArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conferences.
     * @param {ConferencesDeleteManyArgs} args - Arguments to filter Conferences to delete.
     * @example
     * // Delete a few Conferences
     * const { count } = await prisma.conferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferencesDeleteManyArgs>(args?: SelectSubset<T, ConferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conferences
     * const conferences = await prisma.conferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferencesUpdateManyArgs>(args: SelectSubset<T, ConferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conferences and returns the data updated in the database.
     * @param {ConferencesUpdateManyAndReturnArgs} args - Arguments to update many Conferences.
     * @example
     * // Update many Conferences
     * const conferences = await prisma.conferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conferences and only return the `id`
     * const conferencesWithIdOnly = await prisma.conferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conferences.
     * @param {ConferencesUpsertArgs} args - Arguments to update or create a Conferences.
     * @example
     * // Update or create a Conferences
     * const conferences = await prisma.conferences.upsert({
     *   create: {
     *     // ... data to create a Conferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conferences we want to update
     *   }
     * })
     */
    upsert<T extends ConferencesUpsertArgs>(args: SelectSubset<T, ConferencesUpsertArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesCountArgs} args - Arguments to filter Conferences to count.
     * @example
     * // Count the number of Conferences
     * const count = await prisma.conferences.count({
     *   where: {
     *     // ... the filter for the Conferences we want to count
     *   }
     * })
    **/
    count<T extends ConferencesCountArgs>(
      args?: Subset<T, ConferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferencesAggregateArgs>(args: Subset<T, ConferencesAggregateArgs>): Prisma.PrismaPromise<GetConferencesAggregateType<T>>

    /**
     * Group by Conferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferencesGroupByArgs['orderBy'] }
        : { orderBy?: ConferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conferences model
   */
  readonly fields: ConferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follows<T extends Conferences$followsArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$followsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Conferences$likesArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calendars<T extends Conferences$calendarsArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$calendarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organizations<T extends Conferences$organizationsArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$organizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceOrganizationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ranks<T extends Conferences$ranksArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$ranksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crawlJobs<T extends Conferences$crawlJobsArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$crawlJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdByUser<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feedbacks<T extends Conferences$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Conferences$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conferences model
   */ 
  interface ConferencesFieldRefs {
    readonly id: FieldRef<"Conferences", 'String'>
    readonly title: FieldRef<"Conferences", 'String'>
    readonly acronym: FieldRef<"Conferences", 'String'>
    readonly creatorId: FieldRef<"Conferences", 'String'>
    readonly createdAt: FieldRef<"Conferences", 'DateTime'>
    readonly updatedAt: FieldRef<"Conferences", 'DateTime'>
    readonly status: FieldRef<"Conferences", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conferences findUnique
   */
  export type ConferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where: ConferencesWhereUniqueInput
  }

  /**
   * Conferences findUniqueOrThrow
   */
  export type ConferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where: ConferencesWhereUniqueInput
  }

  /**
   * Conferences findFirst
   */
  export type ConferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where?: ConferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conferences.
     */
    cursor?: ConferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conferences.
     */
    distinct?: ConferencesScalarFieldEnum | ConferencesScalarFieldEnum[]
  }

  /**
   * Conferences findFirstOrThrow
   */
  export type ConferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where?: ConferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conferences.
     */
    cursor?: ConferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conferences.
     */
    distinct?: ConferencesScalarFieldEnum | ConferencesScalarFieldEnum[]
  }

  /**
   * Conferences findMany
   */
  export type ConferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter, which Conferences to fetch.
     */
    where?: ConferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conferences to fetch.
     */
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conferences.
     */
    cursor?: ConferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conferences.
     */
    skip?: number
    distinct?: ConferencesScalarFieldEnum | ConferencesScalarFieldEnum[]
  }

  /**
   * Conferences create
   */
  export type ConferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a Conferences.
     */
    data: XOR<ConferencesCreateInput, ConferencesUncheckedCreateInput>
  }

  /**
   * Conferences createMany
   */
  export type ConferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conferences.
     */
    data: ConferencesCreateManyInput | ConferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conferences createManyAndReturn
   */
  export type ConferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * The data used to create many Conferences.
     */
    data: ConferencesCreateManyInput | ConferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conferences update
   */
  export type ConferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a Conferences.
     */
    data: XOR<ConferencesUpdateInput, ConferencesUncheckedUpdateInput>
    /**
     * Choose, which Conferences to update.
     */
    where: ConferencesWhereUniqueInput
  }

  /**
   * Conferences updateMany
   */
  export type ConferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conferences.
     */
    data: XOR<ConferencesUpdateManyMutationInput, ConferencesUncheckedUpdateManyInput>
    /**
     * Filter which Conferences to update
     */
    where?: ConferencesWhereInput
    /**
     * Limit how many Conferences to update.
     */
    limit?: number
  }

  /**
   * Conferences updateManyAndReturn
   */
  export type ConferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * The data used to update Conferences.
     */
    data: XOR<ConferencesUpdateManyMutationInput, ConferencesUncheckedUpdateManyInput>
    /**
     * Filter which Conferences to update
     */
    where?: ConferencesWhereInput
    /**
     * Limit how many Conferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conferences upsert
   */
  export type ConferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the Conferences to update in case it exists.
     */
    where: ConferencesWhereUniqueInput
    /**
     * In case the Conferences found by the `where` argument doesn't exist, create a new Conferences with this data.
     */
    create: XOR<ConferencesCreateInput, ConferencesUncheckedCreateInput>
    /**
     * In case the Conferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferencesUpdateInput, ConferencesUncheckedUpdateInput>
  }

  /**
   * Conferences delete
   */
  export type ConferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    /**
     * Filter which Conferences to delete.
     */
    where: ConferencesWhereUniqueInput
  }

  /**
   * Conferences deleteMany
   */
  export type ConferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conferences to delete
     */
    where?: ConferencesWhereInput
    /**
     * Limit how many Conferences to delete.
     */
    limit?: number
  }

  /**
   * Conferences.follows
   */
  export type Conferences$followsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    where?: ConferenceFollowsWhereInput
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    cursor?: ConferenceFollowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceFollowsScalarFieldEnum | ConferenceFollowsScalarFieldEnum[]
  }

  /**
   * Conferences.likes
   */
  export type Conferences$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    where?: ConferenceLikesWhereInput
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    cursor?: ConferenceLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceLikesScalarFieldEnum | ConferenceLikesScalarFieldEnum[]
  }

  /**
   * Conferences.calendars
   */
  export type Conferences$calendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    where?: ConferenceCalendarsWhereInput
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    cursor?: ConferenceCalendarsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceCalendarsScalarFieldEnum | ConferenceCalendarsScalarFieldEnum[]
  }

  /**
   * Conferences.organizations
   */
  export type Conferences$organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceOrganizations
     */
    select?: ConferenceOrganizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceOrganizations
     */
    omit?: ConferenceOrganizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceOrganizationsInclude<ExtArgs> | null
    where?: ConferenceOrganizationsWhereInput
    orderBy?: ConferenceOrganizationsOrderByWithRelationInput | ConferenceOrganizationsOrderByWithRelationInput[]
    cursor?: ConferenceOrganizationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceOrganizationsScalarFieldEnum | ConferenceOrganizationsScalarFieldEnum[]
  }

  /**
   * Conferences.ranks
   */
  export type Conferences$ranksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    where?: ConferenceRanksWhereInput
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    cursor?: ConferenceRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * Conferences.crawlJobs
   */
  export type Conferences$crawlJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    where?: ConferenceCrawlJobsWhereInput
    orderBy?: ConferenceCrawlJobsOrderByWithRelationInput | ConferenceCrawlJobsOrderByWithRelationInput[]
    cursor?: ConferenceCrawlJobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceCrawlJobsScalarFieldEnum | ConferenceCrawlJobsScalarFieldEnum[]
  }

  /**
   * Conferences.feedbacks
   */
  export type Conferences$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    where?: ConferenceFeedbacksWhereInput
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    cursor?: ConferenceFeedbacksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceFeedbacksScalarFieldEnum | ConferenceFeedbacksScalarFieldEnum[]
  }

  /**
   * Conferences without action
   */
  export type ConferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceRanks
   */

  export type AggregateConferenceRanks = {
    _count: ConferenceRanksCountAggregateOutputType | null
    _avg: ConferenceRanksAvgAggregateOutputType | null
    _sum: ConferenceRanksSumAggregateOutputType | null
    _min: ConferenceRanksMinAggregateOutputType | null
    _max: ConferenceRanksMaxAggregateOutputType | null
  }

  export type ConferenceRanksAvgAggregateOutputType = {
    year: number | null
  }

  export type ConferenceRanksSumAggregateOutputType = {
    year: number | null
  }

  export type ConferenceRanksMinAggregateOutputType = {
    id: string | null
    year: number | null
    conferenceId: string | null
    fieldOfResearchId: string | null
    rankId: string | null
  }

  export type ConferenceRanksMaxAggregateOutputType = {
    id: string | null
    year: number | null
    conferenceId: string | null
    fieldOfResearchId: string | null
    rankId: string | null
  }

  export type ConferenceRanksCountAggregateOutputType = {
    id: number
    year: number
    conferenceId: number
    fieldOfResearchId: number
    rankId: number
    _all: number
  }


  export type ConferenceRanksAvgAggregateInputType = {
    year?: true
  }

  export type ConferenceRanksSumAggregateInputType = {
    year?: true
  }

  export type ConferenceRanksMinAggregateInputType = {
    id?: true
    year?: true
    conferenceId?: true
    fieldOfResearchId?: true
    rankId?: true
  }

  export type ConferenceRanksMaxAggregateInputType = {
    id?: true
    year?: true
    conferenceId?: true
    fieldOfResearchId?: true
    rankId?: true
  }

  export type ConferenceRanksCountAggregateInputType = {
    id?: true
    year?: true
    conferenceId?: true
    fieldOfResearchId?: true
    rankId?: true
    _all?: true
  }

  export type ConferenceRanksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceRanks to aggregate.
     */
    where?: ConferenceRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceRanks to fetch.
     */
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceRanks
    **/
    _count?: true | ConferenceRanksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceRanksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceRanksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceRanksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceRanksMaxAggregateInputType
  }

  export type GetConferenceRanksAggregateType<T extends ConferenceRanksAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceRanks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceRanks[P]>
      : GetScalarType<T[P], AggregateConferenceRanks[P]>
  }




  export type ConferenceRanksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceRanksWhereInput
    orderBy?: ConferenceRanksOrderByWithAggregationInput | ConferenceRanksOrderByWithAggregationInput[]
    by: ConferenceRanksScalarFieldEnum[] | ConferenceRanksScalarFieldEnum
    having?: ConferenceRanksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceRanksCountAggregateInputType | true
    _avg?: ConferenceRanksAvgAggregateInputType
    _sum?: ConferenceRanksSumAggregateInputType
    _min?: ConferenceRanksMinAggregateInputType
    _max?: ConferenceRanksMaxAggregateInputType
  }

  export type ConferenceRanksGroupByOutputType = {
    id: string
    year: number
    conferenceId: string
    fieldOfResearchId: string
    rankId: string
    _count: ConferenceRanksCountAggregateOutputType | null
    _avg: ConferenceRanksAvgAggregateOutputType | null
    _sum: ConferenceRanksSumAggregateOutputType | null
    _min: ConferenceRanksMinAggregateOutputType | null
    _max: ConferenceRanksMaxAggregateOutputType | null
  }

  type GetConferenceRanksGroupByPayload<T extends ConferenceRanksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceRanksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceRanksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceRanksGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceRanksGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceRanksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    conferenceId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceRanks"]>

  export type ConferenceRanksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    conferenceId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceRanks"]>

  export type ConferenceRanksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    conferenceId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceRanks"]>

  export type ConferenceRanksSelectScalar = {
    id?: boolean
    year?: boolean
    conferenceId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
  }

  export type ConferenceRanksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "conferenceId" | "fieldOfResearchId" | "rankId", ExtArgs["result"]["conferenceRanks"]>
  export type ConferenceRanksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }
  export type ConferenceRanksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }
  export type ConferenceRanksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }

  export type $ConferenceRanksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceRanks"
    objects: {
      inFieldOfResearch: Prisma.$FieldOfResearchsPayload<ExtArgs>
      byRank: Prisma.$RanksPayload<ExtArgs>
      belongsTo: Prisma.$ConferencesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      conferenceId: string
      fieldOfResearchId: string
      rankId: string
    }, ExtArgs["result"]["conferenceRanks"]>
    composites: {}
  }

  type ConferenceRanksGetPayload<S extends boolean | null | undefined | ConferenceRanksDefaultArgs> = $Result.GetResult<Prisma.$ConferenceRanksPayload, S>

  type ConferenceRanksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceRanksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceRanksCountAggregateInputType | true
    }

  export interface ConferenceRanksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceRanks'], meta: { name: 'ConferenceRanks' } }
    /**
     * Find zero or one ConferenceRanks that matches the filter.
     * @param {ConferenceRanksFindUniqueArgs} args - Arguments to find a ConferenceRanks
     * @example
     * // Get one ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceRanksFindUniqueArgs>(args: SelectSubset<T, ConferenceRanksFindUniqueArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceRanks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceRanksFindUniqueOrThrowArgs} args - Arguments to find a ConferenceRanks
     * @example
     * // Get one ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceRanksFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceRanksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksFindFirstArgs} args - Arguments to find a ConferenceRanks
     * @example
     * // Get one ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceRanksFindFirstArgs>(args?: SelectSubset<T, ConferenceRanksFindFirstArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceRanks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksFindFirstOrThrowArgs} args - Arguments to find a ConferenceRanks
     * @example
     * // Get one ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceRanksFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceRanksFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findMany()
     * 
     * // Get first 10 ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceRanksWithIdOnly = await prisma.conferenceRanks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceRanksFindManyArgs>(args?: SelectSubset<T, ConferenceRanksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceRanks.
     * @param {ConferenceRanksCreateArgs} args - Arguments to create a ConferenceRanks.
     * @example
     * // Create one ConferenceRanks
     * const ConferenceRanks = await prisma.conferenceRanks.create({
     *   data: {
     *     // ... data to create a ConferenceRanks
     *   }
     * })
     * 
     */
    create<T extends ConferenceRanksCreateArgs>(args: SelectSubset<T, ConferenceRanksCreateArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceRanks.
     * @param {ConferenceRanksCreateManyArgs} args - Arguments to create many ConferenceRanks.
     * @example
     * // Create many ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceRanksCreateManyArgs>(args?: SelectSubset<T, ConferenceRanksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceRanks and returns the data saved in the database.
     * @param {ConferenceRanksCreateManyAndReturnArgs} args - Arguments to create many ConferenceRanks.
     * @example
     * // Create many ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceRanks and only return the `id`
     * const conferenceRanksWithIdOnly = await prisma.conferenceRanks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceRanksCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceRanksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceRanks.
     * @param {ConferenceRanksDeleteArgs} args - Arguments to delete one ConferenceRanks.
     * @example
     * // Delete one ConferenceRanks
     * const ConferenceRanks = await prisma.conferenceRanks.delete({
     *   where: {
     *     // ... filter to delete one ConferenceRanks
     *   }
     * })
     * 
     */
    delete<T extends ConferenceRanksDeleteArgs>(args: SelectSubset<T, ConferenceRanksDeleteArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceRanks.
     * @param {ConferenceRanksUpdateArgs} args - Arguments to update one ConferenceRanks.
     * @example
     * // Update one ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceRanksUpdateArgs>(args: SelectSubset<T, ConferenceRanksUpdateArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceRanks.
     * @param {ConferenceRanksDeleteManyArgs} args - Arguments to filter ConferenceRanks to delete.
     * @example
     * // Delete a few ConferenceRanks
     * const { count } = await prisma.conferenceRanks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceRanksDeleteManyArgs>(args?: SelectSubset<T, ConferenceRanksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceRanksUpdateManyArgs>(args: SelectSubset<T, ConferenceRanksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceRanks and returns the data updated in the database.
     * @param {ConferenceRanksUpdateManyAndReturnArgs} args - Arguments to update many ConferenceRanks.
     * @example
     * // Update many ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceRanks and only return the `id`
     * const conferenceRanksWithIdOnly = await prisma.conferenceRanks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceRanksUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceRanksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceRanks.
     * @param {ConferenceRanksUpsertArgs} args - Arguments to update or create a ConferenceRanks.
     * @example
     * // Update or create a ConferenceRanks
     * const conferenceRanks = await prisma.conferenceRanks.upsert({
     *   create: {
     *     // ... data to create a ConferenceRanks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceRanks we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceRanksUpsertArgs>(args: SelectSubset<T, ConferenceRanksUpsertArgs<ExtArgs>>): Prisma__ConferenceRanksClient<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksCountArgs} args - Arguments to filter ConferenceRanks to count.
     * @example
     * // Count the number of ConferenceRanks
     * const count = await prisma.conferenceRanks.count({
     *   where: {
     *     // ... the filter for the ConferenceRanks we want to count
     *   }
     * })
    **/
    count<T extends ConferenceRanksCountArgs>(
      args?: Subset<T, ConferenceRanksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceRanksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceRanksAggregateArgs>(args: Subset<T, ConferenceRanksAggregateArgs>): Prisma.PrismaPromise<GetConferenceRanksAggregateType<T>>

    /**
     * Group by ConferenceRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceRanksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceRanksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceRanksGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceRanksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceRanksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceRanksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceRanks model
   */
  readonly fields: ConferenceRanksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceRanks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceRanksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inFieldOfResearch<T extends FieldOfResearchsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldOfResearchsDefaultArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    byRank<T extends RanksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RanksDefaultArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    belongsTo<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceRanks model
   */ 
  interface ConferenceRanksFieldRefs {
    readonly id: FieldRef<"ConferenceRanks", 'String'>
    readonly year: FieldRef<"ConferenceRanks", 'Int'>
    readonly conferenceId: FieldRef<"ConferenceRanks", 'String'>
    readonly fieldOfResearchId: FieldRef<"ConferenceRanks", 'String'>
    readonly rankId: FieldRef<"ConferenceRanks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceRanks findUnique
   */
  export type ConferenceRanksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceRanks to fetch.
     */
    where: ConferenceRanksWhereUniqueInput
  }

  /**
   * ConferenceRanks findUniqueOrThrow
   */
  export type ConferenceRanksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceRanks to fetch.
     */
    where: ConferenceRanksWhereUniqueInput
  }

  /**
   * ConferenceRanks findFirst
   */
  export type ConferenceRanksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceRanks to fetch.
     */
    where?: ConferenceRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceRanks to fetch.
     */
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceRanks.
     */
    cursor?: ConferenceRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceRanks.
     */
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * ConferenceRanks findFirstOrThrow
   */
  export type ConferenceRanksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceRanks to fetch.
     */
    where?: ConferenceRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceRanks to fetch.
     */
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceRanks.
     */
    cursor?: ConferenceRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceRanks.
     */
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * ConferenceRanks findMany
   */
  export type ConferenceRanksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceRanks to fetch.
     */
    where?: ConferenceRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceRanks to fetch.
     */
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceRanks.
     */
    cursor?: ConferenceRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceRanks.
     */
    skip?: number
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * ConferenceRanks create
   */
  export type ConferenceRanksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceRanks.
     */
    data: XOR<ConferenceRanksCreateInput, ConferenceRanksUncheckedCreateInput>
  }

  /**
   * ConferenceRanks createMany
   */
  export type ConferenceRanksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceRanks.
     */
    data: ConferenceRanksCreateManyInput | ConferenceRanksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceRanks createManyAndReturn
   */
  export type ConferenceRanksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceRanks.
     */
    data: ConferenceRanksCreateManyInput | ConferenceRanksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceRanks update
   */
  export type ConferenceRanksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceRanks.
     */
    data: XOR<ConferenceRanksUpdateInput, ConferenceRanksUncheckedUpdateInput>
    /**
     * Choose, which ConferenceRanks to update.
     */
    where: ConferenceRanksWhereUniqueInput
  }

  /**
   * ConferenceRanks updateMany
   */
  export type ConferenceRanksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceRanks.
     */
    data: XOR<ConferenceRanksUpdateManyMutationInput, ConferenceRanksUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceRanks to update
     */
    where?: ConferenceRanksWhereInput
    /**
     * Limit how many ConferenceRanks to update.
     */
    limit?: number
  }

  /**
   * ConferenceRanks updateManyAndReturn
   */
  export type ConferenceRanksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceRanks.
     */
    data: XOR<ConferenceRanksUpdateManyMutationInput, ConferenceRanksUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceRanks to update
     */
    where?: ConferenceRanksWhereInput
    /**
     * Limit how many ConferenceRanks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceRanks upsert
   */
  export type ConferenceRanksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceRanks to update in case it exists.
     */
    where: ConferenceRanksWhereUniqueInput
    /**
     * In case the ConferenceRanks found by the `where` argument doesn't exist, create a new ConferenceRanks with this data.
     */
    create: XOR<ConferenceRanksCreateInput, ConferenceRanksUncheckedCreateInput>
    /**
     * In case the ConferenceRanks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceRanksUpdateInput, ConferenceRanksUncheckedUpdateInput>
  }

  /**
   * ConferenceRanks delete
   */
  export type ConferenceRanksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    /**
     * Filter which ConferenceRanks to delete.
     */
    where: ConferenceRanksWhereUniqueInput
  }

  /**
   * ConferenceRanks deleteMany
   */
  export type ConferenceRanksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceRanks to delete
     */
    where?: ConferenceRanksWhereInput
    /**
     * Limit how many ConferenceRanks to delete.
     */
    limit?: number
  }

  /**
   * ConferenceRanks without action
   */
  export type ConferenceRanksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
  }


  /**
   * Model FieldOfResearchs
   */

  export type AggregateFieldOfResearchs = {
    _count: FieldOfResearchsCountAggregateOutputType | null
    _min: FieldOfResearchsMinAggregateOutputType | null
    _max: FieldOfResearchsMaxAggregateOutputType | null
  }

  export type FieldOfResearchsMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type FieldOfResearchsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
  }

  export type FieldOfResearchsCountAggregateOutputType = {
    id: number
    name: number
    code: number
    _all: number
  }


  export type FieldOfResearchsMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type FieldOfResearchsMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type FieldOfResearchsCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    _all?: true
  }

  export type FieldOfResearchsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldOfResearchs to aggregate.
     */
    where?: FieldOfResearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOfResearchs to fetch.
     */
    orderBy?: FieldOfResearchsOrderByWithRelationInput | FieldOfResearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldOfResearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOfResearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOfResearchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldOfResearchs
    **/
    _count?: true | FieldOfResearchsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldOfResearchsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldOfResearchsMaxAggregateInputType
  }

  export type GetFieldOfResearchsAggregateType<T extends FieldOfResearchsAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldOfResearchs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldOfResearchs[P]>
      : GetScalarType<T[P], AggregateFieldOfResearchs[P]>
  }




  export type FieldOfResearchsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldOfResearchsWhereInput
    orderBy?: FieldOfResearchsOrderByWithAggregationInput | FieldOfResearchsOrderByWithAggregationInput[]
    by: FieldOfResearchsScalarFieldEnum[] | FieldOfResearchsScalarFieldEnum
    having?: FieldOfResearchsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldOfResearchsCountAggregateInputType | true
    _min?: FieldOfResearchsMinAggregateInputType
    _max?: FieldOfResearchsMaxAggregateInputType
  }

  export type FieldOfResearchsGroupByOutputType = {
    id: string
    name: string
    code: string
    _count: FieldOfResearchsCountAggregateOutputType | null
    _min: FieldOfResearchsMinAggregateOutputType | null
    _max: FieldOfResearchsMaxAggregateOutputType | null
  }

  type GetFieldOfResearchsGroupByPayload<T extends FieldOfResearchsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldOfResearchsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldOfResearchsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldOfResearchsGroupByOutputType[P]>
            : GetScalarType<T[P], FieldOfResearchsGroupByOutputType[P]>
        }
      >
    >


  export type FieldOfResearchsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    journalRanks?: boolean | FieldOfResearchs$journalRanksArgs<ExtArgs>
    conferenceRanks?: boolean | FieldOfResearchs$conferenceRanksArgs<ExtArgs>
    _count?: boolean | FieldOfResearchsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldOfResearchs"]>

  export type FieldOfResearchsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["fieldOfResearchs"]>

  export type FieldOfResearchsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["fieldOfResearchs"]>

  export type FieldOfResearchsSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
  }

  export type FieldOfResearchsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code", ExtArgs["result"]["fieldOfResearchs"]>
  export type FieldOfResearchsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalRanks?: boolean | FieldOfResearchs$journalRanksArgs<ExtArgs>
    conferenceRanks?: boolean | FieldOfResearchs$conferenceRanksArgs<ExtArgs>
    _count?: boolean | FieldOfResearchsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FieldOfResearchsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FieldOfResearchsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FieldOfResearchsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldOfResearchs"
    objects: {
      journalRanks: Prisma.$JournalRanksPayload<ExtArgs>[]
      conferenceRanks: Prisma.$ConferenceRanksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
    }, ExtArgs["result"]["fieldOfResearchs"]>
    composites: {}
  }

  type FieldOfResearchsGetPayload<S extends boolean | null | undefined | FieldOfResearchsDefaultArgs> = $Result.GetResult<Prisma.$FieldOfResearchsPayload, S>

  type FieldOfResearchsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldOfResearchsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldOfResearchsCountAggregateInputType | true
    }

  export interface FieldOfResearchsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldOfResearchs'], meta: { name: 'FieldOfResearchs' } }
    /**
     * Find zero or one FieldOfResearchs that matches the filter.
     * @param {FieldOfResearchsFindUniqueArgs} args - Arguments to find a FieldOfResearchs
     * @example
     * // Get one FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldOfResearchsFindUniqueArgs>(args: SelectSubset<T, FieldOfResearchsFindUniqueArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FieldOfResearchs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldOfResearchsFindUniqueOrThrowArgs} args - Arguments to find a FieldOfResearchs
     * @example
     * // Get one FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldOfResearchsFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldOfResearchsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldOfResearchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsFindFirstArgs} args - Arguments to find a FieldOfResearchs
     * @example
     * // Get one FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldOfResearchsFindFirstArgs>(args?: SelectSubset<T, FieldOfResearchsFindFirstArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldOfResearchs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsFindFirstOrThrowArgs} args - Arguments to find a FieldOfResearchs
     * @example
     * // Get one FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldOfResearchsFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldOfResearchsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldOfResearchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findMany()
     * 
     * // Get first 10 FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldOfResearchsWithIdOnly = await prisma.fieldOfResearchs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldOfResearchsFindManyArgs>(args?: SelectSubset<T, FieldOfResearchsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FieldOfResearchs.
     * @param {FieldOfResearchsCreateArgs} args - Arguments to create a FieldOfResearchs.
     * @example
     * // Create one FieldOfResearchs
     * const FieldOfResearchs = await prisma.fieldOfResearchs.create({
     *   data: {
     *     // ... data to create a FieldOfResearchs
     *   }
     * })
     * 
     */
    create<T extends FieldOfResearchsCreateArgs>(args: SelectSubset<T, FieldOfResearchsCreateArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FieldOfResearchs.
     * @param {FieldOfResearchsCreateManyArgs} args - Arguments to create many FieldOfResearchs.
     * @example
     * // Create many FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldOfResearchsCreateManyArgs>(args?: SelectSubset<T, FieldOfResearchsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FieldOfResearchs and returns the data saved in the database.
     * @param {FieldOfResearchsCreateManyAndReturnArgs} args - Arguments to create many FieldOfResearchs.
     * @example
     * // Create many FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FieldOfResearchs and only return the `id`
     * const fieldOfResearchsWithIdOnly = await prisma.fieldOfResearchs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FieldOfResearchsCreateManyAndReturnArgs>(args?: SelectSubset<T, FieldOfResearchsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FieldOfResearchs.
     * @param {FieldOfResearchsDeleteArgs} args - Arguments to delete one FieldOfResearchs.
     * @example
     * // Delete one FieldOfResearchs
     * const FieldOfResearchs = await prisma.fieldOfResearchs.delete({
     *   where: {
     *     // ... filter to delete one FieldOfResearchs
     *   }
     * })
     * 
     */
    delete<T extends FieldOfResearchsDeleteArgs>(args: SelectSubset<T, FieldOfResearchsDeleteArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FieldOfResearchs.
     * @param {FieldOfResearchsUpdateArgs} args - Arguments to update one FieldOfResearchs.
     * @example
     * // Update one FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldOfResearchsUpdateArgs>(args: SelectSubset<T, FieldOfResearchsUpdateArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FieldOfResearchs.
     * @param {FieldOfResearchsDeleteManyArgs} args - Arguments to filter FieldOfResearchs to delete.
     * @example
     * // Delete a few FieldOfResearchs
     * const { count } = await prisma.fieldOfResearchs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldOfResearchsDeleteManyArgs>(args?: SelectSubset<T, FieldOfResearchsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldOfResearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldOfResearchsUpdateManyArgs>(args: SelectSubset<T, FieldOfResearchsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldOfResearchs and returns the data updated in the database.
     * @param {FieldOfResearchsUpdateManyAndReturnArgs} args - Arguments to update many FieldOfResearchs.
     * @example
     * // Update many FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FieldOfResearchs and only return the `id`
     * const fieldOfResearchsWithIdOnly = await prisma.fieldOfResearchs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FieldOfResearchsUpdateManyAndReturnArgs>(args: SelectSubset<T, FieldOfResearchsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FieldOfResearchs.
     * @param {FieldOfResearchsUpsertArgs} args - Arguments to update or create a FieldOfResearchs.
     * @example
     * // Update or create a FieldOfResearchs
     * const fieldOfResearchs = await prisma.fieldOfResearchs.upsert({
     *   create: {
     *     // ... data to create a FieldOfResearchs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldOfResearchs we want to update
     *   }
     * })
     */
    upsert<T extends FieldOfResearchsUpsertArgs>(args: SelectSubset<T, FieldOfResearchsUpsertArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FieldOfResearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsCountArgs} args - Arguments to filter FieldOfResearchs to count.
     * @example
     * // Count the number of FieldOfResearchs
     * const count = await prisma.fieldOfResearchs.count({
     *   where: {
     *     // ... the filter for the FieldOfResearchs we want to count
     *   }
     * })
    **/
    count<T extends FieldOfResearchsCountArgs>(
      args?: Subset<T, FieldOfResearchsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldOfResearchsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldOfResearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldOfResearchsAggregateArgs>(args: Subset<T, FieldOfResearchsAggregateArgs>): Prisma.PrismaPromise<GetFieldOfResearchsAggregateType<T>>

    /**
     * Group by FieldOfResearchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldOfResearchsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldOfResearchsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldOfResearchsGroupByArgs['orderBy'] }
        : { orderBy?: FieldOfResearchsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldOfResearchsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldOfResearchsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldOfResearchs model
   */
  readonly fields: FieldOfResearchsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldOfResearchs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldOfResearchsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journalRanks<T extends FieldOfResearchs$journalRanksArgs<ExtArgs> = {}>(args?: Subset<T, FieldOfResearchs$journalRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conferenceRanks<T extends FieldOfResearchs$conferenceRanksArgs<ExtArgs> = {}>(args?: Subset<T, FieldOfResearchs$conferenceRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FieldOfResearchs model
   */ 
  interface FieldOfResearchsFieldRefs {
    readonly id: FieldRef<"FieldOfResearchs", 'String'>
    readonly name: FieldRef<"FieldOfResearchs", 'String'>
    readonly code: FieldRef<"FieldOfResearchs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FieldOfResearchs findUnique
   */
  export type FieldOfResearchsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter, which FieldOfResearchs to fetch.
     */
    where: FieldOfResearchsWhereUniqueInput
  }

  /**
   * FieldOfResearchs findUniqueOrThrow
   */
  export type FieldOfResearchsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter, which FieldOfResearchs to fetch.
     */
    where: FieldOfResearchsWhereUniqueInput
  }

  /**
   * FieldOfResearchs findFirst
   */
  export type FieldOfResearchsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter, which FieldOfResearchs to fetch.
     */
    where?: FieldOfResearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOfResearchs to fetch.
     */
    orderBy?: FieldOfResearchsOrderByWithRelationInput | FieldOfResearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldOfResearchs.
     */
    cursor?: FieldOfResearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOfResearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOfResearchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldOfResearchs.
     */
    distinct?: FieldOfResearchsScalarFieldEnum | FieldOfResearchsScalarFieldEnum[]
  }

  /**
   * FieldOfResearchs findFirstOrThrow
   */
  export type FieldOfResearchsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter, which FieldOfResearchs to fetch.
     */
    where?: FieldOfResearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOfResearchs to fetch.
     */
    orderBy?: FieldOfResearchsOrderByWithRelationInput | FieldOfResearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldOfResearchs.
     */
    cursor?: FieldOfResearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOfResearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOfResearchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldOfResearchs.
     */
    distinct?: FieldOfResearchsScalarFieldEnum | FieldOfResearchsScalarFieldEnum[]
  }

  /**
   * FieldOfResearchs findMany
   */
  export type FieldOfResearchsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter, which FieldOfResearchs to fetch.
     */
    where?: FieldOfResearchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldOfResearchs to fetch.
     */
    orderBy?: FieldOfResearchsOrderByWithRelationInput | FieldOfResearchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldOfResearchs.
     */
    cursor?: FieldOfResearchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldOfResearchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldOfResearchs.
     */
    skip?: number
    distinct?: FieldOfResearchsScalarFieldEnum | FieldOfResearchsScalarFieldEnum[]
  }

  /**
   * FieldOfResearchs create
   */
  export type FieldOfResearchsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldOfResearchs.
     */
    data: XOR<FieldOfResearchsCreateInput, FieldOfResearchsUncheckedCreateInput>
  }

  /**
   * FieldOfResearchs createMany
   */
  export type FieldOfResearchsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldOfResearchs.
     */
    data: FieldOfResearchsCreateManyInput | FieldOfResearchsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FieldOfResearchs createManyAndReturn
   */
  export type FieldOfResearchsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * The data used to create many FieldOfResearchs.
     */
    data: FieldOfResearchsCreateManyInput | FieldOfResearchsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FieldOfResearchs update
   */
  export type FieldOfResearchsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldOfResearchs.
     */
    data: XOR<FieldOfResearchsUpdateInput, FieldOfResearchsUncheckedUpdateInput>
    /**
     * Choose, which FieldOfResearchs to update.
     */
    where: FieldOfResearchsWhereUniqueInput
  }

  /**
   * FieldOfResearchs updateMany
   */
  export type FieldOfResearchsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldOfResearchs.
     */
    data: XOR<FieldOfResearchsUpdateManyMutationInput, FieldOfResearchsUncheckedUpdateManyInput>
    /**
     * Filter which FieldOfResearchs to update
     */
    where?: FieldOfResearchsWhereInput
    /**
     * Limit how many FieldOfResearchs to update.
     */
    limit?: number
  }

  /**
   * FieldOfResearchs updateManyAndReturn
   */
  export type FieldOfResearchsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * The data used to update FieldOfResearchs.
     */
    data: XOR<FieldOfResearchsUpdateManyMutationInput, FieldOfResearchsUncheckedUpdateManyInput>
    /**
     * Filter which FieldOfResearchs to update
     */
    where?: FieldOfResearchsWhereInput
    /**
     * Limit how many FieldOfResearchs to update.
     */
    limit?: number
  }

  /**
   * FieldOfResearchs upsert
   */
  export type FieldOfResearchsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldOfResearchs to update in case it exists.
     */
    where: FieldOfResearchsWhereUniqueInput
    /**
     * In case the FieldOfResearchs found by the `where` argument doesn't exist, create a new FieldOfResearchs with this data.
     */
    create: XOR<FieldOfResearchsCreateInput, FieldOfResearchsUncheckedCreateInput>
    /**
     * In case the FieldOfResearchs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldOfResearchsUpdateInput, FieldOfResearchsUncheckedUpdateInput>
  }

  /**
   * FieldOfResearchs delete
   */
  export type FieldOfResearchsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
    /**
     * Filter which FieldOfResearchs to delete.
     */
    where: FieldOfResearchsWhereUniqueInput
  }

  /**
   * FieldOfResearchs deleteMany
   */
  export type FieldOfResearchsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldOfResearchs to delete
     */
    where?: FieldOfResearchsWhereInput
    /**
     * Limit how many FieldOfResearchs to delete.
     */
    limit?: number
  }

  /**
   * FieldOfResearchs.journalRanks
   */
  export type FieldOfResearchs$journalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    where?: JournalRanksWhereInput
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    cursor?: JournalRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * FieldOfResearchs.conferenceRanks
   */
  export type FieldOfResearchs$conferenceRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    where?: ConferenceRanksWhereInput
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    cursor?: ConferenceRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * FieldOfResearchs without action
   */
  export type FieldOfResearchsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldOfResearchs
     */
    select?: FieldOfResearchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldOfResearchs
     */
    omit?: FieldOfResearchsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldOfResearchsInclude<ExtArgs> | null
  }


  /**
   * Model Ranks
   */

  export type AggregateRanks = {
    _count: RanksCountAggregateOutputType | null
    _avg: RanksAvgAggregateOutputType | null
    _sum: RanksSumAggregateOutputType | null
    _min: RanksMinAggregateOutputType | null
    _max: RanksMaxAggregateOutputType | null
  }

  export type RanksAvgAggregateOutputType = {
    value: number | null
  }

  export type RanksSumAggregateOutputType = {
    value: number | null
  }

  export type RanksMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    sourceId: string | null
  }

  export type RanksMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    sourceId: string | null
  }

  export type RanksCountAggregateOutputType = {
    id: number
    name: number
    value: number
    sourceId: number
    _all: number
  }


  export type RanksAvgAggregateInputType = {
    value?: true
  }

  export type RanksSumAggregateInputType = {
    value?: true
  }

  export type RanksMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    sourceId?: true
  }

  export type RanksMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    sourceId?: true
  }

  export type RanksCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    sourceId?: true
    _all?: true
  }

  export type RanksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ranks to aggregate.
     */
    where?: RanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RanksOrderByWithRelationInput | RanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ranks
    **/
    _count?: true | RanksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RanksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RanksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RanksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RanksMaxAggregateInputType
  }

  export type GetRanksAggregateType<T extends RanksAggregateArgs> = {
        [P in keyof T & keyof AggregateRanks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRanks[P]>
      : GetScalarType<T[P], AggregateRanks[P]>
  }




  export type RanksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RanksWhereInput
    orderBy?: RanksOrderByWithAggregationInput | RanksOrderByWithAggregationInput[]
    by: RanksScalarFieldEnum[] | RanksScalarFieldEnum
    having?: RanksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RanksCountAggregateInputType | true
    _avg?: RanksAvgAggregateInputType
    _sum?: RanksSumAggregateInputType
    _min?: RanksMinAggregateInputType
    _max?: RanksMaxAggregateInputType
  }

  export type RanksGroupByOutputType = {
    id: string
    name: string
    value: number
    sourceId: string
    _count: RanksCountAggregateOutputType | null
    _avg: RanksAvgAggregateOutputType | null
    _sum: RanksSumAggregateOutputType | null
    _min: RanksMinAggregateOutputType | null
    _max: RanksMaxAggregateOutputType | null
  }

  type GetRanksGroupByPayload<T extends RanksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RanksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RanksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RanksGroupByOutputType[P]>
            : GetScalarType<T[P], RanksGroupByOutputType[P]>
        }
      >
    >


  export type RanksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    sourceId?: boolean
    conferenceRanks?: boolean | Ranks$conferenceRanksArgs<ExtArgs>
    journalRanks?: boolean | Ranks$journalRanksArgs<ExtArgs>
    belongsToSource?: boolean | SourcesDefaultArgs<ExtArgs>
    _count?: boolean | RanksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ranks"]>

  export type RanksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    sourceId?: boolean
    belongsToSource?: boolean | SourcesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ranks"]>

  export type RanksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    sourceId?: boolean
    belongsToSource?: boolean | SourcesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ranks"]>

  export type RanksSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    sourceId?: boolean
  }

  export type RanksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value" | "sourceId", ExtArgs["result"]["ranks"]>
  export type RanksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conferenceRanks?: boolean | Ranks$conferenceRanksArgs<ExtArgs>
    journalRanks?: boolean | Ranks$journalRanksArgs<ExtArgs>
    belongsToSource?: boolean | SourcesDefaultArgs<ExtArgs>
    _count?: boolean | RanksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RanksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsToSource?: boolean | SourcesDefaultArgs<ExtArgs>
  }
  export type RanksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsToSource?: boolean | SourcesDefaultArgs<ExtArgs>
  }

  export type $RanksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ranks"
    objects: {
      conferenceRanks: Prisma.$ConferenceRanksPayload<ExtArgs>[]
      journalRanks: Prisma.$JournalRanksPayload<ExtArgs>[]
      belongsToSource: Prisma.$SourcesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      value: number
      sourceId: string
    }, ExtArgs["result"]["ranks"]>
    composites: {}
  }

  type RanksGetPayload<S extends boolean | null | undefined | RanksDefaultArgs> = $Result.GetResult<Prisma.$RanksPayload, S>

  type RanksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RanksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RanksCountAggregateInputType | true
    }

  export interface RanksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ranks'], meta: { name: 'Ranks' } }
    /**
     * Find zero or one Ranks that matches the filter.
     * @param {RanksFindUniqueArgs} args - Arguments to find a Ranks
     * @example
     * // Get one Ranks
     * const ranks = await prisma.ranks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RanksFindUniqueArgs>(args: SelectSubset<T, RanksFindUniqueArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ranks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RanksFindUniqueOrThrowArgs} args - Arguments to find a Ranks
     * @example
     * // Get one Ranks
     * const ranks = await prisma.ranks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RanksFindUniqueOrThrowArgs>(args: SelectSubset<T, RanksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ranks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksFindFirstArgs} args - Arguments to find a Ranks
     * @example
     * // Get one Ranks
     * const ranks = await prisma.ranks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RanksFindFirstArgs>(args?: SelectSubset<T, RanksFindFirstArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ranks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksFindFirstOrThrowArgs} args - Arguments to find a Ranks
     * @example
     * // Get one Ranks
     * const ranks = await prisma.ranks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RanksFindFirstOrThrowArgs>(args?: SelectSubset<T, RanksFindFirstOrThrowArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ranks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ranks
     * const ranks = await prisma.ranks.findMany()
     * 
     * // Get first 10 Ranks
     * const ranks = await prisma.ranks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ranksWithIdOnly = await prisma.ranks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RanksFindManyArgs>(args?: SelectSubset<T, RanksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ranks.
     * @param {RanksCreateArgs} args - Arguments to create a Ranks.
     * @example
     * // Create one Ranks
     * const Ranks = await prisma.ranks.create({
     *   data: {
     *     // ... data to create a Ranks
     *   }
     * })
     * 
     */
    create<T extends RanksCreateArgs>(args: SelectSubset<T, RanksCreateArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ranks.
     * @param {RanksCreateManyArgs} args - Arguments to create many Ranks.
     * @example
     * // Create many Ranks
     * const ranks = await prisma.ranks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RanksCreateManyArgs>(args?: SelectSubset<T, RanksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ranks and returns the data saved in the database.
     * @param {RanksCreateManyAndReturnArgs} args - Arguments to create many Ranks.
     * @example
     * // Create many Ranks
     * const ranks = await prisma.ranks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ranks and only return the `id`
     * const ranksWithIdOnly = await prisma.ranks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RanksCreateManyAndReturnArgs>(args?: SelectSubset<T, RanksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ranks.
     * @param {RanksDeleteArgs} args - Arguments to delete one Ranks.
     * @example
     * // Delete one Ranks
     * const Ranks = await prisma.ranks.delete({
     *   where: {
     *     // ... filter to delete one Ranks
     *   }
     * })
     * 
     */
    delete<T extends RanksDeleteArgs>(args: SelectSubset<T, RanksDeleteArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ranks.
     * @param {RanksUpdateArgs} args - Arguments to update one Ranks.
     * @example
     * // Update one Ranks
     * const ranks = await prisma.ranks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RanksUpdateArgs>(args: SelectSubset<T, RanksUpdateArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ranks.
     * @param {RanksDeleteManyArgs} args - Arguments to filter Ranks to delete.
     * @example
     * // Delete a few Ranks
     * const { count } = await prisma.ranks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RanksDeleteManyArgs>(args?: SelectSubset<T, RanksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ranks
     * const ranks = await prisma.ranks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RanksUpdateManyArgs>(args: SelectSubset<T, RanksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ranks and returns the data updated in the database.
     * @param {RanksUpdateManyAndReturnArgs} args - Arguments to update many Ranks.
     * @example
     * // Update many Ranks
     * const ranks = await prisma.ranks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ranks and only return the `id`
     * const ranksWithIdOnly = await prisma.ranks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RanksUpdateManyAndReturnArgs>(args: SelectSubset<T, RanksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ranks.
     * @param {RanksUpsertArgs} args - Arguments to update or create a Ranks.
     * @example
     * // Update or create a Ranks
     * const ranks = await prisma.ranks.upsert({
     *   create: {
     *     // ... data to create a Ranks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ranks we want to update
     *   }
     * })
     */
    upsert<T extends RanksUpsertArgs>(args: SelectSubset<T, RanksUpsertArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksCountArgs} args - Arguments to filter Ranks to count.
     * @example
     * // Count the number of Ranks
     * const count = await prisma.ranks.count({
     *   where: {
     *     // ... the filter for the Ranks we want to count
     *   }
     * })
    **/
    count<T extends RanksCountArgs>(
      args?: Subset<T, RanksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RanksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RanksAggregateArgs>(args: Subset<T, RanksAggregateArgs>): Prisma.PrismaPromise<GetRanksAggregateType<T>>

    /**
     * Group by Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RanksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RanksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RanksGroupByArgs['orderBy'] }
        : { orderBy?: RanksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RanksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRanksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ranks model
   */
  readonly fields: RanksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ranks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RanksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conferenceRanks<T extends Ranks$conferenceRanksArgs<ExtArgs> = {}>(args?: Subset<T, Ranks$conferenceRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalRanks<T extends Ranks$journalRanksArgs<ExtArgs> = {}>(args?: Subset<T, Ranks$journalRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    belongsToSource<T extends SourcesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourcesDefaultArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ranks model
   */ 
  interface RanksFieldRefs {
    readonly id: FieldRef<"Ranks", 'String'>
    readonly name: FieldRef<"Ranks", 'String'>
    readonly value: FieldRef<"Ranks", 'Int'>
    readonly sourceId: FieldRef<"Ranks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ranks findUnique
   */
  export type RanksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where: RanksWhereUniqueInput
  }

  /**
   * Ranks findUniqueOrThrow
   */
  export type RanksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where: RanksWhereUniqueInput
  }

  /**
   * Ranks findFirst
   */
  export type RanksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where?: RanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RanksOrderByWithRelationInput | RanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ranks.
     */
    cursor?: RanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ranks.
     */
    distinct?: RanksScalarFieldEnum | RanksScalarFieldEnum[]
  }

  /**
   * Ranks findFirstOrThrow
   */
  export type RanksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where?: RanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RanksOrderByWithRelationInput | RanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ranks.
     */
    cursor?: RanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ranks.
     */
    distinct?: RanksScalarFieldEnum | RanksScalarFieldEnum[]
  }

  /**
   * Ranks findMany
   */
  export type RanksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter, which Ranks to fetch.
     */
    where?: RanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranks to fetch.
     */
    orderBy?: RanksOrderByWithRelationInput | RanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ranks.
     */
    cursor?: RanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranks.
     */
    skip?: number
    distinct?: RanksScalarFieldEnum | RanksScalarFieldEnum[]
  }

  /**
   * Ranks create
   */
  export type RanksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * The data needed to create a Ranks.
     */
    data: XOR<RanksCreateInput, RanksUncheckedCreateInput>
  }

  /**
   * Ranks createMany
   */
  export type RanksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ranks.
     */
    data: RanksCreateManyInput | RanksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ranks createManyAndReturn
   */
  export type RanksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * The data used to create many Ranks.
     */
    data: RanksCreateManyInput | RanksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ranks update
   */
  export type RanksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * The data needed to update a Ranks.
     */
    data: XOR<RanksUpdateInput, RanksUncheckedUpdateInput>
    /**
     * Choose, which Ranks to update.
     */
    where: RanksWhereUniqueInput
  }

  /**
   * Ranks updateMany
   */
  export type RanksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ranks.
     */
    data: XOR<RanksUpdateManyMutationInput, RanksUncheckedUpdateManyInput>
    /**
     * Filter which Ranks to update
     */
    where?: RanksWhereInput
    /**
     * Limit how many Ranks to update.
     */
    limit?: number
  }

  /**
   * Ranks updateManyAndReturn
   */
  export type RanksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * The data used to update Ranks.
     */
    data: XOR<RanksUpdateManyMutationInput, RanksUncheckedUpdateManyInput>
    /**
     * Filter which Ranks to update
     */
    where?: RanksWhereInput
    /**
     * Limit how many Ranks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ranks upsert
   */
  export type RanksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * The filter to search for the Ranks to update in case it exists.
     */
    where: RanksWhereUniqueInput
    /**
     * In case the Ranks found by the `where` argument doesn't exist, create a new Ranks with this data.
     */
    create: XOR<RanksCreateInput, RanksUncheckedCreateInput>
    /**
     * In case the Ranks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RanksUpdateInput, RanksUncheckedUpdateInput>
  }

  /**
   * Ranks delete
   */
  export type RanksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    /**
     * Filter which Ranks to delete.
     */
    where: RanksWhereUniqueInput
  }

  /**
   * Ranks deleteMany
   */
  export type RanksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ranks to delete
     */
    where?: RanksWhereInput
    /**
     * Limit how many Ranks to delete.
     */
    limit?: number
  }

  /**
   * Ranks.conferenceRanks
   */
  export type Ranks$conferenceRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceRanks
     */
    select?: ConferenceRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceRanks
     */
    omit?: ConferenceRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceRanksInclude<ExtArgs> | null
    where?: ConferenceRanksWhereInput
    orderBy?: ConferenceRanksOrderByWithRelationInput | ConferenceRanksOrderByWithRelationInput[]
    cursor?: ConferenceRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceRanksScalarFieldEnum | ConferenceRanksScalarFieldEnum[]
  }

  /**
   * Ranks.journalRanks
   */
  export type Ranks$journalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    where?: JournalRanksWhereInput
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    cursor?: JournalRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * Ranks without action
   */
  export type RanksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
  }


  /**
   * Model Sources
   */

  export type AggregateSources = {
    _count: SourcesCountAggregateOutputType | null
    _min: SourcesMinAggregateOutputType | null
    _max: SourcesMaxAggregateOutputType | null
  }

  export type SourcesMinAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
  }

  export type SourcesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
  }

  export type SourcesCountAggregateOutputType = {
    id: number
    name: number
    link: number
    _all: number
  }


  export type SourcesMinAggregateInputType = {
    id?: true
    name?: true
    link?: true
  }

  export type SourcesMaxAggregateInputType = {
    id?: true
    name?: true
    link?: true
  }

  export type SourcesCountAggregateInputType = {
    id?: true
    name?: true
    link?: true
    _all?: true
  }

  export type SourcesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sources to aggregate.
     */
    where?: SourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourcesOrderByWithRelationInput | SourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sources
    **/
    _count?: true | SourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourcesMaxAggregateInputType
  }

  export type GetSourcesAggregateType<T extends SourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateSources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSources[P]>
      : GetScalarType<T[P], AggregateSources[P]>
  }




  export type SourcesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourcesWhereInput
    orderBy?: SourcesOrderByWithAggregationInput | SourcesOrderByWithAggregationInput[]
    by: SourcesScalarFieldEnum[] | SourcesScalarFieldEnum
    having?: SourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourcesCountAggregateInputType | true
    _min?: SourcesMinAggregateInputType
    _max?: SourcesMaxAggregateInputType
  }

  export type SourcesGroupByOutputType = {
    id: string
    name: string
    link: string | null
    _count: SourcesCountAggregateOutputType | null
    _min: SourcesMinAggregateOutputType | null
    _max: SourcesMaxAggregateOutputType | null
  }

  type GetSourcesGroupByPayload<T extends SourcesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourcesGroupByOutputType[P]>
            : GetScalarType<T[P], SourcesGroupByOutputType[P]>
        }
      >
    >


  export type SourcesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    ranks?: boolean | Sources$ranksArgs<ExtArgs>
    _count?: boolean | SourcesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sources"]>

  export type SourcesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
  }, ExtArgs["result"]["sources"]>

  export type SourcesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
  }, ExtArgs["result"]["sources"]>

  export type SourcesSelectScalar = {
    id?: boolean
    name?: boolean
    link?: boolean
  }

  export type SourcesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "link", ExtArgs["result"]["sources"]>
  export type SourcesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ranks?: boolean | Sources$ranksArgs<ExtArgs>
    _count?: boolean | SourcesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SourcesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SourcesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SourcesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sources"
    objects: {
      ranks: Prisma.$RanksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      link: string | null
    }, ExtArgs["result"]["sources"]>
    composites: {}
  }

  type SourcesGetPayload<S extends boolean | null | undefined | SourcesDefaultArgs> = $Result.GetResult<Prisma.$SourcesPayload, S>

  type SourcesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourcesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourcesCountAggregateInputType | true
    }

  export interface SourcesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sources'], meta: { name: 'Sources' } }
    /**
     * Find zero or one Sources that matches the filter.
     * @param {SourcesFindUniqueArgs} args - Arguments to find a Sources
     * @example
     * // Get one Sources
     * const sources = await prisma.sources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourcesFindUniqueArgs>(args: SelectSubset<T, SourcesFindUniqueArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sources that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourcesFindUniqueOrThrowArgs} args - Arguments to find a Sources
     * @example
     * // Get one Sources
     * const sources = await prisma.sources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourcesFindUniqueOrThrowArgs>(args: SelectSubset<T, SourcesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesFindFirstArgs} args - Arguments to find a Sources
     * @example
     * // Get one Sources
     * const sources = await prisma.sources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourcesFindFirstArgs>(args?: SelectSubset<T, SourcesFindFirstArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sources that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesFindFirstOrThrowArgs} args - Arguments to find a Sources
     * @example
     * // Get one Sources
     * const sources = await prisma.sources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourcesFindFirstOrThrowArgs>(args?: SelectSubset<T, SourcesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sources
     * const sources = await prisma.sources.findMany()
     * 
     * // Get first 10 Sources
     * const sources = await prisma.sources.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourcesWithIdOnly = await prisma.sources.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourcesFindManyArgs>(args?: SelectSubset<T, SourcesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sources.
     * @param {SourcesCreateArgs} args - Arguments to create a Sources.
     * @example
     * // Create one Sources
     * const Sources = await prisma.sources.create({
     *   data: {
     *     // ... data to create a Sources
     *   }
     * })
     * 
     */
    create<T extends SourcesCreateArgs>(args: SelectSubset<T, SourcesCreateArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sources.
     * @param {SourcesCreateManyArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const sources = await prisma.sources.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourcesCreateManyArgs>(args?: SelectSubset<T, SourcesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sources and returns the data saved in the database.
     * @param {SourcesCreateManyAndReturnArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const sources = await prisma.sources.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sources and only return the `id`
     * const sourcesWithIdOnly = await prisma.sources.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourcesCreateManyAndReturnArgs>(args?: SelectSubset<T, SourcesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sources.
     * @param {SourcesDeleteArgs} args - Arguments to delete one Sources.
     * @example
     * // Delete one Sources
     * const Sources = await prisma.sources.delete({
     *   where: {
     *     // ... filter to delete one Sources
     *   }
     * })
     * 
     */
    delete<T extends SourcesDeleteArgs>(args: SelectSubset<T, SourcesDeleteArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sources.
     * @param {SourcesUpdateArgs} args - Arguments to update one Sources.
     * @example
     * // Update one Sources
     * const sources = await prisma.sources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourcesUpdateArgs>(args: SelectSubset<T, SourcesUpdateArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sources.
     * @param {SourcesDeleteManyArgs} args - Arguments to filter Sources to delete.
     * @example
     * // Delete a few Sources
     * const { count } = await prisma.sources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourcesDeleteManyArgs>(args?: SelectSubset<T, SourcesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sources
     * const sources = await prisma.sources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourcesUpdateManyArgs>(args: SelectSubset<T, SourcesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources and returns the data updated in the database.
     * @param {SourcesUpdateManyAndReturnArgs} args - Arguments to update many Sources.
     * @example
     * // Update many Sources
     * const sources = await prisma.sources.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sources and only return the `id`
     * const sourcesWithIdOnly = await prisma.sources.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourcesUpdateManyAndReturnArgs>(args: SelectSubset<T, SourcesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sources.
     * @param {SourcesUpsertArgs} args - Arguments to update or create a Sources.
     * @example
     * // Update or create a Sources
     * const sources = await prisma.sources.upsert({
     *   create: {
     *     // ... data to create a Sources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sources we want to update
     *   }
     * })
     */
    upsert<T extends SourcesUpsertArgs>(args: SelectSubset<T, SourcesUpsertArgs<ExtArgs>>): Prisma__SourcesClient<$Result.GetResult<Prisma.$SourcesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesCountArgs} args - Arguments to filter Sources to count.
     * @example
     * // Count the number of Sources
     * const count = await prisma.sources.count({
     *   where: {
     *     // ... the filter for the Sources we want to count
     *   }
     * })
    **/
    count<T extends SourcesCountArgs>(
      args?: Subset<T, SourcesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourcesAggregateArgs>(args: Subset<T, SourcesAggregateArgs>): Prisma.PrismaPromise<GetSourcesAggregateType<T>>

    /**
     * Group by Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourcesGroupByArgs['orderBy'] }
        : { orderBy?: SourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourcesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sources model
   */
  readonly fields: SourcesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourcesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ranks<T extends Sources$ranksArgs<ExtArgs> = {}>(args?: Subset<T, Sources$ranksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sources model
   */ 
  interface SourcesFieldRefs {
    readonly id: FieldRef<"Sources", 'String'>
    readonly name: FieldRef<"Sources", 'String'>
    readonly link: FieldRef<"Sources", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sources findUnique
   */
  export type SourcesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where: SourcesWhereUniqueInput
  }

  /**
   * Sources findUniqueOrThrow
   */
  export type SourcesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where: SourcesWhereUniqueInput
  }

  /**
   * Sources findFirst
   */
  export type SourcesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourcesOrderByWithRelationInput | SourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourcesScalarFieldEnum | SourcesScalarFieldEnum[]
  }

  /**
   * Sources findFirstOrThrow
   */
  export type SourcesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourcesOrderByWithRelationInput | SourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourcesScalarFieldEnum | SourcesScalarFieldEnum[]
  }

  /**
   * Sources findMany
   */
  export type SourcesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourcesOrderByWithRelationInput | SourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sources.
     */
    cursor?: SourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    distinct?: SourcesScalarFieldEnum | SourcesScalarFieldEnum[]
  }

  /**
   * Sources create
   */
  export type SourcesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * The data needed to create a Sources.
     */
    data: XOR<SourcesCreateInput, SourcesUncheckedCreateInput>
  }

  /**
   * Sources createMany
   */
  export type SourcesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sources.
     */
    data: SourcesCreateManyInput | SourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sources createManyAndReturn
   */
  export type SourcesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * The data used to create many Sources.
     */
    data: SourcesCreateManyInput | SourcesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sources update
   */
  export type SourcesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * The data needed to update a Sources.
     */
    data: XOR<SourcesUpdateInput, SourcesUncheckedUpdateInput>
    /**
     * Choose, which Sources to update.
     */
    where: SourcesWhereUniqueInput
  }

  /**
   * Sources updateMany
   */
  export type SourcesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sources.
     */
    data: XOR<SourcesUpdateManyMutationInput, SourcesUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourcesWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
  }

  /**
   * Sources updateManyAndReturn
   */
  export type SourcesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * The data used to update Sources.
     */
    data: XOR<SourcesUpdateManyMutationInput, SourcesUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourcesWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
  }

  /**
   * Sources upsert
   */
  export type SourcesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * The filter to search for the Sources to update in case it exists.
     */
    where: SourcesWhereUniqueInput
    /**
     * In case the Sources found by the `where` argument doesn't exist, create a new Sources with this data.
     */
    create: XOR<SourcesCreateInput, SourcesUncheckedCreateInput>
    /**
     * In case the Sources was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourcesUpdateInput, SourcesUncheckedUpdateInput>
  }

  /**
   * Sources delete
   */
  export type SourcesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
    /**
     * Filter which Sources to delete.
     */
    where: SourcesWhereUniqueInput
  }

  /**
   * Sources deleteMany
   */
  export type SourcesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sources to delete
     */
    where?: SourcesWhereInput
    /**
     * Limit how many Sources to delete.
     */
    limit?: number
  }

  /**
   * Sources.ranks
   */
  export type Sources$ranksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranks
     */
    select?: RanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ranks
     */
    omit?: RanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RanksInclude<ExtArgs> | null
    where?: RanksWhereInput
    orderBy?: RanksOrderByWithRelationInput | RanksOrderByWithRelationInput[]
    cursor?: RanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RanksScalarFieldEnum | RanksScalarFieldEnum[]
  }

  /**
   * Sources without action
   */
  export type SourcesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sources
     */
    select?: SourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sources
     */
    omit?: SourcesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcesInclude<ExtArgs> | null
  }


  /**
   * Model JournalTopics
   */

  export type AggregateJournalTopics = {
    _count: JournalTopicsCountAggregateOutputType | null
    _min: JournalTopicsMinAggregateOutputType | null
    _max: JournalTopicsMaxAggregateOutputType | null
  }

  export type JournalTopicsMinAggregateOutputType = {
    id: string | null
    journalId: string | null
    topicId: string | null
  }

  export type JournalTopicsMaxAggregateOutputType = {
    id: string | null
    journalId: string | null
    topicId: string | null
  }

  export type JournalTopicsCountAggregateOutputType = {
    id: number
    journalId: number
    topicId: number
    _all: number
  }


  export type JournalTopicsMinAggregateInputType = {
    id?: true
    journalId?: true
    topicId?: true
  }

  export type JournalTopicsMaxAggregateInputType = {
    id?: true
    journalId?: true
    topicId?: true
  }

  export type JournalTopicsCountAggregateInputType = {
    id?: true
    journalId?: true
    topicId?: true
    _all?: true
  }

  export type JournalTopicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalTopics to aggregate.
     */
    where?: JournalTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTopics to fetch.
     */
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalTopics
    **/
    _count?: true | JournalTopicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalTopicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalTopicsMaxAggregateInputType
  }

  export type GetJournalTopicsAggregateType<T extends JournalTopicsAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalTopics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalTopics[P]>
      : GetScalarType<T[P], AggregateJournalTopics[P]>
  }




  export type JournalTopicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalTopicsWhereInput
    orderBy?: JournalTopicsOrderByWithAggregationInput | JournalTopicsOrderByWithAggregationInput[]
    by: JournalTopicsScalarFieldEnum[] | JournalTopicsScalarFieldEnum
    having?: JournalTopicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalTopicsCountAggregateInputType | true
    _min?: JournalTopicsMinAggregateInputType
    _max?: JournalTopicsMaxAggregateInputType
  }

  export type JournalTopicsGroupByOutputType = {
    id: string
    journalId: string
    topicId: string
    _count: JournalTopicsCountAggregateOutputType | null
    _min: JournalTopicsMinAggregateOutputType | null
    _max: JournalTopicsMaxAggregateOutputType | null
  }

  type GetJournalTopicsGroupByPayload<T extends JournalTopicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalTopicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalTopicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalTopicsGroupByOutputType[P]>
            : GetScalarType<T[P], JournalTopicsGroupByOutputType[P]>
        }
      >
    >


  export type JournalTopicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    topicId?: boolean
    belongsToTopics?: boolean | TopicsDefaultArgs<ExtArgs>
    inJournals?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalTopics"]>

  export type JournalTopicsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    topicId?: boolean
    belongsToTopics?: boolean | TopicsDefaultArgs<ExtArgs>
    inJournals?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalTopics"]>

  export type JournalTopicsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    topicId?: boolean
    belongsToTopics?: boolean | TopicsDefaultArgs<ExtArgs>
    inJournals?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalTopics"]>

  export type JournalTopicsSelectScalar = {
    id?: boolean
    journalId?: boolean
    topicId?: boolean
  }

  export type JournalTopicsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "topicId", ExtArgs["result"]["journalTopics"]>
  export type JournalTopicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsToTopics?: boolean | TopicsDefaultArgs<ExtArgs>
    inJournals?: boolean | JournalsDefaultArgs<ExtArgs>
  }
  export type JournalTopicsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsToTopics?: boolean | TopicsDefaultArgs<ExtArgs>
    inJournals?: boolean | JournalsDefaultArgs<ExtArgs>
  }
  export type JournalTopicsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsToTopics?: boolean | TopicsDefaultArgs<ExtArgs>
    inJournals?: boolean | JournalsDefaultArgs<ExtArgs>
  }

  export type $JournalTopicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalTopics"
    objects: {
      belongsToTopics: Prisma.$TopicsPayload<ExtArgs>
      inJournals: Prisma.$JournalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalId: string
      topicId: string
    }, ExtArgs["result"]["journalTopics"]>
    composites: {}
  }

  type JournalTopicsGetPayload<S extends boolean | null | undefined | JournalTopicsDefaultArgs> = $Result.GetResult<Prisma.$JournalTopicsPayload, S>

  type JournalTopicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalTopicsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalTopicsCountAggregateInputType | true
    }

  export interface JournalTopicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalTopics'], meta: { name: 'JournalTopics' } }
    /**
     * Find zero or one JournalTopics that matches the filter.
     * @param {JournalTopicsFindUniqueArgs} args - Arguments to find a JournalTopics
     * @example
     * // Get one JournalTopics
     * const journalTopics = await prisma.journalTopics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalTopicsFindUniqueArgs>(args: SelectSubset<T, JournalTopicsFindUniqueArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalTopics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalTopicsFindUniqueOrThrowArgs} args - Arguments to find a JournalTopics
     * @example
     * // Get one JournalTopics
     * const journalTopics = await prisma.journalTopics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalTopicsFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalTopicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsFindFirstArgs} args - Arguments to find a JournalTopics
     * @example
     * // Get one JournalTopics
     * const journalTopics = await prisma.journalTopics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalTopicsFindFirstArgs>(args?: SelectSubset<T, JournalTopicsFindFirstArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalTopics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsFindFirstOrThrowArgs} args - Arguments to find a JournalTopics
     * @example
     * // Get one JournalTopics
     * const journalTopics = await prisma.journalTopics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalTopicsFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalTopicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalTopics
     * const journalTopics = await prisma.journalTopics.findMany()
     * 
     * // Get first 10 JournalTopics
     * const journalTopics = await prisma.journalTopics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalTopicsWithIdOnly = await prisma.journalTopics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalTopicsFindManyArgs>(args?: SelectSubset<T, JournalTopicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalTopics.
     * @param {JournalTopicsCreateArgs} args - Arguments to create a JournalTopics.
     * @example
     * // Create one JournalTopics
     * const JournalTopics = await prisma.journalTopics.create({
     *   data: {
     *     // ... data to create a JournalTopics
     *   }
     * })
     * 
     */
    create<T extends JournalTopicsCreateArgs>(args: SelectSubset<T, JournalTopicsCreateArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalTopics.
     * @param {JournalTopicsCreateManyArgs} args - Arguments to create many JournalTopics.
     * @example
     * // Create many JournalTopics
     * const journalTopics = await prisma.journalTopics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalTopicsCreateManyArgs>(args?: SelectSubset<T, JournalTopicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalTopics and returns the data saved in the database.
     * @param {JournalTopicsCreateManyAndReturnArgs} args - Arguments to create many JournalTopics.
     * @example
     * // Create many JournalTopics
     * const journalTopics = await prisma.journalTopics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalTopics and only return the `id`
     * const journalTopicsWithIdOnly = await prisma.journalTopics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalTopicsCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalTopicsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalTopics.
     * @param {JournalTopicsDeleteArgs} args - Arguments to delete one JournalTopics.
     * @example
     * // Delete one JournalTopics
     * const JournalTopics = await prisma.journalTopics.delete({
     *   where: {
     *     // ... filter to delete one JournalTopics
     *   }
     * })
     * 
     */
    delete<T extends JournalTopicsDeleteArgs>(args: SelectSubset<T, JournalTopicsDeleteArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalTopics.
     * @param {JournalTopicsUpdateArgs} args - Arguments to update one JournalTopics.
     * @example
     * // Update one JournalTopics
     * const journalTopics = await prisma.journalTopics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalTopicsUpdateArgs>(args: SelectSubset<T, JournalTopicsUpdateArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalTopics.
     * @param {JournalTopicsDeleteManyArgs} args - Arguments to filter JournalTopics to delete.
     * @example
     * // Delete a few JournalTopics
     * const { count } = await prisma.journalTopics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalTopicsDeleteManyArgs>(args?: SelectSubset<T, JournalTopicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalTopics
     * const journalTopics = await prisma.journalTopics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalTopicsUpdateManyArgs>(args: SelectSubset<T, JournalTopicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalTopics and returns the data updated in the database.
     * @param {JournalTopicsUpdateManyAndReturnArgs} args - Arguments to update many JournalTopics.
     * @example
     * // Update many JournalTopics
     * const journalTopics = await prisma.journalTopics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalTopics and only return the `id`
     * const journalTopicsWithIdOnly = await prisma.journalTopics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalTopicsUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalTopicsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalTopics.
     * @param {JournalTopicsUpsertArgs} args - Arguments to update or create a JournalTopics.
     * @example
     * // Update or create a JournalTopics
     * const journalTopics = await prisma.journalTopics.upsert({
     *   create: {
     *     // ... data to create a JournalTopics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalTopics we want to update
     *   }
     * })
     */
    upsert<T extends JournalTopicsUpsertArgs>(args: SelectSubset<T, JournalTopicsUpsertArgs<ExtArgs>>): Prisma__JournalTopicsClient<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsCountArgs} args - Arguments to filter JournalTopics to count.
     * @example
     * // Count the number of JournalTopics
     * const count = await prisma.journalTopics.count({
     *   where: {
     *     // ... the filter for the JournalTopics we want to count
     *   }
     * })
    **/
    count<T extends JournalTopicsCountArgs>(
      args?: Subset<T, JournalTopicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalTopicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalTopicsAggregateArgs>(args: Subset<T, JournalTopicsAggregateArgs>): Prisma.PrismaPromise<GetJournalTopicsAggregateType<T>>

    /**
     * Group by JournalTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTopicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalTopicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalTopicsGroupByArgs['orderBy'] }
        : { orderBy?: JournalTopicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalTopicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalTopicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalTopics model
   */
  readonly fields: JournalTopicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalTopics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalTopicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsToTopics<T extends TopicsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicsDefaultArgs<ExtArgs>>): Prisma__TopicsClient<$Result.GetResult<Prisma.$TopicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inJournals<T extends JournalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalsDefaultArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalTopics model
   */ 
  interface JournalTopicsFieldRefs {
    readonly id: FieldRef<"JournalTopics", 'String'>
    readonly journalId: FieldRef<"JournalTopics", 'String'>
    readonly topicId: FieldRef<"JournalTopics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JournalTopics findUnique
   */
  export type JournalTopicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter, which JournalTopics to fetch.
     */
    where: JournalTopicsWhereUniqueInput
  }

  /**
   * JournalTopics findUniqueOrThrow
   */
  export type JournalTopicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter, which JournalTopics to fetch.
     */
    where: JournalTopicsWhereUniqueInput
  }

  /**
   * JournalTopics findFirst
   */
  export type JournalTopicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter, which JournalTopics to fetch.
     */
    where?: JournalTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTopics to fetch.
     */
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalTopics.
     */
    cursor?: JournalTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalTopics.
     */
    distinct?: JournalTopicsScalarFieldEnum | JournalTopicsScalarFieldEnum[]
  }

  /**
   * JournalTopics findFirstOrThrow
   */
  export type JournalTopicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter, which JournalTopics to fetch.
     */
    where?: JournalTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTopics to fetch.
     */
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalTopics.
     */
    cursor?: JournalTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalTopics.
     */
    distinct?: JournalTopicsScalarFieldEnum | JournalTopicsScalarFieldEnum[]
  }

  /**
   * JournalTopics findMany
   */
  export type JournalTopicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter, which JournalTopics to fetch.
     */
    where?: JournalTopicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTopics to fetch.
     */
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalTopics.
     */
    cursor?: JournalTopicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTopics.
     */
    skip?: number
    distinct?: JournalTopicsScalarFieldEnum | JournalTopicsScalarFieldEnum[]
  }

  /**
   * JournalTopics create
   */
  export type JournalTopicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalTopics.
     */
    data: XOR<JournalTopicsCreateInput, JournalTopicsUncheckedCreateInput>
  }

  /**
   * JournalTopics createMany
   */
  export type JournalTopicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalTopics.
     */
    data: JournalTopicsCreateManyInput | JournalTopicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalTopics createManyAndReturn
   */
  export type JournalTopicsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * The data used to create many JournalTopics.
     */
    data: JournalTopicsCreateManyInput | JournalTopicsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalTopics update
   */
  export type JournalTopicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalTopics.
     */
    data: XOR<JournalTopicsUpdateInput, JournalTopicsUncheckedUpdateInput>
    /**
     * Choose, which JournalTopics to update.
     */
    where: JournalTopicsWhereUniqueInput
  }

  /**
   * JournalTopics updateMany
   */
  export type JournalTopicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalTopics.
     */
    data: XOR<JournalTopicsUpdateManyMutationInput, JournalTopicsUncheckedUpdateManyInput>
    /**
     * Filter which JournalTopics to update
     */
    where?: JournalTopicsWhereInput
    /**
     * Limit how many JournalTopics to update.
     */
    limit?: number
  }

  /**
   * JournalTopics updateManyAndReturn
   */
  export type JournalTopicsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * The data used to update JournalTopics.
     */
    data: XOR<JournalTopicsUpdateManyMutationInput, JournalTopicsUncheckedUpdateManyInput>
    /**
     * Filter which JournalTopics to update
     */
    where?: JournalTopicsWhereInput
    /**
     * Limit how many JournalTopics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalTopics upsert
   */
  export type JournalTopicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalTopics to update in case it exists.
     */
    where: JournalTopicsWhereUniqueInput
    /**
     * In case the JournalTopics found by the `where` argument doesn't exist, create a new JournalTopics with this data.
     */
    create: XOR<JournalTopicsCreateInput, JournalTopicsUncheckedCreateInput>
    /**
     * In case the JournalTopics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalTopicsUpdateInput, JournalTopicsUncheckedUpdateInput>
  }

  /**
   * JournalTopics delete
   */
  export type JournalTopicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    /**
     * Filter which JournalTopics to delete.
     */
    where: JournalTopicsWhereUniqueInput
  }

  /**
   * JournalTopics deleteMany
   */
  export type JournalTopicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalTopics to delete
     */
    where?: JournalTopicsWhereInput
    /**
     * Limit how many JournalTopics to delete.
     */
    limit?: number
  }

  /**
   * JournalTopics without action
   */
  export type JournalTopicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
  }


  /**
   * Model JournalRanks
   */

  export type AggregateJournalRanks = {
    _count: JournalRanksCountAggregateOutputType | null
    _avg: JournalRanksAvgAggregateOutputType | null
    _sum: JournalRanksSumAggregateOutputType | null
    _min: JournalRanksMinAggregateOutputType | null
    _max: JournalRanksMaxAggregateOutputType | null
  }

  export type JournalRanksAvgAggregateOutputType = {
    year: number | null
  }

  export type JournalRanksSumAggregateOutputType = {
    year: number | null
  }

  export type JournalRanksMinAggregateOutputType = {
    id: string | null
    year: number | null
    journalId: string | null
    fieldOfResearchId: string | null
    rankId: string | null
  }

  export type JournalRanksMaxAggregateOutputType = {
    id: string | null
    year: number | null
    journalId: string | null
    fieldOfResearchId: string | null
    rankId: string | null
  }

  export type JournalRanksCountAggregateOutputType = {
    id: number
    year: number
    journalId: number
    fieldOfResearchId: number
    rankId: number
    _all: number
  }


  export type JournalRanksAvgAggregateInputType = {
    year?: true
  }

  export type JournalRanksSumAggregateInputType = {
    year?: true
  }

  export type JournalRanksMinAggregateInputType = {
    id?: true
    year?: true
    journalId?: true
    fieldOfResearchId?: true
    rankId?: true
  }

  export type JournalRanksMaxAggregateInputType = {
    id?: true
    year?: true
    journalId?: true
    fieldOfResearchId?: true
    rankId?: true
  }

  export type JournalRanksCountAggregateInputType = {
    id?: true
    year?: true
    journalId?: true
    fieldOfResearchId?: true
    rankId?: true
    _all?: true
  }

  export type JournalRanksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalRanks to aggregate.
     */
    where?: JournalRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalRanks to fetch.
     */
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalRanks
    **/
    _count?: true | JournalRanksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalRanksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalRanksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalRanksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalRanksMaxAggregateInputType
  }

  export type GetJournalRanksAggregateType<T extends JournalRanksAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalRanks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalRanks[P]>
      : GetScalarType<T[P], AggregateJournalRanks[P]>
  }




  export type JournalRanksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalRanksWhereInput
    orderBy?: JournalRanksOrderByWithAggregationInput | JournalRanksOrderByWithAggregationInput[]
    by: JournalRanksScalarFieldEnum[] | JournalRanksScalarFieldEnum
    having?: JournalRanksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalRanksCountAggregateInputType | true
    _avg?: JournalRanksAvgAggregateInputType
    _sum?: JournalRanksSumAggregateInputType
    _min?: JournalRanksMinAggregateInputType
    _max?: JournalRanksMaxAggregateInputType
  }

  export type JournalRanksGroupByOutputType = {
    id: string
    year: number
    journalId: string
    fieldOfResearchId: string
    rankId: string
    _count: JournalRanksCountAggregateOutputType | null
    _avg: JournalRanksAvgAggregateOutputType | null
    _sum: JournalRanksSumAggregateOutputType | null
    _min: JournalRanksMinAggregateOutputType | null
    _max: JournalRanksMaxAggregateOutputType | null
  }

  type GetJournalRanksGroupByPayload<T extends JournalRanksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalRanksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalRanksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalRanksGroupByOutputType[P]>
            : GetScalarType<T[P], JournalRanksGroupByOutputType[P]>
        }
      >
    >


  export type JournalRanksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    journalId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalRanks"]>

  export type JournalRanksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    journalId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalRanks"]>

  export type JournalRanksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    journalId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalRanks"]>

  export type JournalRanksSelectScalar = {
    id?: boolean
    year?: boolean
    journalId?: boolean
    fieldOfResearchId?: boolean
    rankId?: boolean
  }

  export type JournalRanksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "journalId" | "fieldOfResearchId" | "rankId", ExtArgs["result"]["journalRanks"]>
  export type JournalRanksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }
  export type JournalRanksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }
  export type JournalRanksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inFieldOfResearch?: boolean | FieldOfResearchsDefaultArgs<ExtArgs>
    byRank?: boolean | RanksDefaultArgs<ExtArgs>
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }

  export type $JournalRanksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalRanks"
    objects: {
      inFieldOfResearch: Prisma.$FieldOfResearchsPayload<ExtArgs>
      byRank: Prisma.$RanksPayload<ExtArgs>
      belongsTo: Prisma.$JournalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      journalId: string
      fieldOfResearchId: string
      rankId: string
    }, ExtArgs["result"]["journalRanks"]>
    composites: {}
  }

  type JournalRanksGetPayload<S extends boolean | null | undefined | JournalRanksDefaultArgs> = $Result.GetResult<Prisma.$JournalRanksPayload, S>

  type JournalRanksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalRanksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalRanksCountAggregateInputType | true
    }

  export interface JournalRanksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalRanks'], meta: { name: 'JournalRanks' } }
    /**
     * Find zero or one JournalRanks that matches the filter.
     * @param {JournalRanksFindUniqueArgs} args - Arguments to find a JournalRanks
     * @example
     * // Get one JournalRanks
     * const journalRanks = await prisma.journalRanks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalRanksFindUniqueArgs>(args: SelectSubset<T, JournalRanksFindUniqueArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalRanks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalRanksFindUniqueOrThrowArgs} args - Arguments to find a JournalRanks
     * @example
     * // Get one JournalRanks
     * const journalRanks = await prisma.journalRanks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalRanksFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalRanksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksFindFirstArgs} args - Arguments to find a JournalRanks
     * @example
     * // Get one JournalRanks
     * const journalRanks = await prisma.journalRanks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalRanksFindFirstArgs>(args?: SelectSubset<T, JournalRanksFindFirstArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalRanks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksFindFirstOrThrowArgs} args - Arguments to find a JournalRanks
     * @example
     * // Get one JournalRanks
     * const journalRanks = await prisma.journalRanks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalRanksFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalRanksFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalRanks
     * const journalRanks = await prisma.journalRanks.findMany()
     * 
     * // Get first 10 JournalRanks
     * const journalRanks = await prisma.journalRanks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalRanksWithIdOnly = await prisma.journalRanks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalRanksFindManyArgs>(args?: SelectSubset<T, JournalRanksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalRanks.
     * @param {JournalRanksCreateArgs} args - Arguments to create a JournalRanks.
     * @example
     * // Create one JournalRanks
     * const JournalRanks = await prisma.journalRanks.create({
     *   data: {
     *     // ... data to create a JournalRanks
     *   }
     * })
     * 
     */
    create<T extends JournalRanksCreateArgs>(args: SelectSubset<T, JournalRanksCreateArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalRanks.
     * @param {JournalRanksCreateManyArgs} args - Arguments to create many JournalRanks.
     * @example
     * // Create many JournalRanks
     * const journalRanks = await prisma.journalRanks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalRanksCreateManyArgs>(args?: SelectSubset<T, JournalRanksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalRanks and returns the data saved in the database.
     * @param {JournalRanksCreateManyAndReturnArgs} args - Arguments to create many JournalRanks.
     * @example
     * // Create many JournalRanks
     * const journalRanks = await prisma.journalRanks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalRanks and only return the `id`
     * const journalRanksWithIdOnly = await prisma.journalRanks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalRanksCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalRanksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalRanks.
     * @param {JournalRanksDeleteArgs} args - Arguments to delete one JournalRanks.
     * @example
     * // Delete one JournalRanks
     * const JournalRanks = await prisma.journalRanks.delete({
     *   where: {
     *     // ... filter to delete one JournalRanks
     *   }
     * })
     * 
     */
    delete<T extends JournalRanksDeleteArgs>(args: SelectSubset<T, JournalRanksDeleteArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalRanks.
     * @param {JournalRanksUpdateArgs} args - Arguments to update one JournalRanks.
     * @example
     * // Update one JournalRanks
     * const journalRanks = await prisma.journalRanks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalRanksUpdateArgs>(args: SelectSubset<T, JournalRanksUpdateArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalRanks.
     * @param {JournalRanksDeleteManyArgs} args - Arguments to filter JournalRanks to delete.
     * @example
     * // Delete a few JournalRanks
     * const { count } = await prisma.journalRanks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalRanksDeleteManyArgs>(args?: SelectSubset<T, JournalRanksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalRanks
     * const journalRanks = await prisma.journalRanks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalRanksUpdateManyArgs>(args: SelectSubset<T, JournalRanksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalRanks and returns the data updated in the database.
     * @param {JournalRanksUpdateManyAndReturnArgs} args - Arguments to update many JournalRanks.
     * @example
     * // Update many JournalRanks
     * const journalRanks = await prisma.journalRanks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalRanks and only return the `id`
     * const journalRanksWithIdOnly = await prisma.journalRanks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalRanksUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalRanksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalRanks.
     * @param {JournalRanksUpsertArgs} args - Arguments to update or create a JournalRanks.
     * @example
     * // Update or create a JournalRanks
     * const journalRanks = await prisma.journalRanks.upsert({
     *   create: {
     *     // ... data to create a JournalRanks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalRanks we want to update
     *   }
     * })
     */
    upsert<T extends JournalRanksUpsertArgs>(args: SelectSubset<T, JournalRanksUpsertArgs<ExtArgs>>): Prisma__JournalRanksClient<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksCountArgs} args - Arguments to filter JournalRanks to count.
     * @example
     * // Count the number of JournalRanks
     * const count = await prisma.journalRanks.count({
     *   where: {
     *     // ... the filter for the JournalRanks we want to count
     *   }
     * })
    **/
    count<T extends JournalRanksCountArgs>(
      args?: Subset<T, JournalRanksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalRanksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalRanksAggregateArgs>(args: Subset<T, JournalRanksAggregateArgs>): Prisma.PrismaPromise<GetJournalRanksAggregateType<T>>

    /**
     * Group by JournalRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalRanksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalRanksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalRanksGroupByArgs['orderBy'] }
        : { orderBy?: JournalRanksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalRanksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalRanksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalRanks model
   */
  readonly fields: JournalRanksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalRanks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalRanksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inFieldOfResearch<T extends FieldOfResearchsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldOfResearchsDefaultArgs<ExtArgs>>): Prisma__FieldOfResearchsClient<$Result.GetResult<Prisma.$FieldOfResearchsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    byRank<T extends RanksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RanksDefaultArgs<ExtArgs>>): Prisma__RanksClient<$Result.GetResult<Prisma.$RanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    belongsTo<T extends JournalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalsDefaultArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalRanks model
   */ 
  interface JournalRanksFieldRefs {
    readonly id: FieldRef<"JournalRanks", 'String'>
    readonly year: FieldRef<"JournalRanks", 'Int'>
    readonly journalId: FieldRef<"JournalRanks", 'String'>
    readonly fieldOfResearchId: FieldRef<"JournalRanks", 'String'>
    readonly rankId: FieldRef<"JournalRanks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JournalRanks findUnique
   */
  export type JournalRanksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter, which JournalRanks to fetch.
     */
    where: JournalRanksWhereUniqueInput
  }

  /**
   * JournalRanks findUniqueOrThrow
   */
  export type JournalRanksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter, which JournalRanks to fetch.
     */
    where: JournalRanksWhereUniqueInput
  }

  /**
   * JournalRanks findFirst
   */
  export type JournalRanksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter, which JournalRanks to fetch.
     */
    where?: JournalRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalRanks to fetch.
     */
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalRanks.
     */
    cursor?: JournalRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalRanks.
     */
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * JournalRanks findFirstOrThrow
   */
  export type JournalRanksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter, which JournalRanks to fetch.
     */
    where?: JournalRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalRanks to fetch.
     */
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalRanks.
     */
    cursor?: JournalRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalRanks.
     */
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * JournalRanks findMany
   */
  export type JournalRanksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter, which JournalRanks to fetch.
     */
    where?: JournalRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalRanks to fetch.
     */
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalRanks.
     */
    cursor?: JournalRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalRanks.
     */
    skip?: number
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * JournalRanks create
   */
  export type JournalRanksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalRanks.
     */
    data: XOR<JournalRanksCreateInput, JournalRanksUncheckedCreateInput>
  }

  /**
   * JournalRanks createMany
   */
  export type JournalRanksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalRanks.
     */
    data: JournalRanksCreateManyInput | JournalRanksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalRanks createManyAndReturn
   */
  export type JournalRanksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * The data used to create many JournalRanks.
     */
    data: JournalRanksCreateManyInput | JournalRanksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalRanks update
   */
  export type JournalRanksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalRanks.
     */
    data: XOR<JournalRanksUpdateInput, JournalRanksUncheckedUpdateInput>
    /**
     * Choose, which JournalRanks to update.
     */
    where: JournalRanksWhereUniqueInput
  }

  /**
   * JournalRanks updateMany
   */
  export type JournalRanksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalRanks.
     */
    data: XOR<JournalRanksUpdateManyMutationInput, JournalRanksUncheckedUpdateManyInput>
    /**
     * Filter which JournalRanks to update
     */
    where?: JournalRanksWhereInput
    /**
     * Limit how many JournalRanks to update.
     */
    limit?: number
  }

  /**
   * JournalRanks updateManyAndReturn
   */
  export type JournalRanksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * The data used to update JournalRanks.
     */
    data: XOR<JournalRanksUpdateManyMutationInput, JournalRanksUncheckedUpdateManyInput>
    /**
     * Filter which JournalRanks to update
     */
    where?: JournalRanksWhereInput
    /**
     * Limit how many JournalRanks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalRanks upsert
   */
  export type JournalRanksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalRanks to update in case it exists.
     */
    where: JournalRanksWhereUniqueInput
    /**
     * In case the JournalRanks found by the `where` argument doesn't exist, create a new JournalRanks with this data.
     */
    create: XOR<JournalRanksCreateInput, JournalRanksUncheckedCreateInput>
    /**
     * In case the JournalRanks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalRanksUpdateInput, JournalRanksUncheckedUpdateInput>
  }

  /**
   * JournalRanks delete
   */
  export type JournalRanksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    /**
     * Filter which JournalRanks to delete.
     */
    where: JournalRanksWhereUniqueInput
  }

  /**
   * JournalRanks deleteMany
   */
  export type JournalRanksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalRanks to delete
     */
    where?: JournalRanksWhereInput
    /**
     * Limit how many JournalRanks to delete.
     */
    limit?: number
  }

  /**
   * JournalRanks without action
   */
  export type JournalRanksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
  }


  /**
   * Model Journals
   */

  export type AggregateJournals = {
    _count: JournalsCountAggregateOutputType | null
    _avg: JournalsAvgAggregateOutputType | null
    _sum: JournalsSumAggregateOutputType | null
    _min: JournalsMinAggregateOutputType | null
    _max: JournalsMaxAggregateOutputType | null
  }

  export type JournalsAvgAggregateOutputType = {
    hIndex: number | null
  }

  export type JournalsSumAggregateOutputType = {
    hIndex: number | null
  }

  export type JournalsMinAggregateOutputType = {
    id: string | null
    name: string | null
    issn: string | null
    hIndex: number | null
    publisher: string | null
    nation: string | null
    scope: string | null
    emailSubmission: string | null
    creator: string | null
  }

  export type JournalsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    issn: string | null
    hIndex: number | null
    publisher: string | null
    nation: string | null
    scope: string | null
    emailSubmission: string | null
    creator: string | null
  }

  export type JournalsCountAggregateOutputType = {
    id: number
    name: number
    issn: number
    hIndex: number
    publisher: number
    nation: number
    scope: number
    emailSubmission: number
    creator: number
    _all: number
  }


  export type JournalsAvgAggregateInputType = {
    hIndex?: true
  }

  export type JournalsSumAggregateInputType = {
    hIndex?: true
  }

  export type JournalsMinAggregateInputType = {
    id?: true
    name?: true
    issn?: true
    hIndex?: true
    publisher?: true
    nation?: true
    scope?: true
    emailSubmission?: true
    creator?: true
  }

  export type JournalsMaxAggregateInputType = {
    id?: true
    name?: true
    issn?: true
    hIndex?: true
    publisher?: true
    nation?: true
    scope?: true
    emailSubmission?: true
    creator?: true
  }

  export type JournalsCountAggregateInputType = {
    id?: true
    name?: true
    issn?: true
    hIndex?: true
    publisher?: true
    nation?: true
    scope?: true
    emailSubmission?: true
    creator?: true
    _all?: true
  }

  export type JournalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journals to aggregate.
     */
    where?: JournalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalsOrderByWithRelationInput | JournalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Journals
    **/
    _count?: true | JournalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalsMaxAggregateInputType
  }

  export type GetJournalsAggregateType<T extends JournalsAggregateArgs> = {
        [P in keyof T & keyof AggregateJournals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournals[P]>
      : GetScalarType<T[P], AggregateJournals[P]>
  }




  export type JournalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalsWhereInput
    orderBy?: JournalsOrderByWithAggregationInput | JournalsOrderByWithAggregationInput[]
    by: JournalsScalarFieldEnum[] | JournalsScalarFieldEnum
    having?: JournalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalsCountAggregateInputType | true
    _avg?: JournalsAvgAggregateInputType
    _sum?: JournalsSumAggregateInputType
    _min?: JournalsMinAggregateInputType
    _max?: JournalsMaxAggregateInputType
  }

  export type JournalsGroupByOutputType = {
    id: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    _count: JournalsCountAggregateOutputType | null
    _avg: JournalsAvgAggregateOutputType | null
    _sum: JournalsSumAggregateOutputType | null
    _min: JournalsMinAggregateOutputType | null
    _max: JournalsMaxAggregateOutputType | null
  }

  type GetJournalsGroupByPayload<T extends JournalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalsGroupByOutputType[P]>
            : GetScalarType<T[P], JournalsGroupByOutputType[P]>
        }
      >
    >


  export type JournalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    issn?: boolean
    hIndex?: boolean
    publisher?: boolean
    nation?: boolean
    scope?: boolean
    emailSubmission?: boolean
    creator?: boolean
    topics?: boolean | Journals$topicsArgs<ExtArgs>
    journalRanks?: boolean | Journals$journalRanksArgs<ExtArgs>
    journalLikes?: boolean | Journals$journalLikesArgs<ExtArgs>
    journalFollows?: boolean | Journals$journalFollowsArgs<ExtArgs>
    crawlJobs?: boolean | Journals$crawlJobsArgs<ExtArgs>
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | JournalsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journals"]>

  export type JournalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    issn?: boolean
    hIndex?: boolean
    publisher?: boolean
    nation?: boolean
    scope?: boolean
    emailSubmission?: boolean
    creator?: boolean
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journals"]>

  export type JournalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    issn?: boolean
    hIndex?: boolean
    publisher?: boolean
    nation?: boolean
    scope?: boolean
    emailSubmission?: boolean
    creator?: boolean
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journals"]>

  export type JournalsSelectScalar = {
    id?: boolean
    name?: boolean
    issn?: boolean
    hIndex?: boolean
    publisher?: boolean
    nation?: boolean
    scope?: boolean
    emailSubmission?: boolean
    creator?: boolean
  }

  export type JournalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "issn" | "hIndex" | "publisher" | "nation" | "scope" | "emailSubmission" | "creator", ExtArgs["result"]["journals"]>
  export type JournalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | Journals$topicsArgs<ExtArgs>
    journalRanks?: boolean | Journals$journalRanksArgs<ExtArgs>
    journalLikes?: boolean | Journals$journalLikesArgs<ExtArgs>
    journalFollows?: boolean | Journals$journalFollowsArgs<ExtArgs>
    crawlJobs?: boolean | Journals$crawlJobsArgs<ExtArgs>
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
    _count?: boolean | JournalsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JournalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type JournalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $JournalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Journals"
    objects: {
      topics: Prisma.$JournalTopicsPayload<ExtArgs>[]
      journalRanks: Prisma.$JournalRanksPayload<ExtArgs>[]
      journalLikes: Prisma.$JournalLikesPayload<ExtArgs>[]
      journalFollows: Prisma.$JournalFollowsPayload<ExtArgs>[]
      crawlJobs: Prisma.$JournalCrawlJobsPayload<ExtArgs>[]
      createdByUser: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      issn: string
      hIndex: number
      publisher: string
      nation: string
      scope: string
      emailSubmission: string
      creator: string
    }, ExtArgs["result"]["journals"]>
    composites: {}
  }

  type JournalsGetPayload<S extends boolean | null | undefined | JournalsDefaultArgs> = $Result.GetResult<Prisma.$JournalsPayload, S>

  type JournalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalsCountAggregateInputType | true
    }

  export interface JournalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Journals'], meta: { name: 'Journals' } }
    /**
     * Find zero or one Journals that matches the filter.
     * @param {JournalsFindUniqueArgs} args - Arguments to find a Journals
     * @example
     * // Get one Journals
     * const journals = await prisma.journals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalsFindUniqueArgs>(args: SelectSubset<T, JournalsFindUniqueArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Journals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalsFindUniqueOrThrowArgs} args - Arguments to find a Journals
     * @example
     * // Get one Journals
     * const journals = await prisma.journals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalsFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsFindFirstArgs} args - Arguments to find a Journals
     * @example
     * // Get one Journals
     * const journals = await prisma.journals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalsFindFirstArgs>(args?: SelectSubset<T, JournalsFindFirstArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsFindFirstOrThrowArgs} args - Arguments to find a Journals
     * @example
     * // Get one Journals
     * const journals = await prisma.journals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalsFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Journals
     * const journals = await prisma.journals.findMany()
     * 
     * // Get first 10 Journals
     * const journals = await prisma.journals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalsWithIdOnly = await prisma.journals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalsFindManyArgs>(args?: SelectSubset<T, JournalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Journals.
     * @param {JournalsCreateArgs} args - Arguments to create a Journals.
     * @example
     * // Create one Journals
     * const Journals = await prisma.journals.create({
     *   data: {
     *     // ... data to create a Journals
     *   }
     * })
     * 
     */
    create<T extends JournalsCreateArgs>(args: SelectSubset<T, JournalsCreateArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Journals.
     * @param {JournalsCreateManyArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journals = await prisma.journals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalsCreateManyArgs>(args?: SelectSubset<T, JournalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Journals and returns the data saved in the database.
     * @param {JournalsCreateManyAndReturnArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journals = await prisma.journals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Journals and only return the `id`
     * const journalsWithIdOnly = await prisma.journals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalsCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Journals.
     * @param {JournalsDeleteArgs} args - Arguments to delete one Journals.
     * @example
     * // Delete one Journals
     * const Journals = await prisma.journals.delete({
     *   where: {
     *     // ... filter to delete one Journals
     *   }
     * })
     * 
     */
    delete<T extends JournalsDeleteArgs>(args: SelectSubset<T, JournalsDeleteArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Journals.
     * @param {JournalsUpdateArgs} args - Arguments to update one Journals.
     * @example
     * // Update one Journals
     * const journals = await prisma.journals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalsUpdateArgs>(args: SelectSubset<T, JournalsUpdateArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Journals.
     * @param {JournalsDeleteManyArgs} args - Arguments to filter Journals to delete.
     * @example
     * // Delete a few Journals
     * const { count } = await prisma.journals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalsDeleteManyArgs>(args?: SelectSubset<T, JournalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Journals
     * const journals = await prisma.journals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalsUpdateManyArgs>(args: SelectSubset<T, JournalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals and returns the data updated in the database.
     * @param {JournalsUpdateManyAndReturnArgs} args - Arguments to update many Journals.
     * @example
     * // Update many Journals
     * const journals = await prisma.journals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Journals and only return the `id`
     * const journalsWithIdOnly = await prisma.journals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalsUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Journals.
     * @param {JournalsUpsertArgs} args - Arguments to update or create a Journals.
     * @example
     * // Update or create a Journals
     * const journals = await prisma.journals.upsert({
     *   create: {
     *     // ... data to create a Journals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Journals we want to update
     *   }
     * })
     */
    upsert<T extends JournalsUpsertArgs>(args: SelectSubset<T, JournalsUpsertArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsCountArgs} args - Arguments to filter Journals to count.
     * @example
     * // Count the number of Journals
     * const count = await prisma.journals.count({
     *   where: {
     *     // ... the filter for the Journals we want to count
     *   }
     * })
    **/
    count<T extends JournalsCountArgs>(
      args?: Subset<T, JournalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalsAggregateArgs>(args: Subset<T, JournalsAggregateArgs>): Prisma.PrismaPromise<GetJournalsAggregateType<T>>

    /**
     * Group by Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalsGroupByArgs['orderBy'] }
        : { orderBy?: JournalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Journals model
   */
  readonly fields: JournalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Journals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topics<T extends Journals$topicsArgs<ExtArgs> = {}>(args?: Subset<T, Journals$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTopicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalRanks<T extends Journals$journalRanksArgs<ExtArgs> = {}>(args?: Subset<T, Journals$journalRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalLikes<T extends Journals$journalLikesArgs<ExtArgs> = {}>(args?: Subset<T, Journals$journalLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalFollows<T extends Journals$journalFollowsArgs<ExtArgs> = {}>(args?: Subset<T, Journals$journalFollowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crawlJobs<T extends Journals$crawlJobsArgs<ExtArgs> = {}>(args?: Subset<T, Journals$crawlJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdByUser<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Journals model
   */ 
  interface JournalsFieldRefs {
    readonly id: FieldRef<"Journals", 'String'>
    readonly name: FieldRef<"Journals", 'String'>
    readonly issn: FieldRef<"Journals", 'String'>
    readonly hIndex: FieldRef<"Journals", 'Int'>
    readonly publisher: FieldRef<"Journals", 'String'>
    readonly nation: FieldRef<"Journals", 'String'>
    readonly scope: FieldRef<"Journals", 'String'>
    readonly emailSubmission: FieldRef<"Journals", 'String'>
    readonly creator: FieldRef<"Journals", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Journals findUnique
   */
  export type JournalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where: JournalsWhereUniqueInput
  }

  /**
   * Journals findUniqueOrThrow
   */
  export type JournalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where: JournalsWhereUniqueInput
  }

  /**
   * Journals findFirst
   */
  export type JournalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalsOrderByWithRelationInput | JournalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalsScalarFieldEnum | JournalsScalarFieldEnum[]
  }

  /**
   * Journals findFirstOrThrow
   */
  export type JournalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalsOrderByWithRelationInput | JournalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalsScalarFieldEnum | JournalsScalarFieldEnum[]
  }

  /**
   * Journals findMany
   */
  export type JournalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalsOrderByWithRelationInput | JournalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Journals.
     */
    cursor?: JournalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    distinct?: JournalsScalarFieldEnum | JournalsScalarFieldEnum[]
  }

  /**
   * Journals create
   */
  export type JournalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * The data needed to create a Journals.
     */
    data: XOR<JournalsCreateInput, JournalsUncheckedCreateInput>
  }

  /**
   * Journals createMany
   */
  export type JournalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Journals.
     */
    data: JournalsCreateManyInput | JournalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Journals createManyAndReturn
   */
  export type JournalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * The data used to create many Journals.
     */
    data: JournalsCreateManyInput | JournalsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Journals update
   */
  export type JournalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * The data needed to update a Journals.
     */
    data: XOR<JournalsUpdateInput, JournalsUncheckedUpdateInput>
    /**
     * Choose, which Journals to update.
     */
    where: JournalsWhereUniqueInput
  }

  /**
   * Journals updateMany
   */
  export type JournalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalsUpdateManyMutationInput, JournalsUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalsWhereInput
    /**
     * Limit how many Journals to update.
     */
    limit?: number
  }

  /**
   * Journals updateManyAndReturn
   */
  export type JournalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalsUpdateManyMutationInput, JournalsUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalsWhereInput
    /**
     * Limit how many Journals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Journals upsert
   */
  export type JournalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * The filter to search for the Journals to update in case it exists.
     */
    where: JournalsWhereUniqueInput
    /**
     * In case the Journals found by the `where` argument doesn't exist, create a new Journals with this data.
     */
    create: XOR<JournalsCreateInput, JournalsUncheckedCreateInput>
    /**
     * In case the Journals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalsUpdateInput, JournalsUncheckedUpdateInput>
  }

  /**
   * Journals delete
   */
  export type JournalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    /**
     * Filter which Journals to delete.
     */
    where: JournalsWhereUniqueInput
  }

  /**
   * Journals deleteMany
   */
  export type JournalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journals to delete
     */
    where?: JournalsWhereInput
    /**
     * Limit how many Journals to delete.
     */
    limit?: number
  }

  /**
   * Journals.topics
   */
  export type Journals$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTopics
     */
    select?: JournalTopicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalTopics
     */
    omit?: JournalTopicsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTopicsInclude<ExtArgs> | null
    where?: JournalTopicsWhereInput
    orderBy?: JournalTopicsOrderByWithRelationInput | JournalTopicsOrderByWithRelationInput[]
    cursor?: JournalTopicsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalTopicsScalarFieldEnum | JournalTopicsScalarFieldEnum[]
  }

  /**
   * Journals.journalRanks
   */
  export type Journals$journalRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalRanks
     */
    select?: JournalRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalRanks
     */
    omit?: JournalRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalRanksInclude<ExtArgs> | null
    where?: JournalRanksWhereInput
    orderBy?: JournalRanksOrderByWithRelationInput | JournalRanksOrderByWithRelationInput[]
    cursor?: JournalRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalRanksScalarFieldEnum | JournalRanksScalarFieldEnum[]
  }

  /**
   * Journals.journalLikes
   */
  export type Journals$journalLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    where?: JournalLikesWhereInput
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    cursor?: JournalLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLikesScalarFieldEnum | JournalLikesScalarFieldEnum[]
  }

  /**
   * Journals.journalFollows
   */
  export type Journals$journalFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    where?: JournalFollowsWhereInput
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    cursor?: JournalFollowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalFollowsScalarFieldEnum | JournalFollowsScalarFieldEnum[]
  }

  /**
   * Journals.crawlJobs
   */
  export type Journals$crawlJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    where?: JournalCrawlJobsWhereInput
    orderBy?: JournalCrawlJobsOrderByWithRelationInput | JournalCrawlJobsOrderByWithRelationInput[]
    cursor?: JournalCrawlJobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalCrawlJobsScalarFieldEnum | JournalCrawlJobsScalarFieldEnum[]
  }

  /**
   * Journals without action
   */
  export type JournalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceFollows
   */

  export type AggregateConferenceFollows = {
    _count: ConferenceFollowsCountAggregateOutputType | null
    _min: ConferenceFollowsMinAggregateOutputType | null
    _max: ConferenceFollowsMaxAggregateOutputType | null
  }

  export type ConferenceFollowsMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceFollowsMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceFollowsCountAggregateOutputType = {
    id: number
    conferenceId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceFollowsMinAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceFollowsMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceFollowsCountAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceFollowsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceFollows to aggregate.
     */
    where?: ConferenceFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFollows to fetch.
     */
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceFollows
    **/
    _count?: true | ConferenceFollowsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceFollowsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceFollowsMaxAggregateInputType
  }

  export type GetConferenceFollowsAggregateType<T extends ConferenceFollowsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceFollows]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceFollows[P]>
      : GetScalarType<T[P], AggregateConferenceFollows[P]>
  }




  export type ConferenceFollowsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFollowsWhereInput
    orderBy?: ConferenceFollowsOrderByWithAggregationInput | ConferenceFollowsOrderByWithAggregationInput[]
    by: ConferenceFollowsScalarFieldEnum[] | ConferenceFollowsScalarFieldEnum
    having?: ConferenceFollowsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceFollowsCountAggregateInputType | true
    _min?: ConferenceFollowsMinAggregateInputType
    _max?: ConferenceFollowsMaxAggregateInputType
  }

  export type ConferenceFollowsGroupByOutputType = {
    id: string
    conferenceId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceFollowsCountAggregateOutputType | null
    _min: ConferenceFollowsMinAggregateOutputType | null
    _max: ConferenceFollowsMaxAggregateOutputType | null
  }

  type GetConferenceFollowsGroupByPayload<T extends ConferenceFollowsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceFollowsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceFollowsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceFollowsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceFollowsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceFollowsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFollows"]>

  export type ConferenceFollowsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFollows"]>

  export type ConferenceFollowsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFollows"]>

  export type ConferenceFollowsSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceFollowsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceFollows"]>
  export type ConferenceFollowsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceFollowsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceFollowsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConferenceFollowsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceFollows"
    objects: {
      belongsTo: Prisma.$ConferencesPayload<ExtArgs>
      byUser: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceFollows"]>
    composites: {}
  }

  type ConferenceFollowsGetPayload<S extends boolean | null | undefined | ConferenceFollowsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceFollowsPayload, S>

  type ConferenceFollowsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceFollowsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceFollowsCountAggregateInputType | true
    }

  export interface ConferenceFollowsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceFollows'], meta: { name: 'ConferenceFollows' } }
    /**
     * Find zero or one ConferenceFollows that matches the filter.
     * @param {ConferenceFollowsFindUniqueArgs} args - Arguments to find a ConferenceFollows
     * @example
     * // Get one ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceFollowsFindUniqueArgs>(args: SelectSubset<T, ConferenceFollowsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceFollows that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceFollowsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceFollows
     * @example
     * // Get one ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceFollowsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceFollowsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsFindFirstArgs} args - Arguments to find a ConferenceFollows
     * @example
     * // Get one ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceFollowsFindFirstArgs>(args?: SelectSubset<T, ConferenceFollowsFindFirstArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceFollows that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsFindFirstOrThrowArgs} args - Arguments to find a ConferenceFollows
     * @example
     * // Get one ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceFollowsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceFollowsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findMany()
     * 
     * // Get first 10 ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceFollowsWithIdOnly = await prisma.conferenceFollows.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceFollowsFindManyArgs>(args?: SelectSubset<T, ConferenceFollowsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceFollows.
     * @param {ConferenceFollowsCreateArgs} args - Arguments to create a ConferenceFollows.
     * @example
     * // Create one ConferenceFollows
     * const ConferenceFollows = await prisma.conferenceFollows.create({
     *   data: {
     *     // ... data to create a ConferenceFollows
     *   }
     * })
     * 
     */
    create<T extends ConferenceFollowsCreateArgs>(args: SelectSubset<T, ConferenceFollowsCreateArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceFollows.
     * @param {ConferenceFollowsCreateManyArgs} args - Arguments to create many ConferenceFollows.
     * @example
     * // Create many ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceFollowsCreateManyArgs>(args?: SelectSubset<T, ConferenceFollowsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceFollows and returns the data saved in the database.
     * @param {ConferenceFollowsCreateManyAndReturnArgs} args - Arguments to create many ConferenceFollows.
     * @example
     * // Create many ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceFollows and only return the `id`
     * const conferenceFollowsWithIdOnly = await prisma.conferenceFollows.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceFollowsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceFollowsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceFollows.
     * @param {ConferenceFollowsDeleteArgs} args - Arguments to delete one ConferenceFollows.
     * @example
     * // Delete one ConferenceFollows
     * const ConferenceFollows = await prisma.conferenceFollows.delete({
     *   where: {
     *     // ... filter to delete one ConferenceFollows
     *   }
     * })
     * 
     */
    delete<T extends ConferenceFollowsDeleteArgs>(args: SelectSubset<T, ConferenceFollowsDeleteArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceFollows.
     * @param {ConferenceFollowsUpdateArgs} args - Arguments to update one ConferenceFollows.
     * @example
     * // Update one ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceFollowsUpdateArgs>(args: SelectSubset<T, ConferenceFollowsUpdateArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceFollows.
     * @param {ConferenceFollowsDeleteManyArgs} args - Arguments to filter ConferenceFollows to delete.
     * @example
     * // Delete a few ConferenceFollows
     * const { count } = await prisma.conferenceFollows.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceFollowsDeleteManyArgs>(args?: SelectSubset<T, ConferenceFollowsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceFollowsUpdateManyArgs>(args: SelectSubset<T, ConferenceFollowsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceFollows and returns the data updated in the database.
     * @param {ConferenceFollowsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceFollows.
     * @example
     * // Update many ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceFollows and only return the `id`
     * const conferenceFollowsWithIdOnly = await prisma.conferenceFollows.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceFollowsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceFollowsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceFollows.
     * @param {ConferenceFollowsUpsertArgs} args - Arguments to update or create a ConferenceFollows.
     * @example
     * // Update or create a ConferenceFollows
     * const conferenceFollows = await prisma.conferenceFollows.upsert({
     *   create: {
     *     // ... data to create a ConferenceFollows
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceFollows we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceFollowsUpsertArgs>(args: SelectSubset<T, ConferenceFollowsUpsertArgs<ExtArgs>>): Prisma__ConferenceFollowsClient<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsCountArgs} args - Arguments to filter ConferenceFollows to count.
     * @example
     * // Count the number of ConferenceFollows
     * const count = await prisma.conferenceFollows.count({
     *   where: {
     *     // ... the filter for the ConferenceFollows we want to count
     *   }
     * })
    **/
    count<T extends ConferenceFollowsCountArgs>(
      args?: Subset<T, ConferenceFollowsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceFollowsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceFollowsAggregateArgs>(args: Subset<T, ConferenceFollowsAggregateArgs>): Prisma.PrismaPromise<GetConferenceFollowsAggregateType<T>>

    /**
     * Group by ConferenceFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFollowsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceFollowsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceFollowsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceFollowsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceFollowsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceFollowsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceFollows model
   */
  readonly fields: ConferenceFollowsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceFollows.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceFollowsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    byUser<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceFollows model
   */ 
  interface ConferenceFollowsFieldRefs {
    readonly id: FieldRef<"ConferenceFollows", 'String'>
    readonly conferenceId: FieldRef<"ConferenceFollows", 'String'>
    readonly userId: FieldRef<"ConferenceFollows", 'String'>
    readonly createdAt: FieldRef<"ConferenceFollows", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceFollows", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceFollows findUnique
   */
  export type ConferenceFollowsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFollows to fetch.
     */
    where: ConferenceFollowsWhereUniqueInput
  }

  /**
   * ConferenceFollows findUniqueOrThrow
   */
  export type ConferenceFollowsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFollows to fetch.
     */
    where: ConferenceFollowsWhereUniqueInput
  }

  /**
   * ConferenceFollows findFirst
   */
  export type ConferenceFollowsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFollows to fetch.
     */
    where?: ConferenceFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFollows to fetch.
     */
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceFollows.
     */
    cursor?: ConferenceFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceFollows.
     */
    distinct?: ConferenceFollowsScalarFieldEnum | ConferenceFollowsScalarFieldEnum[]
  }

  /**
   * ConferenceFollows findFirstOrThrow
   */
  export type ConferenceFollowsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFollows to fetch.
     */
    where?: ConferenceFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFollows to fetch.
     */
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceFollows.
     */
    cursor?: ConferenceFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceFollows.
     */
    distinct?: ConferenceFollowsScalarFieldEnum | ConferenceFollowsScalarFieldEnum[]
  }

  /**
   * ConferenceFollows findMany
   */
  export type ConferenceFollowsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFollows to fetch.
     */
    where?: ConferenceFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFollows to fetch.
     */
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceFollows.
     */
    cursor?: ConferenceFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFollows.
     */
    skip?: number
    distinct?: ConferenceFollowsScalarFieldEnum | ConferenceFollowsScalarFieldEnum[]
  }

  /**
   * ConferenceFollows create
   */
  export type ConferenceFollowsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceFollows.
     */
    data: XOR<ConferenceFollowsCreateInput, ConferenceFollowsUncheckedCreateInput>
  }

  /**
   * ConferenceFollows createMany
   */
  export type ConferenceFollowsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceFollows.
     */
    data: ConferenceFollowsCreateManyInput | ConferenceFollowsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceFollows createManyAndReturn
   */
  export type ConferenceFollowsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceFollows.
     */
    data: ConferenceFollowsCreateManyInput | ConferenceFollowsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceFollows update
   */
  export type ConferenceFollowsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceFollows.
     */
    data: XOR<ConferenceFollowsUpdateInput, ConferenceFollowsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceFollows to update.
     */
    where: ConferenceFollowsWhereUniqueInput
  }

  /**
   * ConferenceFollows updateMany
   */
  export type ConferenceFollowsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceFollows.
     */
    data: XOR<ConferenceFollowsUpdateManyMutationInput, ConferenceFollowsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceFollows to update
     */
    where?: ConferenceFollowsWhereInput
    /**
     * Limit how many ConferenceFollows to update.
     */
    limit?: number
  }

  /**
   * ConferenceFollows updateManyAndReturn
   */
  export type ConferenceFollowsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceFollows.
     */
    data: XOR<ConferenceFollowsUpdateManyMutationInput, ConferenceFollowsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceFollows to update
     */
    where?: ConferenceFollowsWhereInput
    /**
     * Limit how many ConferenceFollows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceFollows upsert
   */
  export type ConferenceFollowsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceFollows to update in case it exists.
     */
    where: ConferenceFollowsWhereUniqueInput
    /**
     * In case the ConferenceFollows found by the `where` argument doesn't exist, create a new ConferenceFollows with this data.
     */
    create: XOR<ConferenceFollowsCreateInput, ConferenceFollowsUncheckedCreateInput>
    /**
     * In case the ConferenceFollows was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceFollowsUpdateInput, ConferenceFollowsUncheckedUpdateInput>
  }

  /**
   * ConferenceFollows delete
   */
  export type ConferenceFollowsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceFollows to delete.
     */
    where: ConferenceFollowsWhereUniqueInput
  }

  /**
   * ConferenceFollows deleteMany
   */
  export type ConferenceFollowsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceFollows to delete
     */
    where?: ConferenceFollowsWhereInput
    /**
     * Limit how many ConferenceFollows to delete.
     */
    limit?: number
  }

  /**
   * ConferenceFollows without action
   */
  export type ConferenceFollowsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceLikes
   */

  export type AggregateConferenceLikes = {
    _count: ConferenceLikesCountAggregateOutputType | null
    _min: ConferenceLikesMinAggregateOutputType | null
    _max: ConferenceLikesMaxAggregateOutputType | null
  }

  export type ConferenceLikesMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceLikesMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceLikesCountAggregateOutputType = {
    id: number
    conferenceId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceLikesMinAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceLikesMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceLikesCountAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceLikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceLikes to aggregate.
     */
    where?: ConferenceLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceLikes to fetch.
     */
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceLikes
    **/
    _count?: true | ConferenceLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceLikesMaxAggregateInputType
  }

  export type GetConferenceLikesAggregateType<T extends ConferenceLikesAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceLikes[P]>
      : GetScalarType<T[P], AggregateConferenceLikes[P]>
  }




  export type ConferenceLikesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceLikesWhereInput
    orderBy?: ConferenceLikesOrderByWithAggregationInput | ConferenceLikesOrderByWithAggregationInput[]
    by: ConferenceLikesScalarFieldEnum[] | ConferenceLikesScalarFieldEnum
    having?: ConferenceLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceLikesCountAggregateInputType | true
    _min?: ConferenceLikesMinAggregateInputType
    _max?: ConferenceLikesMaxAggregateInputType
  }

  export type ConferenceLikesGroupByOutputType = {
    id: string
    conferenceId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceLikesCountAggregateOutputType | null
    _min: ConferenceLikesMinAggregateOutputType | null
    _max: ConferenceLikesMaxAggregateOutputType | null
  }

  type GetConferenceLikesGroupByPayload<T extends ConferenceLikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceLikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceLikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceLikesGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceLikesGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceLikesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceLikes"]>

  export type ConferenceLikesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceLikes"]>

  export type ConferenceLikesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceLikes"]>

  export type ConferenceLikesSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceLikesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceLikes"]>
  export type ConferenceLikesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceLikesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceLikesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConferenceLikesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceLikes"
    objects: {
      belongsTo: Prisma.$ConferencesPayload<ExtArgs>
      byUser: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceLikes"]>
    composites: {}
  }

  type ConferenceLikesGetPayload<S extends boolean | null | undefined | ConferenceLikesDefaultArgs> = $Result.GetResult<Prisma.$ConferenceLikesPayload, S>

  type ConferenceLikesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceLikesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceLikesCountAggregateInputType | true
    }

  export interface ConferenceLikesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceLikes'], meta: { name: 'ConferenceLikes' } }
    /**
     * Find zero or one ConferenceLikes that matches the filter.
     * @param {ConferenceLikesFindUniqueArgs} args - Arguments to find a ConferenceLikes
     * @example
     * // Get one ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceLikesFindUniqueArgs>(args: SelectSubset<T, ConferenceLikesFindUniqueArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceLikes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceLikesFindUniqueOrThrowArgs} args - Arguments to find a ConferenceLikes
     * @example
     * // Get one ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceLikesFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceLikesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesFindFirstArgs} args - Arguments to find a ConferenceLikes
     * @example
     * // Get one ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceLikesFindFirstArgs>(args?: SelectSubset<T, ConferenceLikesFindFirstArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceLikes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesFindFirstOrThrowArgs} args - Arguments to find a ConferenceLikes
     * @example
     * // Get one ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceLikesFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceLikesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findMany()
     * 
     * // Get first 10 ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceLikesWithIdOnly = await prisma.conferenceLikes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceLikesFindManyArgs>(args?: SelectSubset<T, ConferenceLikesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceLikes.
     * @param {ConferenceLikesCreateArgs} args - Arguments to create a ConferenceLikes.
     * @example
     * // Create one ConferenceLikes
     * const ConferenceLikes = await prisma.conferenceLikes.create({
     *   data: {
     *     // ... data to create a ConferenceLikes
     *   }
     * })
     * 
     */
    create<T extends ConferenceLikesCreateArgs>(args: SelectSubset<T, ConferenceLikesCreateArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceLikes.
     * @param {ConferenceLikesCreateManyArgs} args - Arguments to create many ConferenceLikes.
     * @example
     * // Create many ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceLikesCreateManyArgs>(args?: SelectSubset<T, ConferenceLikesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceLikes and returns the data saved in the database.
     * @param {ConferenceLikesCreateManyAndReturnArgs} args - Arguments to create many ConferenceLikes.
     * @example
     * // Create many ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceLikes and only return the `id`
     * const conferenceLikesWithIdOnly = await prisma.conferenceLikes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceLikesCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceLikesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceLikes.
     * @param {ConferenceLikesDeleteArgs} args - Arguments to delete one ConferenceLikes.
     * @example
     * // Delete one ConferenceLikes
     * const ConferenceLikes = await prisma.conferenceLikes.delete({
     *   where: {
     *     // ... filter to delete one ConferenceLikes
     *   }
     * })
     * 
     */
    delete<T extends ConferenceLikesDeleteArgs>(args: SelectSubset<T, ConferenceLikesDeleteArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceLikes.
     * @param {ConferenceLikesUpdateArgs} args - Arguments to update one ConferenceLikes.
     * @example
     * // Update one ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceLikesUpdateArgs>(args: SelectSubset<T, ConferenceLikesUpdateArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceLikes.
     * @param {ConferenceLikesDeleteManyArgs} args - Arguments to filter ConferenceLikes to delete.
     * @example
     * // Delete a few ConferenceLikes
     * const { count } = await prisma.conferenceLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceLikesDeleteManyArgs>(args?: SelectSubset<T, ConferenceLikesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceLikesUpdateManyArgs>(args: SelectSubset<T, ConferenceLikesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceLikes and returns the data updated in the database.
     * @param {ConferenceLikesUpdateManyAndReturnArgs} args - Arguments to update many ConferenceLikes.
     * @example
     * // Update many ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceLikes and only return the `id`
     * const conferenceLikesWithIdOnly = await prisma.conferenceLikes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceLikesUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceLikesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceLikes.
     * @param {ConferenceLikesUpsertArgs} args - Arguments to update or create a ConferenceLikes.
     * @example
     * // Update or create a ConferenceLikes
     * const conferenceLikes = await prisma.conferenceLikes.upsert({
     *   create: {
     *     // ... data to create a ConferenceLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceLikes we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceLikesUpsertArgs>(args: SelectSubset<T, ConferenceLikesUpsertArgs<ExtArgs>>): Prisma__ConferenceLikesClient<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesCountArgs} args - Arguments to filter ConferenceLikes to count.
     * @example
     * // Count the number of ConferenceLikes
     * const count = await prisma.conferenceLikes.count({
     *   where: {
     *     // ... the filter for the ConferenceLikes we want to count
     *   }
     * })
    **/
    count<T extends ConferenceLikesCountArgs>(
      args?: Subset<T, ConferenceLikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceLikesAggregateArgs>(args: Subset<T, ConferenceLikesAggregateArgs>): Prisma.PrismaPromise<GetConferenceLikesAggregateType<T>>

    /**
     * Group by ConferenceLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceLikesGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceLikes model
   */
  readonly fields: ConferenceLikesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceLikesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    byUser<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceLikes model
   */ 
  interface ConferenceLikesFieldRefs {
    readonly id: FieldRef<"ConferenceLikes", 'String'>
    readonly conferenceId: FieldRef<"ConferenceLikes", 'String'>
    readonly userId: FieldRef<"ConferenceLikes", 'String'>
    readonly createdAt: FieldRef<"ConferenceLikes", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceLikes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceLikes findUnique
   */
  export type ConferenceLikesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceLikes to fetch.
     */
    where: ConferenceLikesWhereUniqueInput
  }

  /**
   * ConferenceLikes findUniqueOrThrow
   */
  export type ConferenceLikesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceLikes to fetch.
     */
    where: ConferenceLikesWhereUniqueInput
  }

  /**
   * ConferenceLikes findFirst
   */
  export type ConferenceLikesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceLikes to fetch.
     */
    where?: ConferenceLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceLikes to fetch.
     */
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceLikes.
     */
    cursor?: ConferenceLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceLikes.
     */
    distinct?: ConferenceLikesScalarFieldEnum | ConferenceLikesScalarFieldEnum[]
  }

  /**
   * ConferenceLikes findFirstOrThrow
   */
  export type ConferenceLikesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceLikes to fetch.
     */
    where?: ConferenceLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceLikes to fetch.
     */
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceLikes.
     */
    cursor?: ConferenceLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceLikes.
     */
    distinct?: ConferenceLikesScalarFieldEnum | ConferenceLikesScalarFieldEnum[]
  }

  /**
   * ConferenceLikes findMany
   */
  export type ConferenceLikesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceLikes to fetch.
     */
    where?: ConferenceLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceLikes to fetch.
     */
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceLikes.
     */
    cursor?: ConferenceLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceLikes.
     */
    skip?: number
    distinct?: ConferenceLikesScalarFieldEnum | ConferenceLikesScalarFieldEnum[]
  }

  /**
   * ConferenceLikes create
   */
  export type ConferenceLikesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceLikes.
     */
    data: XOR<ConferenceLikesCreateInput, ConferenceLikesUncheckedCreateInput>
  }

  /**
   * ConferenceLikes createMany
   */
  export type ConferenceLikesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceLikes.
     */
    data: ConferenceLikesCreateManyInput | ConferenceLikesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceLikes createManyAndReturn
   */
  export type ConferenceLikesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceLikes.
     */
    data: ConferenceLikesCreateManyInput | ConferenceLikesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceLikes update
   */
  export type ConferenceLikesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceLikes.
     */
    data: XOR<ConferenceLikesUpdateInput, ConferenceLikesUncheckedUpdateInput>
    /**
     * Choose, which ConferenceLikes to update.
     */
    where: ConferenceLikesWhereUniqueInput
  }

  /**
   * ConferenceLikes updateMany
   */
  export type ConferenceLikesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceLikes.
     */
    data: XOR<ConferenceLikesUpdateManyMutationInput, ConferenceLikesUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceLikes to update
     */
    where?: ConferenceLikesWhereInput
    /**
     * Limit how many ConferenceLikes to update.
     */
    limit?: number
  }

  /**
   * ConferenceLikes updateManyAndReturn
   */
  export type ConferenceLikesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceLikes.
     */
    data: XOR<ConferenceLikesUpdateManyMutationInput, ConferenceLikesUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceLikes to update
     */
    where?: ConferenceLikesWhereInput
    /**
     * Limit how many ConferenceLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceLikes upsert
   */
  export type ConferenceLikesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceLikes to update in case it exists.
     */
    where: ConferenceLikesWhereUniqueInput
    /**
     * In case the ConferenceLikes found by the `where` argument doesn't exist, create a new ConferenceLikes with this data.
     */
    create: XOR<ConferenceLikesCreateInput, ConferenceLikesUncheckedCreateInput>
    /**
     * In case the ConferenceLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceLikesUpdateInput, ConferenceLikesUncheckedUpdateInput>
  }

  /**
   * ConferenceLikes delete
   */
  export type ConferenceLikesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    /**
     * Filter which ConferenceLikes to delete.
     */
    where: ConferenceLikesWhereUniqueInput
  }

  /**
   * ConferenceLikes deleteMany
   */
  export type ConferenceLikesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceLikes to delete
     */
    where?: ConferenceLikesWhereInput
    /**
     * Limit how many ConferenceLikes to delete.
     */
    limit?: number
  }

  /**
   * ConferenceLikes without action
   */
  export type ConferenceLikesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceFeedbacks
   */

  export type AggregateConferenceFeedbacks = {
    _count: ConferenceFeedbacksCountAggregateOutputType | null
    _avg: ConferenceFeedbacksAvgAggregateOutputType | null
    _sum: ConferenceFeedbacksSumAggregateOutputType | null
    _min: ConferenceFeedbacksMinAggregateOutputType | null
    _max: ConferenceFeedbacksMaxAggregateOutputType | null
  }

  export type ConferenceFeedbacksAvgAggregateOutputType = {
    star: number | null
  }

  export type ConferenceFeedbacksSumAggregateOutputType = {
    star: number | null
  }

  export type ConferenceFeedbacksMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    creatorId: string | null
    description: string | null
    star: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceFeedbacksMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    creatorId: string | null
    description: string | null
    star: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceFeedbacksCountAggregateOutputType = {
    id: number
    conferenceId: number
    creatorId: number
    description: number
    star: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceFeedbacksAvgAggregateInputType = {
    star?: true
  }

  export type ConferenceFeedbacksSumAggregateInputType = {
    star?: true
  }

  export type ConferenceFeedbacksMinAggregateInputType = {
    id?: true
    conferenceId?: true
    creatorId?: true
    description?: true
    star?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceFeedbacksMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    creatorId?: true
    description?: true
    star?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceFeedbacksCountAggregateInputType = {
    id?: true
    conferenceId?: true
    creatorId?: true
    description?: true
    star?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceFeedbacksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceFeedbacks to aggregate.
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceFeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceFeedbacks
    **/
    _count?: true | ConferenceFeedbacksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceFeedbacksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceFeedbacksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceFeedbacksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceFeedbacksMaxAggregateInputType
  }

  export type GetConferenceFeedbacksAggregateType<T extends ConferenceFeedbacksAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceFeedbacks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceFeedbacks[P]>
      : GetScalarType<T[P], AggregateConferenceFeedbacks[P]>
  }




  export type ConferenceFeedbacksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceFeedbacksWhereInput
    orderBy?: ConferenceFeedbacksOrderByWithAggregationInput | ConferenceFeedbacksOrderByWithAggregationInput[]
    by: ConferenceFeedbacksScalarFieldEnum[] | ConferenceFeedbacksScalarFieldEnum
    having?: ConferenceFeedbacksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceFeedbacksCountAggregateInputType | true
    _avg?: ConferenceFeedbacksAvgAggregateInputType
    _sum?: ConferenceFeedbacksSumAggregateInputType
    _min?: ConferenceFeedbacksMinAggregateInputType
    _max?: ConferenceFeedbacksMaxAggregateInputType
  }

  export type ConferenceFeedbacksGroupByOutputType = {
    id: string
    conferenceId: string
    creatorId: string
    description: string
    star: number
    createdAt: Date
    updatedAt: Date
    _count: ConferenceFeedbacksCountAggregateOutputType | null
    _avg: ConferenceFeedbacksAvgAggregateOutputType | null
    _sum: ConferenceFeedbacksSumAggregateOutputType | null
    _min: ConferenceFeedbacksMinAggregateOutputType | null
    _max: ConferenceFeedbacksMaxAggregateOutputType | null
  }

  type GetConferenceFeedbacksGroupByPayload<T extends ConferenceFeedbacksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceFeedbacksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceFeedbacksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceFeedbacksGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceFeedbacksGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceFeedbacksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    creatorId?: boolean
    description?: boolean
    star?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFeedbacks"]>

  export type ConferenceFeedbacksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    creatorId?: boolean
    description?: boolean
    star?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFeedbacks"]>

  export type ConferenceFeedbacksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    creatorId?: boolean
    description?: boolean
    star?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceFeedbacks"]>

  export type ConferenceFeedbacksSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    creatorId?: boolean
    description?: boolean
    star?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceFeedbacksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "creatorId" | "description" | "star" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceFeedbacks"]>
  export type ConferenceFeedbacksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceFeedbacksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceFeedbacksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConferenceFeedbacksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceFeedbacks"
    objects: {
      belongsTo: Prisma.$ConferencesPayload<ExtArgs>
      byUser: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      creatorId: string
      description: string
      star: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceFeedbacks"]>
    composites: {}
  }

  type ConferenceFeedbacksGetPayload<S extends boolean | null | undefined | ConferenceFeedbacksDefaultArgs> = $Result.GetResult<Prisma.$ConferenceFeedbacksPayload, S>

  type ConferenceFeedbacksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceFeedbacksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceFeedbacksCountAggregateInputType | true
    }

  export interface ConferenceFeedbacksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceFeedbacks'], meta: { name: 'ConferenceFeedbacks' } }
    /**
     * Find zero or one ConferenceFeedbacks that matches the filter.
     * @param {ConferenceFeedbacksFindUniqueArgs} args - Arguments to find a ConferenceFeedbacks
     * @example
     * // Get one ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceFeedbacksFindUniqueArgs>(args: SelectSubset<T, ConferenceFeedbacksFindUniqueArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceFeedbacks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceFeedbacksFindUniqueOrThrowArgs} args - Arguments to find a ConferenceFeedbacks
     * @example
     * // Get one ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceFeedbacksFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceFeedbacksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksFindFirstArgs} args - Arguments to find a ConferenceFeedbacks
     * @example
     * // Get one ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceFeedbacksFindFirstArgs>(args?: SelectSubset<T, ConferenceFeedbacksFindFirstArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceFeedbacks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksFindFirstOrThrowArgs} args - Arguments to find a ConferenceFeedbacks
     * @example
     * // Get one ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceFeedbacksFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceFeedbacksFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findMany()
     * 
     * // Get first 10 ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceFeedbacksWithIdOnly = await prisma.conferenceFeedbacks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceFeedbacksFindManyArgs>(args?: SelectSubset<T, ConferenceFeedbacksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceFeedbacks.
     * @param {ConferenceFeedbacksCreateArgs} args - Arguments to create a ConferenceFeedbacks.
     * @example
     * // Create one ConferenceFeedbacks
     * const ConferenceFeedbacks = await prisma.conferenceFeedbacks.create({
     *   data: {
     *     // ... data to create a ConferenceFeedbacks
     *   }
     * })
     * 
     */
    create<T extends ConferenceFeedbacksCreateArgs>(args: SelectSubset<T, ConferenceFeedbacksCreateArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceFeedbacks.
     * @param {ConferenceFeedbacksCreateManyArgs} args - Arguments to create many ConferenceFeedbacks.
     * @example
     * // Create many ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceFeedbacksCreateManyArgs>(args?: SelectSubset<T, ConferenceFeedbacksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceFeedbacks and returns the data saved in the database.
     * @param {ConferenceFeedbacksCreateManyAndReturnArgs} args - Arguments to create many ConferenceFeedbacks.
     * @example
     * // Create many ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceFeedbacks and only return the `id`
     * const conferenceFeedbacksWithIdOnly = await prisma.conferenceFeedbacks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceFeedbacksCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceFeedbacksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceFeedbacks.
     * @param {ConferenceFeedbacksDeleteArgs} args - Arguments to delete one ConferenceFeedbacks.
     * @example
     * // Delete one ConferenceFeedbacks
     * const ConferenceFeedbacks = await prisma.conferenceFeedbacks.delete({
     *   where: {
     *     // ... filter to delete one ConferenceFeedbacks
     *   }
     * })
     * 
     */
    delete<T extends ConferenceFeedbacksDeleteArgs>(args: SelectSubset<T, ConferenceFeedbacksDeleteArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceFeedbacks.
     * @param {ConferenceFeedbacksUpdateArgs} args - Arguments to update one ConferenceFeedbacks.
     * @example
     * // Update one ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceFeedbacksUpdateArgs>(args: SelectSubset<T, ConferenceFeedbacksUpdateArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceFeedbacks.
     * @param {ConferenceFeedbacksDeleteManyArgs} args - Arguments to filter ConferenceFeedbacks to delete.
     * @example
     * // Delete a few ConferenceFeedbacks
     * const { count } = await prisma.conferenceFeedbacks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceFeedbacksDeleteManyArgs>(args?: SelectSubset<T, ConferenceFeedbacksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceFeedbacksUpdateManyArgs>(args: SelectSubset<T, ConferenceFeedbacksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceFeedbacks and returns the data updated in the database.
     * @param {ConferenceFeedbacksUpdateManyAndReturnArgs} args - Arguments to update many ConferenceFeedbacks.
     * @example
     * // Update many ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceFeedbacks and only return the `id`
     * const conferenceFeedbacksWithIdOnly = await prisma.conferenceFeedbacks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceFeedbacksUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceFeedbacksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceFeedbacks.
     * @param {ConferenceFeedbacksUpsertArgs} args - Arguments to update or create a ConferenceFeedbacks.
     * @example
     * // Update or create a ConferenceFeedbacks
     * const conferenceFeedbacks = await prisma.conferenceFeedbacks.upsert({
     *   create: {
     *     // ... data to create a ConferenceFeedbacks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceFeedbacks we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceFeedbacksUpsertArgs>(args: SelectSubset<T, ConferenceFeedbacksUpsertArgs<ExtArgs>>): Prisma__ConferenceFeedbacksClient<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksCountArgs} args - Arguments to filter ConferenceFeedbacks to count.
     * @example
     * // Count the number of ConferenceFeedbacks
     * const count = await prisma.conferenceFeedbacks.count({
     *   where: {
     *     // ... the filter for the ConferenceFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends ConferenceFeedbacksCountArgs>(
      args?: Subset<T, ConferenceFeedbacksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceFeedbacksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceFeedbacksAggregateArgs>(args: Subset<T, ConferenceFeedbacksAggregateArgs>): Prisma.PrismaPromise<GetConferenceFeedbacksAggregateType<T>>

    /**
     * Group by ConferenceFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceFeedbacksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceFeedbacksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceFeedbacksGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceFeedbacksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceFeedbacksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceFeedbacksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceFeedbacks model
   */
  readonly fields: ConferenceFeedbacksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceFeedbacks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceFeedbacksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    byUser<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceFeedbacks model
   */ 
  interface ConferenceFeedbacksFieldRefs {
    readonly id: FieldRef<"ConferenceFeedbacks", 'String'>
    readonly conferenceId: FieldRef<"ConferenceFeedbacks", 'String'>
    readonly creatorId: FieldRef<"ConferenceFeedbacks", 'String'>
    readonly description: FieldRef<"ConferenceFeedbacks", 'String'>
    readonly star: FieldRef<"ConferenceFeedbacks", 'Int'>
    readonly createdAt: FieldRef<"ConferenceFeedbacks", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceFeedbacks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceFeedbacks findUnique
   */
  export type ConferenceFeedbacksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where: ConferenceFeedbacksWhereUniqueInput
  }

  /**
   * ConferenceFeedbacks findUniqueOrThrow
   */
  export type ConferenceFeedbacksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where: ConferenceFeedbacksWhereUniqueInput
  }

  /**
   * ConferenceFeedbacks findFirst
   */
  export type ConferenceFeedbacksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceFeedbacks.
     */
    cursor?: ConferenceFeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceFeedbacks.
     */
    distinct?: ConferenceFeedbacksScalarFieldEnum | ConferenceFeedbacksScalarFieldEnum[]
  }

  /**
   * ConferenceFeedbacks findFirstOrThrow
   */
  export type ConferenceFeedbacksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceFeedbacks.
     */
    cursor?: ConferenceFeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceFeedbacks.
     */
    distinct?: ConferenceFeedbacksScalarFieldEnum | ConferenceFeedbacksScalarFieldEnum[]
  }

  /**
   * ConferenceFeedbacks findMany
   */
  export type ConferenceFeedbacksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceFeedbacks to fetch.
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceFeedbacks to fetch.
     */
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceFeedbacks.
     */
    cursor?: ConferenceFeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceFeedbacks.
     */
    skip?: number
    distinct?: ConferenceFeedbacksScalarFieldEnum | ConferenceFeedbacksScalarFieldEnum[]
  }

  /**
   * ConferenceFeedbacks create
   */
  export type ConferenceFeedbacksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceFeedbacks.
     */
    data: XOR<ConferenceFeedbacksCreateInput, ConferenceFeedbacksUncheckedCreateInput>
  }

  /**
   * ConferenceFeedbacks createMany
   */
  export type ConferenceFeedbacksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceFeedbacks.
     */
    data: ConferenceFeedbacksCreateManyInput | ConferenceFeedbacksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceFeedbacks createManyAndReturn
   */
  export type ConferenceFeedbacksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceFeedbacks.
     */
    data: ConferenceFeedbacksCreateManyInput | ConferenceFeedbacksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceFeedbacks update
   */
  export type ConferenceFeedbacksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceFeedbacks.
     */
    data: XOR<ConferenceFeedbacksUpdateInput, ConferenceFeedbacksUncheckedUpdateInput>
    /**
     * Choose, which ConferenceFeedbacks to update.
     */
    where: ConferenceFeedbacksWhereUniqueInput
  }

  /**
   * ConferenceFeedbacks updateMany
   */
  export type ConferenceFeedbacksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceFeedbacks.
     */
    data: XOR<ConferenceFeedbacksUpdateManyMutationInput, ConferenceFeedbacksUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceFeedbacks to update
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * Limit how many ConferenceFeedbacks to update.
     */
    limit?: number
  }

  /**
   * ConferenceFeedbacks updateManyAndReturn
   */
  export type ConferenceFeedbacksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceFeedbacks.
     */
    data: XOR<ConferenceFeedbacksUpdateManyMutationInput, ConferenceFeedbacksUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceFeedbacks to update
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * Limit how many ConferenceFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceFeedbacks upsert
   */
  export type ConferenceFeedbacksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceFeedbacks to update in case it exists.
     */
    where: ConferenceFeedbacksWhereUniqueInput
    /**
     * In case the ConferenceFeedbacks found by the `where` argument doesn't exist, create a new ConferenceFeedbacks with this data.
     */
    create: XOR<ConferenceFeedbacksCreateInput, ConferenceFeedbacksUncheckedCreateInput>
    /**
     * In case the ConferenceFeedbacks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceFeedbacksUpdateInput, ConferenceFeedbacksUncheckedUpdateInput>
  }

  /**
   * ConferenceFeedbacks delete
   */
  export type ConferenceFeedbacksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    /**
     * Filter which ConferenceFeedbacks to delete.
     */
    where: ConferenceFeedbacksWhereUniqueInput
  }

  /**
   * ConferenceFeedbacks deleteMany
   */
  export type ConferenceFeedbacksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceFeedbacks to delete
     */
    where?: ConferenceFeedbacksWhereInput
    /**
     * Limit how many ConferenceFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * ConferenceFeedbacks without action
   */
  export type ConferenceFeedbacksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceCalendars
   */

  export type AggregateConferenceCalendars = {
    _count: ConferenceCalendarsCountAggregateOutputType | null
    _min: ConferenceCalendarsMinAggregateOutputType | null
    _max: ConferenceCalendarsMaxAggregateOutputType | null
  }

  export type ConferenceCalendarsMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceCalendarsMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceCalendarsCountAggregateOutputType = {
    id: number
    conferenceId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceCalendarsMinAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceCalendarsMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceCalendarsCountAggregateInputType = {
    id?: true
    conferenceId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceCalendarsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceCalendars to aggregate.
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCalendars to fetch.
     */
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceCalendarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceCalendars
    **/
    _count?: true | ConferenceCalendarsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceCalendarsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceCalendarsMaxAggregateInputType
  }

  export type GetConferenceCalendarsAggregateType<T extends ConferenceCalendarsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceCalendars]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceCalendars[P]>
      : GetScalarType<T[P], AggregateConferenceCalendars[P]>
  }




  export type ConferenceCalendarsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceCalendarsWhereInput
    orderBy?: ConferenceCalendarsOrderByWithAggregationInput | ConferenceCalendarsOrderByWithAggregationInput[]
    by: ConferenceCalendarsScalarFieldEnum[] | ConferenceCalendarsScalarFieldEnum
    having?: ConferenceCalendarsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceCalendarsCountAggregateInputType | true
    _min?: ConferenceCalendarsMinAggregateInputType
    _max?: ConferenceCalendarsMaxAggregateInputType
  }

  export type ConferenceCalendarsGroupByOutputType = {
    id: string
    conferenceId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceCalendarsCountAggregateOutputType | null
    _min: ConferenceCalendarsMinAggregateOutputType | null
    _max: ConferenceCalendarsMaxAggregateOutputType | null
  }

  type GetConferenceCalendarsGroupByPayload<T extends ConferenceCalendarsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceCalendarsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceCalendarsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceCalendarsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceCalendarsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceCalendarsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCalendars"]>

  export type ConferenceCalendarsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCalendars"]>

  export type ConferenceCalendarsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCalendars"]>

  export type ConferenceCalendarsSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceCalendarsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceCalendars"]>
  export type ConferenceCalendarsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceCalendarsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ConferenceCalendarsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ConferenceCalendarsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceCalendars"
    objects: {
      belongsTo: Prisma.$ConferencesPayload<ExtArgs>
      byUser: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceCalendars"]>
    composites: {}
  }

  type ConferenceCalendarsGetPayload<S extends boolean | null | undefined | ConferenceCalendarsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceCalendarsPayload, S>

  type ConferenceCalendarsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceCalendarsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceCalendarsCountAggregateInputType | true
    }

  export interface ConferenceCalendarsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceCalendars'], meta: { name: 'ConferenceCalendars' } }
    /**
     * Find zero or one ConferenceCalendars that matches the filter.
     * @param {ConferenceCalendarsFindUniqueArgs} args - Arguments to find a ConferenceCalendars
     * @example
     * // Get one ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceCalendarsFindUniqueArgs>(args: SelectSubset<T, ConferenceCalendarsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceCalendars that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceCalendarsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceCalendars
     * @example
     * // Get one ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceCalendarsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceCalendarsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceCalendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsFindFirstArgs} args - Arguments to find a ConferenceCalendars
     * @example
     * // Get one ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceCalendarsFindFirstArgs>(args?: SelectSubset<T, ConferenceCalendarsFindFirstArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceCalendars that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsFindFirstOrThrowArgs} args - Arguments to find a ConferenceCalendars
     * @example
     * // Get one ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceCalendarsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceCalendarsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceCalendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findMany()
     * 
     * // Get first 10 ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceCalendarsWithIdOnly = await prisma.conferenceCalendars.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceCalendarsFindManyArgs>(args?: SelectSubset<T, ConferenceCalendarsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceCalendars.
     * @param {ConferenceCalendarsCreateArgs} args - Arguments to create a ConferenceCalendars.
     * @example
     * // Create one ConferenceCalendars
     * const ConferenceCalendars = await prisma.conferenceCalendars.create({
     *   data: {
     *     // ... data to create a ConferenceCalendars
     *   }
     * })
     * 
     */
    create<T extends ConferenceCalendarsCreateArgs>(args: SelectSubset<T, ConferenceCalendarsCreateArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceCalendars.
     * @param {ConferenceCalendarsCreateManyArgs} args - Arguments to create many ConferenceCalendars.
     * @example
     * // Create many ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceCalendarsCreateManyArgs>(args?: SelectSubset<T, ConferenceCalendarsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceCalendars and returns the data saved in the database.
     * @param {ConferenceCalendarsCreateManyAndReturnArgs} args - Arguments to create many ConferenceCalendars.
     * @example
     * // Create many ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceCalendars and only return the `id`
     * const conferenceCalendarsWithIdOnly = await prisma.conferenceCalendars.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceCalendarsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceCalendarsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceCalendars.
     * @param {ConferenceCalendarsDeleteArgs} args - Arguments to delete one ConferenceCalendars.
     * @example
     * // Delete one ConferenceCalendars
     * const ConferenceCalendars = await prisma.conferenceCalendars.delete({
     *   where: {
     *     // ... filter to delete one ConferenceCalendars
     *   }
     * })
     * 
     */
    delete<T extends ConferenceCalendarsDeleteArgs>(args: SelectSubset<T, ConferenceCalendarsDeleteArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceCalendars.
     * @param {ConferenceCalendarsUpdateArgs} args - Arguments to update one ConferenceCalendars.
     * @example
     * // Update one ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceCalendarsUpdateArgs>(args: SelectSubset<T, ConferenceCalendarsUpdateArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceCalendars.
     * @param {ConferenceCalendarsDeleteManyArgs} args - Arguments to filter ConferenceCalendars to delete.
     * @example
     * // Delete a few ConferenceCalendars
     * const { count } = await prisma.conferenceCalendars.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceCalendarsDeleteManyArgs>(args?: SelectSubset<T, ConferenceCalendarsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceCalendarsUpdateManyArgs>(args: SelectSubset<T, ConferenceCalendarsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceCalendars and returns the data updated in the database.
     * @param {ConferenceCalendarsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceCalendars.
     * @example
     * // Update many ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceCalendars and only return the `id`
     * const conferenceCalendarsWithIdOnly = await prisma.conferenceCalendars.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceCalendarsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceCalendarsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceCalendars.
     * @param {ConferenceCalendarsUpsertArgs} args - Arguments to update or create a ConferenceCalendars.
     * @example
     * // Update or create a ConferenceCalendars
     * const conferenceCalendars = await prisma.conferenceCalendars.upsert({
     *   create: {
     *     // ... data to create a ConferenceCalendars
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceCalendars we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceCalendarsUpsertArgs>(args: SelectSubset<T, ConferenceCalendarsUpsertArgs<ExtArgs>>): Prisma__ConferenceCalendarsClient<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsCountArgs} args - Arguments to filter ConferenceCalendars to count.
     * @example
     * // Count the number of ConferenceCalendars
     * const count = await prisma.conferenceCalendars.count({
     *   where: {
     *     // ... the filter for the ConferenceCalendars we want to count
     *   }
     * })
    **/
    count<T extends ConferenceCalendarsCountArgs>(
      args?: Subset<T, ConferenceCalendarsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceCalendarsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceCalendarsAggregateArgs>(args: Subset<T, ConferenceCalendarsAggregateArgs>): Prisma.PrismaPromise<GetConferenceCalendarsAggregateType<T>>

    /**
     * Group by ConferenceCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCalendarsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceCalendarsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceCalendarsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceCalendarsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceCalendarsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceCalendarsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceCalendars model
   */
  readonly fields: ConferenceCalendarsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceCalendars.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceCalendarsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    byUser<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceCalendars model
   */ 
  interface ConferenceCalendarsFieldRefs {
    readonly id: FieldRef<"ConferenceCalendars", 'String'>
    readonly conferenceId: FieldRef<"ConferenceCalendars", 'String'>
    readonly userId: FieldRef<"ConferenceCalendars", 'String'>
    readonly createdAt: FieldRef<"ConferenceCalendars", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceCalendars", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceCalendars findUnique
   */
  export type ConferenceCalendarsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCalendars to fetch.
     */
    where: ConferenceCalendarsWhereUniqueInput
  }

  /**
   * ConferenceCalendars findUniqueOrThrow
   */
  export type ConferenceCalendarsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCalendars to fetch.
     */
    where: ConferenceCalendarsWhereUniqueInput
  }

  /**
   * ConferenceCalendars findFirst
   */
  export type ConferenceCalendarsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCalendars to fetch.
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCalendars to fetch.
     */
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceCalendars.
     */
    cursor?: ConferenceCalendarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceCalendars.
     */
    distinct?: ConferenceCalendarsScalarFieldEnum | ConferenceCalendarsScalarFieldEnum[]
  }

  /**
   * ConferenceCalendars findFirstOrThrow
   */
  export type ConferenceCalendarsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCalendars to fetch.
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCalendars to fetch.
     */
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceCalendars.
     */
    cursor?: ConferenceCalendarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceCalendars.
     */
    distinct?: ConferenceCalendarsScalarFieldEnum | ConferenceCalendarsScalarFieldEnum[]
  }

  /**
   * ConferenceCalendars findMany
   */
  export type ConferenceCalendarsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCalendars to fetch.
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCalendars to fetch.
     */
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceCalendars.
     */
    cursor?: ConferenceCalendarsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCalendars.
     */
    skip?: number
    distinct?: ConferenceCalendarsScalarFieldEnum | ConferenceCalendarsScalarFieldEnum[]
  }

  /**
   * ConferenceCalendars create
   */
  export type ConferenceCalendarsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceCalendars.
     */
    data: XOR<ConferenceCalendarsCreateInput, ConferenceCalendarsUncheckedCreateInput>
  }

  /**
   * ConferenceCalendars createMany
   */
  export type ConferenceCalendarsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceCalendars.
     */
    data: ConferenceCalendarsCreateManyInput | ConferenceCalendarsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceCalendars createManyAndReturn
   */
  export type ConferenceCalendarsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceCalendars.
     */
    data: ConferenceCalendarsCreateManyInput | ConferenceCalendarsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceCalendars update
   */
  export type ConferenceCalendarsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceCalendars.
     */
    data: XOR<ConferenceCalendarsUpdateInput, ConferenceCalendarsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceCalendars to update.
     */
    where: ConferenceCalendarsWhereUniqueInput
  }

  /**
   * ConferenceCalendars updateMany
   */
  export type ConferenceCalendarsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceCalendars.
     */
    data: XOR<ConferenceCalendarsUpdateManyMutationInput, ConferenceCalendarsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceCalendars to update
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * Limit how many ConferenceCalendars to update.
     */
    limit?: number
  }

  /**
   * ConferenceCalendars updateManyAndReturn
   */
  export type ConferenceCalendarsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceCalendars.
     */
    data: XOR<ConferenceCalendarsUpdateManyMutationInput, ConferenceCalendarsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceCalendars to update
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * Limit how many ConferenceCalendars to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceCalendars upsert
   */
  export type ConferenceCalendarsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceCalendars to update in case it exists.
     */
    where: ConferenceCalendarsWhereUniqueInput
    /**
     * In case the ConferenceCalendars found by the `where` argument doesn't exist, create a new ConferenceCalendars with this data.
     */
    create: XOR<ConferenceCalendarsCreateInput, ConferenceCalendarsUncheckedCreateInput>
    /**
     * In case the ConferenceCalendars was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceCalendarsUpdateInput, ConferenceCalendarsUncheckedUpdateInput>
  }

  /**
   * ConferenceCalendars delete
   */
  export type ConferenceCalendarsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceCalendars to delete.
     */
    where: ConferenceCalendarsWhereUniqueInput
  }

  /**
   * ConferenceCalendars deleteMany
   */
  export type ConferenceCalendarsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceCalendars to delete
     */
    where?: ConferenceCalendarsWhereInput
    /**
     * Limit how many ConferenceCalendars to delete.
     */
    limit?: number
  }

  /**
   * ConferenceCalendars without action
   */
  export type ConferenceCalendarsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
  }


  /**
   * Model JournalLikes
   */

  export type AggregateJournalLikes = {
    _count: JournalLikesCountAggregateOutputType | null
    _min: JournalLikesMinAggregateOutputType | null
    _max: JournalLikesMaxAggregateOutputType | null
  }

  export type JournalLikesMinAggregateOutputType = {
    id: string | null
    journalId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalLikesMaxAggregateOutputType = {
    id: string | null
    journalId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalLikesCountAggregateOutputType = {
    id: number
    journalId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalLikesMinAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalLikesMaxAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalLikesCountAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalLikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLikes to aggregate.
     */
    where?: JournalLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLikes to fetch.
     */
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalLikes
    **/
    _count?: true | JournalLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalLikesMaxAggregateInputType
  }

  export type GetJournalLikesAggregateType<T extends JournalLikesAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalLikes[P]>
      : GetScalarType<T[P], AggregateJournalLikes[P]>
  }




  export type JournalLikesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLikesWhereInput
    orderBy?: JournalLikesOrderByWithAggregationInput | JournalLikesOrderByWithAggregationInput[]
    by: JournalLikesScalarFieldEnum[] | JournalLikesScalarFieldEnum
    having?: JournalLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalLikesCountAggregateInputType | true
    _min?: JournalLikesMinAggregateInputType
    _max?: JournalLikesMaxAggregateInputType
  }

  export type JournalLikesGroupByOutputType = {
    id: string
    journalId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: JournalLikesCountAggregateOutputType | null
    _min: JournalLikesMinAggregateOutputType | null
    _max: JournalLikesMaxAggregateOutputType | null
  }

  type GetJournalLikesGroupByPayload<T extends JournalLikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalLikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalLikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalLikesGroupByOutputType[P]>
            : GetScalarType<T[P], JournalLikesGroupByOutputType[P]>
        }
      >
    >


  export type JournalLikesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLikes"]>

  export type JournalLikesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLikes"]>

  export type JournalLikesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLikes"]>

  export type JournalLikesSelectScalar = {
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalLikesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["journalLikes"]>
  export type JournalLikesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type JournalLikesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type JournalLikesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $JournalLikesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalLikes"
    objects: {
      belongsTo: Prisma.$JournalsPayload<ExtArgs>
      byUser: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalLikes"]>
    composites: {}
  }

  type JournalLikesGetPayload<S extends boolean | null | undefined | JournalLikesDefaultArgs> = $Result.GetResult<Prisma.$JournalLikesPayload, S>

  type JournalLikesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalLikesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalLikesCountAggregateInputType | true
    }

  export interface JournalLikesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalLikes'], meta: { name: 'JournalLikes' } }
    /**
     * Find zero or one JournalLikes that matches the filter.
     * @param {JournalLikesFindUniqueArgs} args - Arguments to find a JournalLikes
     * @example
     * // Get one JournalLikes
     * const journalLikes = await prisma.journalLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalLikesFindUniqueArgs>(args: SelectSubset<T, JournalLikesFindUniqueArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalLikes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalLikesFindUniqueOrThrowArgs} args - Arguments to find a JournalLikes
     * @example
     * // Get one JournalLikes
     * const journalLikes = await prisma.journalLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalLikesFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalLikesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesFindFirstArgs} args - Arguments to find a JournalLikes
     * @example
     * // Get one JournalLikes
     * const journalLikes = await prisma.journalLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalLikesFindFirstArgs>(args?: SelectSubset<T, JournalLikesFindFirstArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalLikes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesFindFirstOrThrowArgs} args - Arguments to find a JournalLikes
     * @example
     * // Get one JournalLikes
     * const journalLikes = await prisma.journalLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalLikesFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalLikesFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalLikes
     * const journalLikes = await prisma.journalLikes.findMany()
     * 
     * // Get first 10 JournalLikes
     * const journalLikes = await prisma.journalLikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalLikesWithIdOnly = await prisma.journalLikes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalLikesFindManyArgs>(args?: SelectSubset<T, JournalLikesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalLikes.
     * @param {JournalLikesCreateArgs} args - Arguments to create a JournalLikes.
     * @example
     * // Create one JournalLikes
     * const JournalLikes = await prisma.journalLikes.create({
     *   data: {
     *     // ... data to create a JournalLikes
     *   }
     * })
     * 
     */
    create<T extends JournalLikesCreateArgs>(args: SelectSubset<T, JournalLikesCreateArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalLikes.
     * @param {JournalLikesCreateManyArgs} args - Arguments to create many JournalLikes.
     * @example
     * // Create many JournalLikes
     * const journalLikes = await prisma.journalLikes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalLikesCreateManyArgs>(args?: SelectSubset<T, JournalLikesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalLikes and returns the data saved in the database.
     * @param {JournalLikesCreateManyAndReturnArgs} args - Arguments to create many JournalLikes.
     * @example
     * // Create many JournalLikes
     * const journalLikes = await prisma.journalLikes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalLikes and only return the `id`
     * const journalLikesWithIdOnly = await prisma.journalLikes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalLikesCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalLikesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalLikes.
     * @param {JournalLikesDeleteArgs} args - Arguments to delete one JournalLikes.
     * @example
     * // Delete one JournalLikes
     * const JournalLikes = await prisma.journalLikes.delete({
     *   where: {
     *     // ... filter to delete one JournalLikes
     *   }
     * })
     * 
     */
    delete<T extends JournalLikesDeleteArgs>(args: SelectSubset<T, JournalLikesDeleteArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalLikes.
     * @param {JournalLikesUpdateArgs} args - Arguments to update one JournalLikes.
     * @example
     * // Update one JournalLikes
     * const journalLikes = await prisma.journalLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalLikesUpdateArgs>(args: SelectSubset<T, JournalLikesUpdateArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalLikes.
     * @param {JournalLikesDeleteManyArgs} args - Arguments to filter JournalLikes to delete.
     * @example
     * // Delete a few JournalLikes
     * const { count } = await prisma.journalLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalLikesDeleteManyArgs>(args?: SelectSubset<T, JournalLikesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalLikes
     * const journalLikes = await prisma.journalLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalLikesUpdateManyArgs>(args: SelectSubset<T, JournalLikesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLikes and returns the data updated in the database.
     * @param {JournalLikesUpdateManyAndReturnArgs} args - Arguments to update many JournalLikes.
     * @example
     * // Update many JournalLikes
     * const journalLikes = await prisma.journalLikes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalLikes and only return the `id`
     * const journalLikesWithIdOnly = await prisma.journalLikes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalLikesUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalLikesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalLikes.
     * @param {JournalLikesUpsertArgs} args - Arguments to update or create a JournalLikes.
     * @example
     * // Update or create a JournalLikes
     * const journalLikes = await prisma.journalLikes.upsert({
     *   create: {
     *     // ... data to create a JournalLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalLikes we want to update
     *   }
     * })
     */
    upsert<T extends JournalLikesUpsertArgs>(args: SelectSubset<T, JournalLikesUpsertArgs<ExtArgs>>): Prisma__JournalLikesClient<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesCountArgs} args - Arguments to filter JournalLikes to count.
     * @example
     * // Count the number of JournalLikes
     * const count = await prisma.journalLikes.count({
     *   where: {
     *     // ... the filter for the JournalLikes we want to count
     *   }
     * })
    **/
    count<T extends JournalLikesCountArgs>(
      args?: Subset<T, JournalLikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalLikesAggregateArgs>(args: Subset<T, JournalLikesAggregateArgs>): Prisma.PrismaPromise<GetJournalLikesAggregateType<T>>

    /**
     * Group by JournalLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalLikesGroupByArgs['orderBy'] }
        : { orderBy?: JournalLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalLikes model
   */
  readonly fields: JournalLikesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalLikesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends JournalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalsDefaultArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    byUser<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalLikes model
   */ 
  interface JournalLikesFieldRefs {
    readonly id: FieldRef<"JournalLikes", 'String'>
    readonly journalId: FieldRef<"JournalLikes", 'String'>
    readonly userId: FieldRef<"JournalLikes", 'String'>
    readonly createdAt: FieldRef<"JournalLikes", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalLikes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalLikes findUnique
   */
  export type JournalLikesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter, which JournalLikes to fetch.
     */
    where: JournalLikesWhereUniqueInput
  }

  /**
   * JournalLikes findUniqueOrThrow
   */
  export type JournalLikesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter, which JournalLikes to fetch.
     */
    where: JournalLikesWhereUniqueInput
  }

  /**
   * JournalLikes findFirst
   */
  export type JournalLikesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter, which JournalLikes to fetch.
     */
    where?: JournalLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLikes to fetch.
     */
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLikes.
     */
    cursor?: JournalLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLikes.
     */
    distinct?: JournalLikesScalarFieldEnum | JournalLikesScalarFieldEnum[]
  }

  /**
   * JournalLikes findFirstOrThrow
   */
  export type JournalLikesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter, which JournalLikes to fetch.
     */
    where?: JournalLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLikes to fetch.
     */
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLikes.
     */
    cursor?: JournalLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLikes.
     */
    distinct?: JournalLikesScalarFieldEnum | JournalLikesScalarFieldEnum[]
  }

  /**
   * JournalLikes findMany
   */
  export type JournalLikesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter, which JournalLikes to fetch.
     */
    where?: JournalLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLikes to fetch.
     */
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalLikes.
     */
    cursor?: JournalLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLikes.
     */
    skip?: number
    distinct?: JournalLikesScalarFieldEnum | JournalLikesScalarFieldEnum[]
  }

  /**
   * JournalLikes create
   */
  export type JournalLikesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalLikes.
     */
    data: XOR<JournalLikesCreateInput, JournalLikesUncheckedCreateInput>
  }

  /**
   * JournalLikes createMany
   */
  export type JournalLikesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalLikes.
     */
    data: JournalLikesCreateManyInput | JournalLikesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalLikes createManyAndReturn
   */
  export type JournalLikesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * The data used to create many JournalLikes.
     */
    data: JournalLikesCreateManyInput | JournalLikesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLikes update
   */
  export type JournalLikesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalLikes.
     */
    data: XOR<JournalLikesUpdateInput, JournalLikesUncheckedUpdateInput>
    /**
     * Choose, which JournalLikes to update.
     */
    where: JournalLikesWhereUniqueInput
  }

  /**
   * JournalLikes updateMany
   */
  export type JournalLikesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalLikes.
     */
    data: XOR<JournalLikesUpdateManyMutationInput, JournalLikesUncheckedUpdateManyInput>
    /**
     * Filter which JournalLikes to update
     */
    where?: JournalLikesWhereInput
    /**
     * Limit how many JournalLikes to update.
     */
    limit?: number
  }

  /**
   * JournalLikes updateManyAndReturn
   */
  export type JournalLikesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * The data used to update JournalLikes.
     */
    data: XOR<JournalLikesUpdateManyMutationInput, JournalLikesUncheckedUpdateManyInput>
    /**
     * Filter which JournalLikes to update
     */
    where?: JournalLikesWhereInput
    /**
     * Limit how many JournalLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLikes upsert
   */
  export type JournalLikesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalLikes to update in case it exists.
     */
    where: JournalLikesWhereUniqueInput
    /**
     * In case the JournalLikes found by the `where` argument doesn't exist, create a new JournalLikes with this data.
     */
    create: XOR<JournalLikesCreateInput, JournalLikesUncheckedCreateInput>
    /**
     * In case the JournalLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalLikesUpdateInput, JournalLikesUncheckedUpdateInput>
  }

  /**
   * JournalLikes delete
   */
  export type JournalLikesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    /**
     * Filter which JournalLikes to delete.
     */
    where: JournalLikesWhereUniqueInput
  }

  /**
   * JournalLikes deleteMany
   */
  export type JournalLikesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLikes to delete
     */
    where?: JournalLikesWhereInput
    /**
     * Limit how many JournalLikes to delete.
     */
    limit?: number
  }

  /**
   * JournalLikes without action
   */
  export type JournalLikesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
  }


  /**
   * Model JournalFollows
   */

  export type AggregateJournalFollows = {
    _count: JournalFollowsCountAggregateOutputType | null
    _min: JournalFollowsMinAggregateOutputType | null
    _max: JournalFollowsMaxAggregateOutputType | null
  }

  export type JournalFollowsMinAggregateOutputType = {
    id: string | null
    journalId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalFollowsMaxAggregateOutputType = {
    id: string | null
    journalId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalFollowsCountAggregateOutputType = {
    id: number
    journalId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalFollowsMinAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalFollowsMaxAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalFollowsCountAggregateInputType = {
    id?: true
    journalId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalFollowsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalFollows to aggregate.
     */
    where?: JournalFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFollows to fetch.
     */
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalFollows
    **/
    _count?: true | JournalFollowsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalFollowsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalFollowsMaxAggregateInputType
  }

  export type GetJournalFollowsAggregateType<T extends JournalFollowsAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalFollows]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalFollows[P]>
      : GetScalarType<T[P], AggregateJournalFollows[P]>
  }




  export type JournalFollowsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalFollowsWhereInput
    orderBy?: JournalFollowsOrderByWithAggregationInput | JournalFollowsOrderByWithAggregationInput[]
    by: JournalFollowsScalarFieldEnum[] | JournalFollowsScalarFieldEnum
    having?: JournalFollowsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalFollowsCountAggregateInputType | true
    _min?: JournalFollowsMinAggregateInputType
    _max?: JournalFollowsMaxAggregateInputType
  }

  export type JournalFollowsGroupByOutputType = {
    id: string
    journalId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: JournalFollowsCountAggregateOutputType | null
    _min: JournalFollowsMinAggregateOutputType | null
    _max: JournalFollowsMaxAggregateOutputType | null
  }

  type GetJournalFollowsGroupByPayload<T extends JournalFollowsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalFollowsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalFollowsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalFollowsGroupByOutputType[P]>
            : GetScalarType<T[P], JournalFollowsGroupByOutputType[P]>
        }
      >
    >


  export type JournalFollowsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalFollows"]>

  export type JournalFollowsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalFollows"]>

  export type JournalFollowsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalFollows"]>

  export type JournalFollowsSelectScalar = {
    id?: boolean
    journalId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalFollowsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["journalFollows"]>
  export type JournalFollowsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type JournalFollowsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type JournalFollowsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
    byUser?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $JournalFollowsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalFollows"
    objects: {
      belongsTo: Prisma.$JournalsPayload<ExtArgs>
      byUser: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalFollows"]>
    composites: {}
  }

  type JournalFollowsGetPayload<S extends boolean | null | undefined | JournalFollowsDefaultArgs> = $Result.GetResult<Prisma.$JournalFollowsPayload, S>

  type JournalFollowsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalFollowsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalFollowsCountAggregateInputType | true
    }

  export interface JournalFollowsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalFollows'], meta: { name: 'JournalFollows' } }
    /**
     * Find zero or one JournalFollows that matches the filter.
     * @param {JournalFollowsFindUniqueArgs} args - Arguments to find a JournalFollows
     * @example
     * // Get one JournalFollows
     * const journalFollows = await prisma.journalFollows.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalFollowsFindUniqueArgs>(args: SelectSubset<T, JournalFollowsFindUniqueArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalFollows that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalFollowsFindUniqueOrThrowArgs} args - Arguments to find a JournalFollows
     * @example
     * // Get one JournalFollows
     * const journalFollows = await prisma.journalFollows.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalFollowsFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalFollowsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsFindFirstArgs} args - Arguments to find a JournalFollows
     * @example
     * // Get one JournalFollows
     * const journalFollows = await prisma.journalFollows.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalFollowsFindFirstArgs>(args?: SelectSubset<T, JournalFollowsFindFirstArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalFollows that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsFindFirstOrThrowArgs} args - Arguments to find a JournalFollows
     * @example
     * // Get one JournalFollows
     * const journalFollows = await prisma.journalFollows.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalFollowsFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalFollowsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalFollows
     * const journalFollows = await prisma.journalFollows.findMany()
     * 
     * // Get first 10 JournalFollows
     * const journalFollows = await prisma.journalFollows.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalFollowsWithIdOnly = await prisma.journalFollows.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalFollowsFindManyArgs>(args?: SelectSubset<T, JournalFollowsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalFollows.
     * @param {JournalFollowsCreateArgs} args - Arguments to create a JournalFollows.
     * @example
     * // Create one JournalFollows
     * const JournalFollows = await prisma.journalFollows.create({
     *   data: {
     *     // ... data to create a JournalFollows
     *   }
     * })
     * 
     */
    create<T extends JournalFollowsCreateArgs>(args: SelectSubset<T, JournalFollowsCreateArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalFollows.
     * @param {JournalFollowsCreateManyArgs} args - Arguments to create many JournalFollows.
     * @example
     * // Create many JournalFollows
     * const journalFollows = await prisma.journalFollows.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalFollowsCreateManyArgs>(args?: SelectSubset<T, JournalFollowsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalFollows and returns the data saved in the database.
     * @param {JournalFollowsCreateManyAndReturnArgs} args - Arguments to create many JournalFollows.
     * @example
     * // Create many JournalFollows
     * const journalFollows = await prisma.journalFollows.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalFollows and only return the `id`
     * const journalFollowsWithIdOnly = await prisma.journalFollows.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalFollowsCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalFollowsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalFollows.
     * @param {JournalFollowsDeleteArgs} args - Arguments to delete one JournalFollows.
     * @example
     * // Delete one JournalFollows
     * const JournalFollows = await prisma.journalFollows.delete({
     *   where: {
     *     // ... filter to delete one JournalFollows
     *   }
     * })
     * 
     */
    delete<T extends JournalFollowsDeleteArgs>(args: SelectSubset<T, JournalFollowsDeleteArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalFollows.
     * @param {JournalFollowsUpdateArgs} args - Arguments to update one JournalFollows.
     * @example
     * // Update one JournalFollows
     * const journalFollows = await prisma.journalFollows.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalFollowsUpdateArgs>(args: SelectSubset<T, JournalFollowsUpdateArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalFollows.
     * @param {JournalFollowsDeleteManyArgs} args - Arguments to filter JournalFollows to delete.
     * @example
     * // Delete a few JournalFollows
     * const { count } = await prisma.journalFollows.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalFollowsDeleteManyArgs>(args?: SelectSubset<T, JournalFollowsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalFollows
     * const journalFollows = await prisma.journalFollows.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalFollowsUpdateManyArgs>(args: SelectSubset<T, JournalFollowsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalFollows and returns the data updated in the database.
     * @param {JournalFollowsUpdateManyAndReturnArgs} args - Arguments to update many JournalFollows.
     * @example
     * // Update many JournalFollows
     * const journalFollows = await prisma.journalFollows.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalFollows and only return the `id`
     * const journalFollowsWithIdOnly = await prisma.journalFollows.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalFollowsUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalFollowsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalFollows.
     * @param {JournalFollowsUpsertArgs} args - Arguments to update or create a JournalFollows.
     * @example
     * // Update or create a JournalFollows
     * const journalFollows = await prisma.journalFollows.upsert({
     *   create: {
     *     // ... data to create a JournalFollows
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalFollows we want to update
     *   }
     * })
     */
    upsert<T extends JournalFollowsUpsertArgs>(args: SelectSubset<T, JournalFollowsUpsertArgs<ExtArgs>>): Prisma__JournalFollowsClient<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsCountArgs} args - Arguments to filter JournalFollows to count.
     * @example
     * // Count the number of JournalFollows
     * const count = await prisma.journalFollows.count({
     *   where: {
     *     // ... the filter for the JournalFollows we want to count
     *   }
     * })
    **/
    count<T extends JournalFollowsCountArgs>(
      args?: Subset<T, JournalFollowsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalFollowsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalFollowsAggregateArgs>(args: Subset<T, JournalFollowsAggregateArgs>): Prisma.PrismaPromise<GetJournalFollowsAggregateType<T>>

    /**
     * Group by JournalFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFollowsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalFollowsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalFollowsGroupByArgs['orderBy'] }
        : { orderBy?: JournalFollowsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalFollowsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalFollowsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalFollows model
   */
  readonly fields: JournalFollowsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalFollows.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalFollowsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends JournalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalsDefaultArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    byUser<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalFollows model
   */ 
  interface JournalFollowsFieldRefs {
    readonly id: FieldRef<"JournalFollows", 'String'>
    readonly journalId: FieldRef<"JournalFollows", 'String'>
    readonly userId: FieldRef<"JournalFollows", 'String'>
    readonly createdAt: FieldRef<"JournalFollows", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalFollows", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalFollows findUnique
   */
  export type JournalFollowsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter, which JournalFollows to fetch.
     */
    where: JournalFollowsWhereUniqueInput
  }

  /**
   * JournalFollows findUniqueOrThrow
   */
  export type JournalFollowsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter, which JournalFollows to fetch.
     */
    where: JournalFollowsWhereUniqueInput
  }

  /**
   * JournalFollows findFirst
   */
  export type JournalFollowsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter, which JournalFollows to fetch.
     */
    where?: JournalFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFollows to fetch.
     */
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalFollows.
     */
    cursor?: JournalFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalFollows.
     */
    distinct?: JournalFollowsScalarFieldEnum | JournalFollowsScalarFieldEnum[]
  }

  /**
   * JournalFollows findFirstOrThrow
   */
  export type JournalFollowsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter, which JournalFollows to fetch.
     */
    where?: JournalFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFollows to fetch.
     */
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalFollows.
     */
    cursor?: JournalFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalFollows.
     */
    distinct?: JournalFollowsScalarFieldEnum | JournalFollowsScalarFieldEnum[]
  }

  /**
   * JournalFollows findMany
   */
  export type JournalFollowsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter, which JournalFollows to fetch.
     */
    where?: JournalFollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalFollows to fetch.
     */
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalFollows.
     */
    cursor?: JournalFollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalFollows.
     */
    skip?: number
    distinct?: JournalFollowsScalarFieldEnum | JournalFollowsScalarFieldEnum[]
  }

  /**
   * JournalFollows create
   */
  export type JournalFollowsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalFollows.
     */
    data: XOR<JournalFollowsCreateInput, JournalFollowsUncheckedCreateInput>
  }

  /**
   * JournalFollows createMany
   */
  export type JournalFollowsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalFollows.
     */
    data: JournalFollowsCreateManyInput | JournalFollowsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalFollows createManyAndReturn
   */
  export type JournalFollowsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * The data used to create many JournalFollows.
     */
    data: JournalFollowsCreateManyInput | JournalFollowsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalFollows update
   */
  export type JournalFollowsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalFollows.
     */
    data: XOR<JournalFollowsUpdateInput, JournalFollowsUncheckedUpdateInput>
    /**
     * Choose, which JournalFollows to update.
     */
    where: JournalFollowsWhereUniqueInput
  }

  /**
   * JournalFollows updateMany
   */
  export type JournalFollowsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalFollows.
     */
    data: XOR<JournalFollowsUpdateManyMutationInput, JournalFollowsUncheckedUpdateManyInput>
    /**
     * Filter which JournalFollows to update
     */
    where?: JournalFollowsWhereInput
    /**
     * Limit how many JournalFollows to update.
     */
    limit?: number
  }

  /**
   * JournalFollows updateManyAndReturn
   */
  export type JournalFollowsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * The data used to update JournalFollows.
     */
    data: XOR<JournalFollowsUpdateManyMutationInput, JournalFollowsUncheckedUpdateManyInput>
    /**
     * Filter which JournalFollows to update
     */
    where?: JournalFollowsWhereInput
    /**
     * Limit how many JournalFollows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalFollows upsert
   */
  export type JournalFollowsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalFollows to update in case it exists.
     */
    where: JournalFollowsWhereUniqueInput
    /**
     * In case the JournalFollows found by the `where` argument doesn't exist, create a new JournalFollows with this data.
     */
    create: XOR<JournalFollowsCreateInput, JournalFollowsUncheckedCreateInput>
    /**
     * In case the JournalFollows was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalFollowsUpdateInput, JournalFollowsUncheckedUpdateInput>
  }

  /**
   * JournalFollows delete
   */
  export type JournalFollowsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    /**
     * Filter which JournalFollows to delete.
     */
    where: JournalFollowsWhereUniqueInput
  }

  /**
   * JournalFollows deleteMany
   */
  export type JournalFollowsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalFollows to delete
     */
    where?: JournalFollowsWhereInput
    /**
     * Limit how many JournalFollows to delete.
     */
    limit?: number
  }

  /**
   * JournalFollows without action
   */
  export type JournalFollowsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    dob: Date | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    dob: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    dob?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    dob?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    dob?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    followConference?: boolean | Users$followConferenceArgs<ExtArgs>
    likes?: boolean | Users$likesArgs<ExtArgs>
    calendar?: boolean | Users$calendarArgs<ExtArgs>
    createdConferences?: boolean | Users$createdConferencesArgs<ExtArgs>
    createdJournals?: boolean | Users$createdJournalsArgs<ExtArgs>
    journalLikes?: boolean | Users$journalLikesArgs<ExtArgs>
    journalFollows?: boolean | Users$journalFollowsArgs<ExtArgs>
    feedbacks?: boolean | Users$feedbacksArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    dob?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "firstName" | "lastName" | "dob" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followConference?: boolean | Users$followConferenceArgs<ExtArgs>
    likes?: boolean | Users$likesArgs<ExtArgs>
    calendar?: boolean | Users$calendarArgs<ExtArgs>
    createdConferences?: boolean | Users$createdConferencesArgs<ExtArgs>
    createdJournals?: boolean | Users$createdJournalsArgs<ExtArgs>
    journalLikes?: boolean | Users$journalLikesArgs<ExtArgs>
    journalFollows?: boolean | Users$journalFollowsArgs<ExtArgs>
    feedbacks?: boolean | Users$feedbacksArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      followConference: Prisma.$ConferenceFollowsPayload<ExtArgs>[]
      likes: Prisma.$ConferenceLikesPayload<ExtArgs>[]
      calendar: Prisma.$ConferenceCalendarsPayload<ExtArgs>[]
      createdConferences: Prisma.$ConferencesPayload<ExtArgs>[]
      createdJournals: Prisma.$JournalsPayload<ExtArgs>[]
      journalLikes: Prisma.$JournalLikesPayload<ExtArgs>[]
      journalFollows: Prisma.$JournalFollowsPayload<ExtArgs>[]
      feedbacks: Prisma.$ConferenceFeedbacksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string
      lastName: string
      dob: Date
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    followConference<T extends Users$followConferenceArgs<ExtArgs> = {}>(args?: Subset<T, Users$followConferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Users$likesArgs<ExtArgs> = {}>(args?: Subset<T, Users$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calendar<T extends Users$calendarArgs<ExtArgs> = {}>(args?: Subset<T, Users$calendarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCalendarsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdConferences<T extends Users$createdConferencesArgs<ExtArgs> = {}>(args?: Subset<T, Users$createdConferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdJournals<T extends Users$createdJournalsArgs<ExtArgs> = {}>(args?: Subset<T, Users$createdJournalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalLikes<T extends Users$journalLikesArgs<ExtArgs> = {}>(args?: Subset<T, Users$journalLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLikesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalFollows<T extends Users$journalFollowsArgs<ExtArgs> = {}>(args?: Subset<T, Users$journalFollowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalFollowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends Users$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Users$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceFeedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly firstName: FieldRef<"Users", 'String'>
    readonly lastName: FieldRef<"Users", 'String'>
    readonly dob: FieldRef<"Users", 'DateTime'>
    readonly role: FieldRef<"Users", 'String'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.followConference
   */
  export type Users$followConferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFollows
     */
    select?: ConferenceFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFollows
     */
    omit?: ConferenceFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFollowsInclude<ExtArgs> | null
    where?: ConferenceFollowsWhereInput
    orderBy?: ConferenceFollowsOrderByWithRelationInput | ConferenceFollowsOrderByWithRelationInput[]
    cursor?: ConferenceFollowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceFollowsScalarFieldEnum | ConferenceFollowsScalarFieldEnum[]
  }

  /**
   * Users.likes
   */
  export type Users$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceLikes
     */
    select?: ConferenceLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceLikes
     */
    omit?: ConferenceLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceLikesInclude<ExtArgs> | null
    where?: ConferenceLikesWhereInput
    orderBy?: ConferenceLikesOrderByWithRelationInput | ConferenceLikesOrderByWithRelationInput[]
    cursor?: ConferenceLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceLikesScalarFieldEnum | ConferenceLikesScalarFieldEnum[]
  }

  /**
   * Users.calendar
   */
  export type Users$calendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCalendars
     */
    select?: ConferenceCalendarsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCalendars
     */
    omit?: ConferenceCalendarsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCalendarsInclude<ExtArgs> | null
    where?: ConferenceCalendarsWhereInput
    orderBy?: ConferenceCalendarsOrderByWithRelationInput | ConferenceCalendarsOrderByWithRelationInput[]
    cursor?: ConferenceCalendarsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceCalendarsScalarFieldEnum | ConferenceCalendarsScalarFieldEnum[]
  }

  /**
   * Users.createdConferences
   */
  export type Users$createdConferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conferences
     */
    select?: ConferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conferences
     */
    omit?: ConferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferencesInclude<ExtArgs> | null
    where?: ConferencesWhereInput
    orderBy?: ConferencesOrderByWithRelationInput | ConferencesOrderByWithRelationInput[]
    cursor?: ConferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferencesScalarFieldEnum | ConferencesScalarFieldEnum[]
  }

  /**
   * Users.createdJournals
   */
  export type Users$createdJournalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journals
     */
    select?: JournalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journals
     */
    omit?: JournalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalsInclude<ExtArgs> | null
    where?: JournalsWhereInput
    orderBy?: JournalsOrderByWithRelationInput | JournalsOrderByWithRelationInput[]
    cursor?: JournalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalsScalarFieldEnum | JournalsScalarFieldEnum[]
  }

  /**
   * Users.journalLikes
   */
  export type Users$journalLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLikes
     */
    select?: JournalLikesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLikes
     */
    omit?: JournalLikesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLikesInclude<ExtArgs> | null
    where?: JournalLikesWhereInput
    orderBy?: JournalLikesOrderByWithRelationInput | JournalLikesOrderByWithRelationInput[]
    cursor?: JournalLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLikesScalarFieldEnum | JournalLikesScalarFieldEnum[]
  }

  /**
   * Users.journalFollows
   */
  export type Users$journalFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalFollows
     */
    select?: JournalFollowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalFollows
     */
    omit?: JournalFollowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalFollowsInclude<ExtArgs> | null
    where?: JournalFollowsWhereInput
    orderBy?: JournalFollowsOrderByWithRelationInput | JournalFollowsOrderByWithRelationInput[]
    cursor?: JournalFollowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalFollowsScalarFieldEnum | JournalFollowsScalarFieldEnum[]
  }

  /**
   * Users.feedbacks
   */
  export type Users$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceFeedbacks
     */
    select?: ConferenceFeedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceFeedbacks
     */
    omit?: ConferenceFeedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceFeedbacksInclude<ExtArgs> | null
    where?: ConferenceFeedbacksWhereInput
    orderBy?: ConferenceFeedbacksOrderByWithRelationInput | ConferenceFeedbacksOrderByWithRelationInput[]
    cursor?: ConferenceFeedbacksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConferenceFeedbacksScalarFieldEnum | ConferenceFeedbacksScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model ConferenceCrawlJobs
   */

  export type AggregateConferenceCrawlJobs = {
    _count: ConferenceCrawlJobsCountAggregateOutputType | null
    _avg: ConferenceCrawlJobsAvgAggregateOutputType | null
    _sum: ConferenceCrawlJobsSumAggregateOutputType | null
    _min: ConferenceCrawlJobsMinAggregateOutputType | null
    _max: ConferenceCrawlJobsMaxAggregateOutputType | null
  }

  export type ConferenceCrawlJobsAvgAggregateOutputType = {
    progress: number | null
  }

  export type ConferenceCrawlJobsSumAggregateOutputType = {
    progress: number | null
  }

  export type ConferenceCrawlJobsMinAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    status: string | null
    progress: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceCrawlJobsMaxAggregateOutputType = {
    id: string | null
    conferenceId: string | null
    status: string | null
    progress: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConferenceCrawlJobsCountAggregateOutputType = {
    id: number
    conferenceId: number
    status: number
    progress: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConferenceCrawlJobsAvgAggregateInputType = {
    progress?: true
  }

  export type ConferenceCrawlJobsSumAggregateInputType = {
    progress?: true
  }

  export type ConferenceCrawlJobsMinAggregateInputType = {
    id?: true
    conferenceId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceCrawlJobsMaxAggregateInputType = {
    id?: true
    conferenceId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConferenceCrawlJobsCountAggregateInputType = {
    id?: true
    conferenceId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConferenceCrawlJobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceCrawlJobs to aggregate.
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCrawlJobs to fetch.
     */
    orderBy?: ConferenceCrawlJobsOrderByWithRelationInput | ConferenceCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConferenceCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConferenceCrawlJobs
    **/
    _count?: true | ConferenceCrawlJobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConferenceCrawlJobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConferenceCrawlJobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConferenceCrawlJobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConferenceCrawlJobsMaxAggregateInputType
  }

  export type GetConferenceCrawlJobsAggregateType<T extends ConferenceCrawlJobsAggregateArgs> = {
        [P in keyof T & keyof AggregateConferenceCrawlJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConferenceCrawlJobs[P]>
      : GetScalarType<T[P], AggregateConferenceCrawlJobs[P]>
  }




  export type ConferenceCrawlJobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConferenceCrawlJobsWhereInput
    orderBy?: ConferenceCrawlJobsOrderByWithAggregationInput | ConferenceCrawlJobsOrderByWithAggregationInput[]
    by: ConferenceCrawlJobsScalarFieldEnum[] | ConferenceCrawlJobsScalarFieldEnum
    having?: ConferenceCrawlJobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConferenceCrawlJobsCountAggregateInputType | true
    _avg?: ConferenceCrawlJobsAvgAggregateInputType
    _sum?: ConferenceCrawlJobsSumAggregateInputType
    _min?: ConferenceCrawlJobsMinAggregateInputType
    _max?: ConferenceCrawlJobsMaxAggregateInputType
  }

  export type ConferenceCrawlJobsGroupByOutputType = {
    id: string
    conferenceId: string
    status: string
    progress: number
    message: string
    createdAt: Date
    updatedAt: Date
    _count: ConferenceCrawlJobsCountAggregateOutputType | null
    _avg: ConferenceCrawlJobsAvgAggregateOutputType | null
    _sum: ConferenceCrawlJobsSumAggregateOutputType | null
    _min: ConferenceCrawlJobsMinAggregateOutputType | null
    _max: ConferenceCrawlJobsMaxAggregateOutputType | null
  }

  type GetConferenceCrawlJobsGroupByPayload<T extends ConferenceCrawlJobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConferenceCrawlJobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConferenceCrawlJobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConferenceCrawlJobsGroupByOutputType[P]>
            : GetScalarType<T[P], ConferenceCrawlJobsGroupByOutputType[P]>
        }
      >
    >


  export type ConferenceCrawlJobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCrawlJobs"]>

  export type ConferenceCrawlJobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCrawlJobs"]>

  export type ConferenceCrawlJobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conferenceId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conferenceCrawlJobs"]>

  export type ConferenceCrawlJobsSelectScalar = {
    id?: boolean
    conferenceId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConferenceCrawlJobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conferenceId" | "status" | "progress" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["conferenceCrawlJobs"]>
  export type ConferenceCrawlJobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }
  export type ConferenceCrawlJobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }
  export type ConferenceCrawlJobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | ConferencesDefaultArgs<ExtArgs>
  }

  export type $ConferenceCrawlJobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConferenceCrawlJobs"
    objects: {
      belongsTo: Prisma.$ConferencesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conferenceId: string
      status: string
      progress: number
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conferenceCrawlJobs"]>
    composites: {}
  }

  type ConferenceCrawlJobsGetPayload<S extends boolean | null | undefined | ConferenceCrawlJobsDefaultArgs> = $Result.GetResult<Prisma.$ConferenceCrawlJobsPayload, S>

  type ConferenceCrawlJobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConferenceCrawlJobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConferenceCrawlJobsCountAggregateInputType | true
    }

  export interface ConferenceCrawlJobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConferenceCrawlJobs'], meta: { name: 'ConferenceCrawlJobs' } }
    /**
     * Find zero or one ConferenceCrawlJobs that matches the filter.
     * @param {ConferenceCrawlJobsFindUniqueArgs} args - Arguments to find a ConferenceCrawlJobs
     * @example
     * // Get one ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConferenceCrawlJobsFindUniqueArgs>(args: SelectSubset<T, ConferenceCrawlJobsFindUniqueArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConferenceCrawlJobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConferenceCrawlJobsFindUniqueOrThrowArgs} args - Arguments to find a ConferenceCrawlJobs
     * @example
     * // Get one ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConferenceCrawlJobsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConferenceCrawlJobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceCrawlJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsFindFirstArgs} args - Arguments to find a ConferenceCrawlJobs
     * @example
     * // Get one ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConferenceCrawlJobsFindFirstArgs>(args?: SelectSubset<T, ConferenceCrawlJobsFindFirstArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConferenceCrawlJobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsFindFirstOrThrowArgs} args - Arguments to find a ConferenceCrawlJobs
     * @example
     * // Get one ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConferenceCrawlJobsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConferenceCrawlJobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConferenceCrawlJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findMany()
     * 
     * // Get first 10 ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conferenceCrawlJobsWithIdOnly = await prisma.conferenceCrawlJobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConferenceCrawlJobsFindManyArgs>(args?: SelectSubset<T, ConferenceCrawlJobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsCreateArgs} args - Arguments to create a ConferenceCrawlJobs.
     * @example
     * // Create one ConferenceCrawlJobs
     * const ConferenceCrawlJobs = await prisma.conferenceCrawlJobs.create({
     *   data: {
     *     // ... data to create a ConferenceCrawlJobs
     *   }
     * })
     * 
     */
    create<T extends ConferenceCrawlJobsCreateArgs>(args: SelectSubset<T, ConferenceCrawlJobsCreateArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsCreateManyArgs} args - Arguments to create many ConferenceCrawlJobs.
     * @example
     * // Create many ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConferenceCrawlJobsCreateManyArgs>(args?: SelectSubset<T, ConferenceCrawlJobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConferenceCrawlJobs and returns the data saved in the database.
     * @param {ConferenceCrawlJobsCreateManyAndReturnArgs} args - Arguments to create many ConferenceCrawlJobs.
     * @example
     * // Create many ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConferenceCrawlJobs and only return the `id`
     * const conferenceCrawlJobsWithIdOnly = await prisma.conferenceCrawlJobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConferenceCrawlJobsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConferenceCrawlJobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsDeleteArgs} args - Arguments to delete one ConferenceCrawlJobs.
     * @example
     * // Delete one ConferenceCrawlJobs
     * const ConferenceCrawlJobs = await prisma.conferenceCrawlJobs.delete({
     *   where: {
     *     // ... filter to delete one ConferenceCrawlJobs
     *   }
     * })
     * 
     */
    delete<T extends ConferenceCrawlJobsDeleteArgs>(args: SelectSubset<T, ConferenceCrawlJobsDeleteArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsUpdateArgs} args - Arguments to update one ConferenceCrawlJobs.
     * @example
     * // Update one ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConferenceCrawlJobsUpdateArgs>(args: SelectSubset<T, ConferenceCrawlJobsUpdateArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsDeleteManyArgs} args - Arguments to filter ConferenceCrawlJobs to delete.
     * @example
     * // Delete a few ConferenceCrawlJobs
     * const { count } = await prisma.conferenceCrawlJobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConferenceCrawlJobsDeleteManyArgs>(args?: SelectSubset<T, ConferenceCrawlJobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConferenceCrawlJobsUpdateManyArgs>(args: SelectSubset<T, ConferenceCrawlJobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConferenceCrawlJobs and returns the data updated in the database.
     * @param {ConferenceCrawlJobsUpdateManyAndReturnArgs} args - Arguments to update many ConferenceCrawlJobs.
     * @example
     * // Update many ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConferenceCrawlJobs and only return the `id`
     * const conferenceCrawlJobsWithIdOnly = await prisma.conferenceCrawlJobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConferenceCrawlJobsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConferenceCrawlJobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConferenceCrawlJobs.
     * @param {ConferenceCrawlJobsUpsertArgs} args - Arguments to update or create a ConferenceCrawlJobs.
     * @example
     * // Update or create a ConferenceCrawlJobs
     * const conferenceCrawlJobs = await prisma.conferenceCrawlJobs.upsert({
     *   create: {
     *     // ... data to create a ConferenceCrawlJobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConferenceCrawlJobs we want to update
     *   }
     * })
     */
    upsert<T extends ConferenceCrawlJobsUpsertArgs>(args: SelectSubset<T, ConferenceCrawlJobsUpsertArgs<ExtArgs>>): Prisma__ConferenceCrawlJobsClient<$Result.GetResult<Prisma.$ConferenceCrawlJobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConferenceCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsCountArgs} args - Arguments to filter ConferenceCrawlJobs to count.
     * @example
     * // Count the number of ConferenceCrawlJobs
     * const count = await prisma.conferenceCrawlJobs.count({
     *   where: {
     *     // ... the filter for the ConferenceCrawlJobs we want to count
     *   }
     * })
    **/
    count<T extends ConferenceCrawlJobsCountArgs>(
      args?: Subset<T, ConferenceCrawlJobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConferenceCrawlJobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConferenceCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConferenceCrawlJobsAggregateArgs>(args: Subset<T, ConferenceCrawlJobsAggregateArgs>): Prisma.PrismaPromise<GetConferenceCrawlJobsAggregateType<T>>

    /**
     * Group by ConferenceCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConferenceCrawlJobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConferenceCrawlJobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConferenceCrawlJobsGroupByArgs['orderBy'] }
        : { orderBy?: ConferenceCrawlJobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConferenceCrawlJobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConferenceCrawlJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConferenceCrawlJobs model
   */
  readonly fields: ConferenceCrawlJobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConferenceCrawlJobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConferenceCrawlJobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends ConferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConferencesDefaultArgs<ExtArgs>>): Prisma__ConferencesClient<$Result.GetResult<Prisma.$ConferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConferenceCrawlJobs model
   */ 
  interface ConferenceCrawlJobsFieldRefs {
    readonly id: FieldRef<"ConferenceCrawlJobs", 'String'>
    readonly conferenceId: FieldRef<"ConferenceCrawlJobs", 'String'>
    readonly status: FieldRef<"ConferenceCrawlJobs", 'String'>
    readonly progress: FieldRef<"ConferenceCrawlJobs", 'Int'>
    readonly message: FieldRef<"ConferenceCrawlJobs", 'String'>
    readonly createdAt: FieldRef<"ConferenceCrawlJobs", 'DateTime'>
    readonly updatedAt: FieldRef<"ConferenceCrawlJobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConferenceCrawlJobs findUnique
   */
  export type ConferenceCrawlJobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCrawlJobs to fetch.
     */
    where: ConferenceCrawlJobsWhereUniqueInput
  }

  /**
   * ConferenceCrawlJobs findUniqueOrThrow
   */
  export type ConferenceCrawlJobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCrawlJobs to fetch.
     */
    where: ConferenceCrawlJobsWhereUniqueInput
  }

  /**
   * ConferenceCrawlJobs findFirst
   */
  export type ConferenceCrawlJobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCrawlJobs to fetch.
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCrawlJobs to fetch.
     */
    orderBy?: ConferenceCrawlJobsOrderByWithRelationInput | ConferenceCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceCrawlJobs.
     */
    cursor?: ConferenceCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceCrawlJobs.
     */
    distinct?: ConferenceCrawlJobsScalarFieldEnum | ConferenceCrawlJobsScalarFieldEnum[]
  }

  /**
   * ConferenceCrawlJobs findFirstOrThrow
   */
  export type ConferenceCrawlJobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCrawlJobs to fetch.
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCrawlJobs to fetch.
     */
    orderBy?: ConferenceCrawlJobsOrderByWithRelationInput | ConferenceCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConferenceCrawlJobs.
     */
    cursor?: ConferenceCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConferenceCrawlJobs.
     */
    distinct?: ConferenceCrawlJobsScalarFieldEnum | ConferenceCrawlJobsScalarFieldEnum[]
  }

  /**
   * ConferenceCrawlJobs findMany
   */
  export type ConferenceCrawlJobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which ConferenceCrawlJobs to fetch.
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConferenceCrawlJobs to fetch.
     */
    orderBy?: ConferenceCrawlJobsOrderByWithRelationInput | ConferenceCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConferenceCrawlJobs.
     */
    cursor?: ConferenceCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConferenceCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConferenceCrawlJobs.
     */
    skip?: number
    distinct?: ConferenceCrawlJobsScalarFieldEnum | ConferenceCrawlJobsScalarFieldEnum[]
  }

  /**
   * ConferenceCrawlJobs create
   */
  export type ConferenceCrawlJobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * The data needed to create a ConferenceCrawlJobs.
     */
    data: XOR<ConferenceCrawlJobsCreateInput, ConferenceCrawlJobsUncheckedCreateInput>
  }

  /**
   * ConferenceCrawlJobs createMany
   */
  export type ConferenceCrawlJobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConferenceCrawlJobs.
     */
    data: ConferenceCrawlJobsCreateManyInput | ConferenceCrawlJobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConferenceCrawlJobs createManyAndReturn
   */
  export type ConferenceCrawlJobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * The data used to create many ConferenceCrawlJobs.
     */
    data: ConferenceCrawlJobsCreateManyInput | ConferenceCrawlJobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceCrawlJobs update
   */
  export type ConferenceCrawlJobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * The data needed to update a ConferenceCrawlJobs.
     */
    data: XOR<ConferenceCrawlJobsUpdateInput, ConferenceCrawlJobsUncheckedUpdateInput>
    /**
     * Choose, which ConferenceCrawlJobs to update.
     */
    where: ConferenceCrawlJobsWhereUniqueInput
  }

  /**
   * ConferenceCrawlJobs updateMany
   */
  export type ConferenceCrawlJobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConferenceCrawlJobs.
     */
    data: XOR<ConferenceCrawlJobsUpdateManyMutationInput, ConferenceCrawlJobsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceCrawlJobs to update
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * Limit how many ConferenceCrawlJobs to update.
     */
    limit?: number
  }

  /**
   * ConferenceCrawlJobs updateManyAndReturn
   */
  export type ConferenceCrawlJobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * The data used to update ConferenceCrawlJobs.
     */
    data: XOR<ConferenceCrawlJobsUpdateManyMutationInput, ConferenceCrawlJobsUncheckedUpdateManyInput>
    /**
     * Filter which ConferenceCrawlJobs to update
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * Limit how many ConferenceCrawlJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConferenceCrawlJobs upsert
   */
  export type ConferenceCrawlJobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * The filter to search for the ConferenceCrawlJobs to update in case it exists.
     */
    where: ConferenceCrawlJobsWhereUniqueInput
    /**
     * In case the ConferenceCrawlJobs found by the `where` argument doesn't exist, create a new ConferenceCrawlJobs with this data.
     */
    create: XOR<ConferenceCrawlJobsCreateInput, ConferenceCrawlJobsUncheckedCreateInput>
    /**
     * In case the ConferenceCrawlJobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConferenceCrawlJobsUpdateInput, ConferenceCrawlJobsUncheckedUpdateInput>
  }

  /**
   * ConferenceCrawlJobs delete
   */
  export type ConferenceCrawlJobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter which ConferenceCrawlJobs to delete.
     */
    where: ConferenceCrawlJobsWhereUniqueInput
  }

  /**
   * ConferenceCrawlJobs deleteMany
   */
  export type ConferenceCrawlJobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConferenceCrawlJobs to delete
     */
    where?: ConferenceCrawlJobsWhereInput
    /**
     * Limit how many ConferenceCrawlJobs to delete.
     */
    limit?: number
  }

  /**
   * ConferenceCrawlJobs without action
   */
  export type ConferenceCrawlJobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConferenceCrawlJobs
     */
    select?: ConferenceCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConferenceCrawlJobs
     */
    omit?: ConferenceCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConferenceCrawlJobsInclude<ExtArgs> | null
  }


  /**
   * Model JournalCrawlJobs
   */

  export type AggregateJournalCrawlJobs = {
    _count: JournalCrawlJobsCountAggregateOutputType | null
    _avg: JournalCrawlJobsAvgAggregateOutputType | null
    _sum: JournalCrawlJobsSumAggregateOutputType | null
    _min: JournalCrawlJobsMinAggregateOutputType | null
    _max: JournalCrawlJobsMaxAggregateOutputType | null
  }

  export type JournalCrawlJobsAvgAggregateOutputType = {
    progress: number | null
  }

  export type JournalCrawlJobsSumAggregateOutputType = {
    progress: number | null
  }

  export type JournalCrawlJobsMinAggregateOutputType = {
    id: string | null
    journalId: string | null
    status: string | null
    progress: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalCrawlJobsMaxAggregateOutputType = {
    id: string | null
    journalId: string | null
    status: string | null
    progress: number | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalCrawlJobsCountAggregateOutputType = {
    id: number
    journalId: number
    status: number
    progress: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalCrawlJobsAvgAggregateInputType = {
    progress?: true
  }

  export type JournalCrawlJobsSumAggregateInputType = {
    progress?: true
  }

  export type JournalCrawlJobsMinAggregateInputType = {
    id?: true
    journalId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalCrawlJobsMaxAggregateInputType = {
    id?: true
    journalId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalCrawlJobsCountAggregateInputType = {
    id?: true
    journalId?: true
    status?: true
    progress?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalCrawlJobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalCrawlJobs to aggregate.
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalCrawlJobs to fetch.
     */
    orderBy?: JournalCrawlJobsOrderByWithRelationInput | JournalCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalCrawlJobs
    **/
    _count?: true | JournalCrawlJobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalCrawlJobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalCrawlJobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalCrawlJobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalCrawlJobsMaxAggregateInputType
  }

  export type GetJournalCrawlJobsAggregateType<T extends JournalCrawlJobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalCrawlJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalCrawlJobs[P]>
      : GetScalarType<T[P], AggregateJournalCrawlJobs[P]>
  }




  export type JournalCrawlJobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalCrawlJobsWhereInput
    orderBy?: JournalCrawlJobsOrderByWithAggregationInput | JournalCrawlJobsOrderByWithAggregationInput[]
    by: JournalCrawlJobsScalarFieldEnum[] | JournalCrawlJobsScalarFieldEnum
    having?: JournalCrawlJobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalCrawlJobsCountAggregateInputType | true
    _avg?: JournalCrawlJobsAvgAggregateInputType
    _sum?: JournalCrawlJobsSumAggregateInputType
    _min?: JournalCrawlJobsMinAggregateInputType
    _max?: JournalCrawlJobsMaxAggregateInputType
  }

  export type JournalCrawlJobsGroupByOutputType = {
    id: string
    journalId: string
    status: string
    progress: number
    message: string
    createdAt: Date
    updatedAt: Date
    _count: JournalCrawlJobsCountAggregateOutputType | null
    _avg: JournalCrawlJobsAvgAggregateOutputType | null
    _sum: JournalCrawlJobsSumAggregateOutputType | null
    _min: JournalCrawlJobsMinAggregateOutputType | null
    _max: JournalCrawlJobsMaxAggregateOutputType | null
  }

  type GetJournalCrawlJobsGroupByPayload<T extends JournalCrawlJobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalCrawlJobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalCrawlJobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalCrawlJobsGroupByOutputType[P]>
            : GetScalarType<T[P], JournalCrawlJobsGroupByOutputType[P]>
        }
      >
    >


  export type JournalCrawlJobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalCrawlJobs"]>

  export type JournalCrawlJobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalCrawlJobs"]>

  export type JournalCrawlJobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalCrawlJobs"]>

  export type JournalCrawlJobsSelectScalar = {
    id?: boolean
    journalId?: boolean
    status?: boolean
    progress?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalCrawlJobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "status" | "progress" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["journalCrawlJobs"]>
  export type JournalCrawlJobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }
  export type JournalCrawlJobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }
  export type JournalCrawlJobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    belongsTo?: boolean | JournalsDefaultArgs<ExtArgs>
  }

  export type $JournalCrawlJobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalCrawlJobs"
    objects: {
      belongsTo: Prisma.$JournalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalId: string
      status: string
      progress: number
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalCrawlJobs"]>
    composites: {}
  }

  type JournalCrawlJobsGetPayload<S extends boolean | null | undefined | JournalCrawlJobsDefaultArgs> = $Result.GetResult<Prisma.$JournalCrawlJobsPayload, S>

  type JournalCrawlJobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalCrawlJobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalCrawlJobsCountAggregateInputType | true
    }

  export interface JournalCrawlJobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalCrawlJobs'], meta: { name: 'JournalCrawlJobs' } }
    /**
     * Find zero or one JournalCrawlJobs that matches the filter.
     * @param {JournalCrawlJobsFindUniqueArgs} args - Arguments to find a JournalCrawlJobs
     * @example
     * // Get one JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalCrawlJobsFindUniqueArgs>(args: SelectSubset<T, JournalCrawlJobsFindUniqueArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalCrawlJobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalCrawlJobsFindUniqueOrThrowArgs} args - Arguments to find a JournalCrawlJobs
     * @example
     * // Get one JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalCrawlJobsFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalCrawlJobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalCrawlJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsFindFirstArgs} args - Arguments to find a JournalCrawlJobs
     * @example
     * // Get one JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalCrawlJobsFindFirstArgs>(args?: SelectSubset<T, JournalCrawlJobsFindFirstArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalCrawlJobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsFindFirstOrThrowArgs} args - Arguments to find a JournalCrawlJobs
     * @example
     * // Get one JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalCrawlJobsFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalCrawlJobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalCrawlJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findMany()
     * 
     * // Get first 10 JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalCrawlJobsWithIdOnly = await prisma.journalCrawlJobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalCrawlJobsFindManyArgs>(args?: SelectSubset<T, JournalCrawlJobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalCrawlJobs.
     * @param {JournalCrawlJobsCreateArgs} args - Arguments to create a JournalCrawlJobs.
     * @example
     * // Create one JournalCrawlJobs
     * const JournalCrawlJobs = await prisma.journalCrawlJobs.create({
     *   data: {
     *     // ... data to create a JournalCrawlJobs
     *   }
     * })
     * 
     */
    create<T extends JournalCrawlJobsCreateArgs>(args: SelectSubset<T, JournalCrawlJobsCreateArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalCrawlJobs.
     * @param {JournalCrawlJobsCreateManyArgs} args - Arguments to create many JournalCrawlJobs.
     * @example
     * // Create many JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalCrawlJobsCreateManyArgs>(args?: SelectSubset<T, JournalCrawlJobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalCrawlJobs and returns the data saved in the database.
     * @param {JournalCrawlJobsCreateManyAndReturnArgs} args - Arguments to create many JournalCrawlJobs.
     * @example
     * // Create many JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalCrawlJobs and only return the `id`
     * const journalCrawlJobsWithIdOnly = await prisma.journalCrawlJobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalCrawlJobsCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalCrawlJobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalCrawlJobs.
     * @param {JournalCrawlJobsDeleteArgs} args - Arguments to delete one JournalCrawlJobs.
     * @example
     * // Delete one JournalCrawlJobs
     * const JournalCrawlJobs = await prisma.journalCrawlJobs.delete({
     *   where: {
     *     // ... filter to delete one JournalCrawlJobs
     *   }
     * })
     * 
     */
    delete<T extends JournalCrawlJobsDeleteArgs>(args: SelectSubset<T, JournalCrawlJobsDeleteArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalCrawlJobs.
     * @param {JournalCrawlJobsUpdateArgs} args - Arguments to update one JournalCrawlJobs.
     * @example
     * // Update one JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalCrawlJobsUpdateArgs>(args: SelectSubset<T, JournalCrawlJobsUpdateArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalCrawlJobs.
     * @param {JournalCrawlJobsDeleteManyArgs} args - Arguments to filter JournalCrawlJobs to delete.
     * @example
     * // Delete a few JournalCrawlJobs
     * const { count } = await prisma.journalCrawlJobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalCrawlJobsDeleteManyArgs>(args?: SelectSubset<T, JournalCrawlJobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalCrawlJobsUpdateManyArgs>(args: SelectSubset<T, JournalCrawlJobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalCrawlJobs and returns the data updated in the database.
     * @param {JournalCrawlJobsUpdateManyAndReturnArgs} args - Arguments to update many JournalCrawlJobs.
     * @example
     * // Update many JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalCrawlJobs and only return the `id`
     * const journalCrawlJobsWithIdOnly = await prisma.journalCrawlJobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalCrawlJobsUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalCrawlJobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalCrawlJobs.
     * @param {JournalCrawlJobsUpsertArgs} args - Arguments to update or create a JournalCrawlJobs.
     * @example
     * // Update or create a JournalCrawlJobs
     * const journalCrawlJobs = await prisma.journalCrawlJobs.upsert({
     *   create: {
     *     // ... data to create a JournalCrawlJobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalCrawlJobs we want to update
     *   }
     * })
     */
    upsert<T extends JournalCrawlJobsUpsertArgs>(args: SelectSubset<T, JournalCrawlJobsUpsertArgs<ExtArgs>>): Prisma__JournalCrawlJobsClient<$Result.GetResult<Prisma.$JournalCrawlJobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsCountArgs} args - Arguments to filter JournalCrawlJobs to count.
     * @example
     * // Count the number of JournalCrawlJobs
     * const count = await prisma.journalCrawlJobs.count({
     *   where: {
     *     // ... the filter for the JournalCrawlJobs we want to count
     *   }
     * })
    **/
    count<T extends JournalCrawlJobsCountArgs>(
      args?: Subset<T, JournalCrawlJobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalCrawlJobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalCrawlJobsAggregateArgs>(args: Subset<T, JournalCrawlJobsAggregateArgs>): Prisma.PrismaPromise<GetJournalCrawlJobsAggregateType<T>>

    /**
     * Group by JournalCrawlJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCrawlJobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalCrawlJobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalCrawlJobsGroupByArgs['orderBy'] }
        : { orderBy?: JournalCrawlJobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalCrawlJobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalCrawlJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalCrawlJobs model
   */
  readonly fields: JournalCrawlJobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalCrawlJobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalCrawlJobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    belongsTo<T extends JournalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalsDefaultArgs<ExtArgs>>): Prisma__JournalsClient<$Result.GetResult<Prisma.$JournalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalCrawlJobs model
   */ 
  interface JournalCrawlJobsFieldRefs {
    readonly id: FieldRef<"JournalCrawlJobs", 'String'>
    readonly journalId: FieldRef<"JournalCrawlJobs", 'String'>
    readonly status: FieldRef<"JournalCrawlJobs", 'String'>
    readonly progress: FieldRef<"JournalCrawlJobs", 'Int'>
    readonly message: FieldRef<"JournalCrawlJobs", 'String'>
    readonly createdAt: FieldRef<"JournalCrawlJobs", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalCrawlJobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalCrawlJobs findUnique
   */
  export type JournalCrawlJobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which JournalCrawlJobs to fetch.
     */
    where: JournalCrawlJobsWhereUniqueInput
  }

  /**
   * JournalCrawlJobs findUniqueOrThrow
   */
  export type JournalCrawlJobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which JournalCrawlJobs to fetch.
     */
    where: JournalCrawlJobsWhereUniqueInput
  }

  /**
   * JournalCrawlJobs findFirst
   */
  export type JournalCrawlJobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which JournalCrawlJobs to fetch.
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalCrawlJobs to fetch.
     */
    orderBy?: JournalCrawlJobsOrderByWithRelationInput | JournalCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalCrawlJobs.
     */
    cursor?: JournalCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalCrawlJobs.
     */
    distinct?: JournalCrawlJobsScalarFieldEnum | JournalCrawlJobsScalarFieldEnum[]
  }

  /**
   * JournalCrawlJobs findFirstOrThrow
   */
  export type JournalCrawlJobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which JournalCrawlJobs to fetch.
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalCrawlJobs to fetch.
     */
    orderBy?: JournalCrawlJobsOrderByWithRelationInput | JournalCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalCrawlJobs.
     */
    cursor?: JournalCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalCrawlJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalCrawlJobs.
     */
    distinct?: JournalCrawlJobsScalarFieldEnum | JournalCrawlJobsScalarFieldEnum[]
  }

  /**
   * JournalCrawlJobs findMany
   */
  export type JournalCrawlJobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter, which JournalCrawlJobs to fetch.
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalCrawlJobs to fetch.
     */
    orderBy?: JournalCrawlJobsOrderByWithRelationInput | JournalCrawlJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalCrawlJobs.
     */
    cursor?: JournalCrawlJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalCrawlJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalCrawlJobs.
     */
    skip?: number
    distinct?: JournalCrawlJobsScalarFieldEnum | JournalCrawlJobsScalarFieldEnum[]
  }

  /**
   * JournalCrawlJobs create
   */
  export type JournalCrawlJobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalCrawlJobs.
     */
    data: XOR<JournalCrawlJobsCreateInput, JournalCrawlJobsUncheckedCreateInput>
  }

  /**
   * JournalCrawlJobs createMany
   */
  export type JournalCrawlJobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalCrawlJobs.
     */
    data: JournalCrawlJobsCreateManyInput | JournalCrawlJobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalCrawlJobs createManyAndReturn
   */
  export type JournalCrawlJobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * The data used to create many JournalCrawlJobs.
     */
    data: JournalCrawlJobsCreateManyInput | JournalCrawlJobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalCrawlJobs update
   */
  export type JournalCrawlJobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalCrawlJobs.
     */
    data: XOR<JournalCrawlJobsUpdateInput, JournalCrawlJobsUncheckedUpdateInput>
    /**
     * Choose, which JournalCrawlJobs to update.
     */
    where: JournalCrawlJobsWhereUniqueInput
  }

  /**
   * JournalCrawlJobs updateMany
   */
  export type JournalCrawlJobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalCrawlJobs.
     */
    data: XOR<JournalCrawlJobsUpdateManyMutationInput, JournalCrawlJobsUncheckedUpdateManyInput>
    /**
     * Filter which JournalCrawlJobs to update
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * Limit how many JournalCrawlJobs to update.
     */
    limit?: number
  }

  /**
   * JournalCrawlJobs updateManyAndReturn
   */
  export type JournalCrawlJobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * The data used to update JournalCrawlJobs.
     */
    data: XOR<JournalCrawlJobsUpdateManyMutationInput, JournalCrawlJobsUncheckedUpdateManyInput>
    /**
     * Filter which JournalCrawlJobs to update
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * Limit how many JournalCrawlJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalCrawlJobs upsert
   */
  export type JournalCrawlJobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalCrawlJobs to update in case it exists.
     */
    where: JournalCrawlJobsWhereUniqueInput
    /**
     * In case the JournalCrawlJobs found by the `where` argument doesn't exist, create a new JournalCrawlJobs with this data.
     */
    create: XOR<JournalCrawlJobsCreateInput, JournalCrawlJobsUncheckedCreateInput>
    /**
     * In case the JournalCrawlJobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalCrawlJobsUpdateInput, JournalCrawlJobsUncheckedUpdateInput>
  }

  /**
   * JournalCrawlJobs delete
   */
  export type JournalCrawlJobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
    /**
     * Filter which JournalCrawlJobs to delete.
     */
    where: JournalCrawlJobsWhereUniqueInput
  }

  /**
   * JournalCrawlJobs deleteMany
   */
  export type JournalCrawlJobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalCrawlJobs to delete
     */
    where?: JournalCrawlJobsWhereInput
    /**
     * Limit how many JournalCrawlJobs to delete.
     */
    limit?: number
  }

  /**
   * JournalCrawlJobs without action
   */
  export type JournalCrawlJobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCrawlJobs
     */
    select?: JournalCrawlJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalCrawlJobs
     */
    omit?: JournalCrawlJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalCrawlJobsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PassengerScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName'
  };

  export type PassengerScalarFieldEnum = (typeof PassengerScalarFieldEnum)[keyof typeof PassengerScalarFieldEnum]


  export const LocationsScalarFieldEnum: {
    id: 'id',
    address: 'address',
    cityStateProvince: 'cityStateProvince',
    country: 'country',
    continent: 'continent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isAvailable: 'isAvailable',
    organizeId: 'organizeId'
  };

  export type LocationsScalarFieldEnum = (typeof LocationsScalarFieldEnum)[keyof typeof LocationsScalarFieldEnum]


  export const ConferenceDatesScalarFieldEnum: {
    id: 'id',
    organizedId: 'organizedId',
    fromDate: 'fromDate',
    toDate: 'toDate',
    type: 'type',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isAvailable: 'isAvailable'
  };

  export type ConferenceDatesScalarFieldEnum = (typeof ConferenceDatesScalarFieldEnum)[keyof typeof ConferenceDatesScalarFieldEnum]


  export const ConferenceOrganizationsScalarFieldEnum: {
    id: 'id',
    year: 'year',
    accessType: 'accessType',
    isAvailable: 'isAvailable',
    conferenceId: 'conferenceId',
    publisher: 'publisher',
    summerize: 'summerize',
    callForPaper: 'callForPaper',
    link: 'link',
    cfpLink: 'cfpLink',
    impLink: 'impLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceOrganizationsScalarFieldEnum = (typeof ConferenceOrganizationsScalarFieldEnum)[keyof typeof ConferenceOrganizationsScalarFieldEnum]


  export const ConferenceTopicsScalarFieldEnum: {
    id: 'id',
    organizeId: 'organizeId',
    topicId: 'topicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceTopicsScalarFieldEnum = (typeof ConferenceTopicsScalarFieldEnum)[keyof typeof ConferenceTopicsScalarFieldEnum]


  export const TopicsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopicsScalarFieldEnum = (typeof TopicsScalarFieldEnum)[keyof typeof TopicsScalarFieldEnum]


  export const ConferencesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    acronym: 'acronym',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type ConferencesScalarFieldEnum = (typeof ConferencesScalarFieldEnum)[keyof typeof ConferencesScalarFieldEnum]


  export const ConferenceRanksScalarFieldEnum: {
    id: 'id',
    year: 'year',
    conferenceId: 'conferenceId',
    fieldOfResearchId: 'fieldOfResearchId',
    rankId: 'rankId'
  };

  export type ConferenceRanksScalarFieldEnum = (typeof ConferenceRanksScalarFieldEnum)[keyof typeof ConferenceRanksScalarFieldEnum]


  export const FieldOfResearchsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code'
  };

  export type FieldOfResearchsScalarFieldEnum = (typeof FieldOfResearchsScalarFieldEnum)[keyof typeof FieldOfResearchsScalarFieldEnum]


  export const RanksScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    sourceId: 'sourceId'
  };

  export type RanksScalarFieldEnum = (typeof RanksScalarFieldEnum)[keyof typeof RanksScalarFieldEnum]


  export const SourcesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    link: 'link'
  };

  export type SourcesScalarFieldEnum = (typeof SourcesScalarFieldEnum)[keyof typeof SourcesScalarFieldEnum]


  export const JournalTopicsScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    topicId: 'topicId'
  };

  export type JournalTopicsScalarFieldEnum = (typeof JournalTopicsScalarFieldEnum)[keyof typeof JournalTopicsScalarFieldEnum]


  export const JournalRanksScalarFieldEnum: {
    id: 'id',
    year: 'year',
    journalId: 'journalId',
    fieldOfResearchId: 'fieldOfResearchId',
    rankId: 'rankId'
  };

  export type JournalRanksScalarFieldEnum = (typeof JournalRanksScalarFieldEnum)[keyof typeof JournalRanksScalarFieldEnum]


  export const JournalsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    issn: 'issn',
    hIndex: 'hIndex',
    publisher: 'publisher',
    nation: 'nation',
    scope: 'scope',
    emailSubmission: 'emailSubmission',
    creator: 'creator'
  };

  export type JournalsScalarFieldEnum = (typeof JournalsScalarFieldEnum)[keyof typeof JournalsScalarFieldEnum]


  export const ConferenceFollowsScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceFollowsScalarFieldEnum = (typeof ConferenceFollowsScalarFieldEnum)[keyof typeof ConferenceFollowsScalarFieldEnum]


  export const ConferenceLikesScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceLikesScalarFieldEnum = (typeof ConferenceLikesScalarFieldEnum)[keyof typeof ConferenceLikesScalarFieldEnum]


  export const ConferenceFeedbacksScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    creatorId: 'creatorId',
    description: 'description',
    star: 'star',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceFeedbacksScalarFieldEnum = (typeof ConferenceFeedbacksScalarFieldEnum)[keyof typeof ConferenceFeedbacksScalarFieldEnum]


  export const ConferenceCalendarsScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceCalendarsScalarFieldEnum = (typeof ConferenceCalendarsScalarFieldEnum)[keyof typeof ConferenceCalendarsScalarFieldEnum]


  export const JournalLikesScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalLikesScalarFieldEnum = (typeof JournalLikesScalarFieldEnum)[keyof typeof JournalLikesScalarFieldEnum]


  export const JournalFollowsScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalFollowsScalarFieldEnum = (typeof JournalFollowsScalarFieldEnum)[keyof typeof JournalFollowsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    dob: 'dob',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const ConferenceCrawlJobsScalarFieldEnum: {
    id: 'id',
    conferenceId: 'conferenceId',
    status: 'status',
    progress: 'progress',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConferenceCrawlJobsScalarFieldEnum = (typeof ConferenceCrawlJobsScalarFieldEnum)[keyof typeof ConferenceCrawlJobsScalarFieldEnum]


  export const JournalCrawlJobsScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    status: 'status',
    progress: 'progress',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalCrawlJobsScalarFieldEnum = (typeof JournalCrawlJobsScalarFieldEnum)[keyof typeof JournalCrawlJobsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PassengerWhereInput = {
    AND?: PassengerWhereInput | PassengerWhereInput[]
    OR?: PassengerWhereInput[]
    NOT?: PassengerWhereInput | PassengerWhereInput[]
    id?: StringFilter<"Passenger"> | string
    firstName?: StringFilter<"Passenger"> | string
    lastName?: StringFilter<"Passenger"> | string
  }

  export type PassengerOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type PassengerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    firstName?: string
    AND?: PassengerWhereInput | PassengerWhereInput[]
    OR?: PassengerWhereInput[]
    NOT?: PassengerWhereInput | PassengerWhereInput[]
    lastName?: StringFilter<"Passenger"> | string
  }, "id" | "firstName">

  export type PassengerOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    _count?: PassengerCountOrderByAggregateInput
    _max?: PassengerMaxOrderByAggregateInput
    _min?: PassengerMinOrderByAggregateInput
  }

  export type PassengerScalarWhereWithAggregatesInput = {
    AND?: PassengerScalarWhereWithAggregatesInput | PassengerScalarWhereWithAggregatesInput[]
    OR?: PassengerScalarWhereWithAggregatesInput[]
    NOT?: PassengerScalarWhereWithAggregatesInput | PassengerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Passenger"> | string
    firstName?: StringWithAggregatesFilter<"Passenger"> | string
    lastName?: StringWithAggregatesFilter<"Passenger"> | string
  }

  export type LocationsWhereInput = {
    AND?: LocationsWhereInput | LocationsWhereInput[]
    OR?: LocationsWhereInput[]
    NOT?: LocationsWhereInput | LocationsWhereInput[]
    id?: StringFilter<"Locations"> | string
    address?: StringNullableFilter<"Locations"> | string | null
    cityStateProvince?: StringNullableFilter<"Locations"> | string | null
    country?: StringNullableFilter<"Locations"> | string | null
    continent?: StringNullableFilter<"Locations"> | string | null
    createdAt?: DateTimeFilter<"Locations"> | Date | string
    updatedAt?: DateTimeFilter<"Locations"> | Date | string
    isAvailable?: BoolFilter<"Locations"> | boolean
    organizeId?: StringFilter<"Locations"> | string
    belongsTo?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
  }

  export type LocationsOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrderInput | SortOrder
    cityStateProvince?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    continent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    organizeId?: SortOrder
    belongsTo?: ConferenceOrganizationsOrderByWithRelationInput
  }

  export type LocationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationsWhereInput | LocationsWhereInput[]
    OR?: LocationsWhereInput[]
    NOT?: LocationsWhereInput | LocationsWhereInput[]
    address?: StringNullableFilter<"Locations"> | string | null
    cityStateProvince?: StringNullableFilter<"Locations"> | string | null
    country?: StringNullableFilter<"Locations"> | string | null
    continent?: StringNullableFilter<"Locations"> | string | null
    createdAt?: DateTimeFilter<"Locations"> | Date | string
    updatedAt?: DateTimeFilter<"Locations"> | Date | string
    isAvailable?: BoolFilter<"Locations"> | boolean
    organizeId?: StringFilter<"Locations"> | string
    belongsTo?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
  }, "id">

  export type LocationsOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrderInput | SortOrder
    cityStateProvince?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    continent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    organizeId?: SortOrder
    _count?: LocationsCountOrderByAggregateInput
    _max?: LocationsMaxOrderByAggregateInput
    _min?: LocationsMinOrderByAggregateInput
  }

  export type LocationsScalarWhereWithAggregatesInput = {
    AND?: LocationsScalarWhereWithAggregatesInput | LocationsScalarWhereWithAggregatesInput[]
    OR?: LocationsScalarWhereWithAggregatesInput[]
    NOT?: LocationsScalarWhereWithAggregatesInput | LocationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Locations"> | string
    address?: StringNullableWithAggregatesFilter<"Locations"> | string | null
    cityStateProvince?: StringNullableWithAggregatesFilter<"Locations"> | string | null
    country?: StringNullableWithAggregatesFilter<"Locations"> | string | null
    continent?: StringNullableWithAggregatesFilter<"Locations"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Locations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Locations"> | Date | string
    isAvailable?: BoolWithAggregatesFilter<"Locations"> | boolean
    organizeId?: StringWithAggregatesFilter<"Locations"> | string
  }

  export type ConferenceDatesWhereInput = {
    AND?: ConferenceDatesWhereInput | ConferenceDatesWhereInput[]
    OR?: ConferenceDatesWhereInput[]
    NOT?: ConferenceDatesWhereInput | ConferenceDatesWhereInput[]
    id?: StringFilter<"ConferenceDates"> | string
    organizedId?: StringFilter<"ConferenceDates"> | string
    fromDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    toDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    type?: StringFilter<"ConferenceDates"> | string
    name?: StringFilter<"ConferenceDates"> | string
    createdAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    isAvailable?: BoolFilter<"ConferenceDates"> | boolean
    belongsTo?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
  }

  export type ConferenceDatesOrderByWithRelationInput = {
    id?: SortOrder
    organizedId?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    belongsTo?: ConferenceOrganizationsOrderByWithRelationInput
  }

  export type ConferenceDatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceDatesWhereInput | ConferenceDatesWhereInput[]
    OR?: ConferenceDatesWhereInput[]
    NOT?: ConferenceDatesWhereInput | ConferenceDatesWhereInput[]
    organizedId?: StringFilter<"ConferenceDates"> | string
    fromDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    toDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    type?: StringFilter<"ConferenceDates"> | string
    name?: StringFilter<"ConferenceDates"> | string
    createdAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    isAvailable?: BoolFilter<"ConferenceDates"> | boolean
    belongsTo?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
  }, "id">

  export type ConferenceDatesOrderByWithAggregationInput = {
    id?: SortOrder
    organizedId?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    _count?: ConferenceDatesCountOrderByAggregateInput
    _max?: ConferenceDatesMaxOrderByAggregateInput
    _min?: ConferenceDatesMinOrderByAggregateInput
  }

  export type ConferenceDatesScalarWhereWithAggregatesInput = {
    AND?: ConferenceDatesScalarWhereWithAggregatesInput | ConferenceDatesScalarWhereWithAggregatesInput[]
    OR?: ConferenceDatesScalarWhereWithAggregatesInput[]
    NOT?: ConferenceDatesScalarWhereWithAggregatesInput | ConferenceDatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceDates"> | string
    organizedId?: StringWithAggregatesFilter<"ConferenceDates"> | string
    fromDate?: DateTimeWithAggregatesFilter<"ConferenceDates"> | Date | string
    toDate?: DateTimeWithAggregatesFilter<"ConferenceDates"> | Date | string
    type?: StringWithAggregatesFilter<"ConferenceDates"> | string
    name?: StringWithAggregatesFilter<"ConferenceDates"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceDates"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceDates"> | Date | string
    isAvailable?: BoolWithAggregatesFilter<"ConferenceDates"> | boolean
  }

  export type ConferenceOrganizationsWhereInput = {
    AND?: ConferenceOrganizationsWhereInput | ConferenceOrganizationsWhereInput[]
    OR?: ConferenceOrganizationsWhereInput[]
    NOT?: ConferenceOrganizationsWhereInput | ConferenceOrganizationsWhereInput[]
    id?: StringFilter<"ConferenceOrganizations"> | string
    year?: IntFilter<"ConferenceOrganizations"> | number
    accessType?: StringFilter<"ConferenceOrganizations"> | string
    isAvailable?: BoolFilter<"ConferenceOrganizations"> | boolean
    conferenceId?: StringFilter<"ConferenceOrganizations"> | string
    publisher?: StringFilter<"ConferenceOrganizations"> | string
    summerize?: StringFilter<"ConferenceOrganizations"> | string
    callForPaper?: StringFilter<"ConferenceOrganizations"> | string
    link?: StringFilter<"ConferenceOrganizations"> | string
    cfpLink?: StringFilter<"ConferenceOrganizations"> | string
    impLink?: StringFilter<"ConferenceOrganizations"> | string
    createdAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
    conferenceDates?: ConferenceDatesListRelationFilter
    locations?: LocationsListRelationFilter
    topics?: ConferenceTopicsListRelationFilter
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
  }

  export type ConferenceOrganizationsOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    accessType?: SortOrder
    isAvailable?: SortOrder
    conferenceId?: SortOrder
    publisher?: SortOrder
    summerize?: SortOrder
    callForPaper?: SortOrder
    link?: SortOrder
    cfpLink?: SortOrder
    impLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conferenceDates?: ConferenceDatesOrderByRelationAggregateInput
    locations?: LocationsOrderByRelationAggregateInput
    topics?: ConferenceTopicsOrderByRelationAggregateInput
    belongsTo?: ConferencesOrderByWithRelationInput
  }

  export type ConferenceOrganizationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceOrganizationsWhereInput | ConferenceOrganizationsWhereInput[]
    OR?: ConferenceOrganizationsWhereInput[]
    NOT?: ConferenceOrganizationsWhereInput | ConferenceOrganizationsWhereInput[]
    year?: IntFilter<"ConferenceOrganizations"> | number
    accessType?: StringFilter<"ConferenceOrganizations"> | string
    isAvailable?: BoolFilter<"ConferenceOrganizations"> | boolean
    conferenceId?: StringFilter<"ConferenceOrganizations"> | string
    publisher?: StringFilter<"ConferenceOrganizations"> | string
    summerize?: StringFilter<"ConferenceOrganizations"> | string
    callForPaper?: StringFilter<"ConferenceOrganizations"> | string
    link?: StringFilter<"ConferenceOrganizations"> | string
    cfpLink?: StringFilter<"ConferenceOrganizations"> | string
    impLink?: StringFilter<"ConferenceOrganizations"> | string
    createdAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
    conferenceDates?: ConferenceDatesListRelationFilter
    locations?: LocationsListRelationFilter
    topics?: ConferenceTopicsListRelationFilter
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
  }, "id">

  export type ConferenceOrganizationsOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    accessType?: SortOrder
    isAvailable?: SortOrder
    conferenceId?: SortOrder
    publisher?: SortOrder
    summerize?: SortOrder
    callForPaper?: SortOrder
    link?: SortOrder
    cfpLink?: SortOrder
    impLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceOrganizationsCountOrderByAggregateInput
    _avg?: ConferenceOrganizationsAvgOrderByAggregateInput
    _max?: ConferenceOrganizationsMaxOrderByAggregateInput
    _min?: ConferenceOrganizationsMinOrderByAggregateInput
    _sum?: ConferenceOrganizationsSumOrderByAggregateInput
  }

  export type ConferenceOrganizationsScalarWhereWithAggregatesInput = {
    AND?: ConferenceOrganizationsScalarWhereWithAggregatesInput | ConferenceOrganizationsScalarWhereWithAggregatesInput[]
    OR?: ConferenceOrganizationsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceOrganizationsScalarWhereWithAggregatesInput | ConferenceOrganizationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    year?: IntWithAggregatesFilter<"ConferenceOrganizations"> | number
    accessType?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    isAvailable?: BoolWithAggregatesFilter<"ConferenceOrganizations"> | boolean
    conferenceId?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    publisher?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    summerize?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    callForPaper?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    link?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    cfpLink?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    impLink?: StringWithAggregatesFilter<"ConferenceOrganizations"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceOrganizations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceOrganizations"> | Date | string
  }

  export type ConferenceTopicsWhereInput = {
    AND?: ConferenceTopicsWhereInput | ConferenceTopicsWhereInput[]
    OR?: ConferenceTopicsWhereInput[]
    NOT?: ConferenceTopicsWhereInput | ConferenceTopicsWhereInput[]
    id?: StringFilter<"ConferenceTopics"> | string
    organizeId?: StringFilter<"ConferenceTopics"> | string
    topicId?: StringFilter<"ConferenceTopics"> | string
    createdAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
    belongsTo?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
    inTopic?: XOR<TopicsScalarRelationFilter, TopicsWhereInput>
  }

  export type ConferenceTopicsOrderByWithRelationInput = {
    id?: SortOrder
    organizeId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    belongsTo?: ConferenceOrganizationsOrderByWithRelationInput
    inTopic?: TopicsOrderByWithRelationInput
  }

  export type ConferenceTopicsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceTopicsWhereInput | ConferenceTopicsWhereInput[]
    OR?: ConferenceTopicsWhereInput[]
    NOT?: ConferenceTopicsWhereInput | ConferenceTopicsWhereInput[]
    organizeId?: StringFilter<"ConferenceTopics"> | string
    topicId?: StringFilter<"ConferenceTopics"> | string
    createdAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
    belongsTo?: XOR<ConferenceOrganizationsScalarRelationFilter, ConferenceOrganizationsWhereInput>
    inTopic?: XOR<TopicsScalarRelationFilter, TopicsWhereInput>
  }, "id">

  export type ConferenceTopicsOrderByWithAggregationInput = {
    id?: SortOrder
    organizeId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceTopicsCountOrderByAggregateInput
    _max?: ConferenceTopicsMaxOrderByAggregateInput
    _min?: ConferenceTopicsMinOrderByAggregateInput
  }

  export type ConferenceTopicsScalarWhereWithAggregatesInput = {
    AND?: ConferenceTopicsScalarWhereWithAggregatesInput | ConferenceTopicsScalarWhereWithAggregatesInput[]
    OR?: ConferenceTopicsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceTopicsScalarWhereWithAggregatesInput | ConferenceTopicsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceTopics"> | string
    organizeId?: StringWithAggregatesFilter<"ConferenceTopics"> | string
    topicId?: StringWithAggregatesFilter<"ConferenceTopics"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceTopics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceTopics"> | Date | string
  }

  export type TopicsWhereInput = {
    AND?: TopicsWhereInput | TopicsWhereInput[]
    OR?: TopicsWhereInput[]
    NOT?: TopicsWhereInput | TopicsWhereInput[]
    id?: StringFilter<"Topics"> | string
    name?: StringFilter<"Topics"> | string
    createdAt?: DateTimeFilter<"Topics"> | Date | string
    updatedAt?: DateTimeFilter<"Topics"> | Date | string
    inConferenceTopics?: ConferenceTopicsListRelationFilter
    inJournalTopics?: JournalTopicsListRelationFilter
  }

  export type TopicsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inConferenceTopics?: ConferenceTopicsOrderByRelationAggregateInput
    inJournalTopics?: JournalTopicsOrderByRelationAggregateInput
  }

  export type TopicsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TopicsWhereInput | TopicsWhereInput[]
    OR?: TopicsWhereInput[]
    NOT?: TopicsWhereInput | TopicsWhereInput[]
    createdAt?: DateTimeFilter<"Topics"> | Date | string
    updatedAt?: DateTimeFilter<"Topics"> | Date | string
    inConferenceTopics?: ConferenceTopicsListRelationFilter
    inJournalTopics?: JournalTopicsListRelationFilter
  }, "id" | "name">

  export type TopicsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TopicsCountOrderByAggregateInput
    _max?: TopicsMaxOrderByAggregateInput
    _min?: TopicsMinOrderByAggregateInput
  }

  export type TopicsScalarWhereWithAggregatesInput = {
    AND?: TopicsScalarWhereWithAggregatesInput | TopicsScalarWhereWithAggregatesInput[]
    OR?: TopicsScalarWhereWithAggregatesInput[]
    NOT?: TopicsScalarWhereWithAggregatesInput | TopicsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Topics"> | string
    name?: StringWithAggregatesFilter<"Topics"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Topics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Topics"> | Date | string
  }

  export type ConferencesWhereInput = {
    AND?: ConferencesWhereInput | ConferencesWhereInput[]
    OR?: ConferencesWhereInput[]
    NOT?: ConferencesWhereInput | ConferencesWhereInput[]
    id?: StringFilter<"Conferences"> | string
    title?: StringFilter<"Conferences"> | string
    acronym?: StringFilter<"Conferences"> | string
    creatorId?: StringFilter<"Conferences"> | string
    createdAt?: DateTimeFilter<"Conferences"> | Date | string
    updatedAt?: DateTimeFilter<"Conferences"> | Date | string
    status?: StringFilter<"Conferences"> | string
    follows?: ConferenceFollowsListRelationFilter
    likes?: ConferenceLikesListRelationFilter
    calendars?: ConferenceCalendarsListRelationFilter
    organizations?: ConferenceOrganizationsListRelationFilter
    ranks?: ConferenceRanksListRelationFilter
    crawlJobs?: ConferenceCrawlJobsListRelationFilter
    createdByUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    feedbacks?: ConferenceFeedbacksListRelationFilter
  }

  export type ConferencesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    acronym?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    follows?: ConferenceFollowsOrderByRelationAggregateInput
    likes?: ConferenceLikesOrderByRelationAggregateInput
    calendars?: ConferenceCalendarsOrderByRelationAggregateInput
    organizations?: ConferenceOrganizationsOrderByRelationAggregateInput
    ranks?: ConferenceRanksOrderByRelationAggregateInput
    crawlJobs?: ConferenceCrawlJobsOrderByRelationAggregateInput
    createdByUser?: UsersOrderByWithRelationInput
    feedbacks?: ConferenceFeedbacksOrderByRelationAggregateInput
  }

  export type ConferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title_acronym?: ConferencesTitleAcronymCompoundUniqueInput
    AND?: ConferencesWhereInput | ConferencesWhereInput[]
    OR?: ConferencesWhereInput[]
    NOT?: ConferencesWhereInput | ConferencesWhereInput[]
    title?: StringFilter<"Conferences"> | string
    acronym?: StringFilter<"Conferences"> | string
    creatorId?: StringFilter<"Conferences"> | string
    createdAt?: DateTimeFilter<"Conferences"> | Date | string
    updatedAt?: DateTimeFilter<"Conferences"> | Date | string
    status?: StringFilter<"Conferences"> | string
    follows?: ConferenceFollowsListRelationFilter
    likes?: ConferenceLikesListRelationFilter
    calendars?: ConferenceCalendarsListRelationFilter
    organizations?: ConferenceOrganizationsListRelationFilter
    ranks?: ConferenceRanksListRelationFilter
    crawlJobs?: ConferenceCrawlJobsListRelationFilter
    createdByUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    feedbacks?: ConferenceFeedbacksListRelationFilter
  }, "id" | "title_acronym">

  export type ConferencesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    acronym?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: ConferencesCountOrderByAggregateInput
    _max?: ConferencesMaxOrderByAggregateInput
    _min?: ConferencesMinOrderByAggregateInput
  }

  export type ConferencesScalarWhereWithAggregatesInput = {
    AND?: ConferencesScalarWhereWithAggregatesInput | ConferencesScalarWhereWithAggregatesInput[]
    OR?: ConferencesScalarWhereWithAggregatesInput[]
    NOT?: ConferencesScalarWhereWithAggregatesInput | ConferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conferences"> | string
    title?: StringWithAggregatesFilter<"Conferences"> | string
    acronym?: StringWithAggregatesFilter<"Conferences"> | string
    creatorId?: StringWithAggregatesFilter<"Conferences"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Conferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conferences"> | Date | string
    status?: StringWithAggregatesFilter<"Conferences"> | string
  }

  export type ConferenceRanksWhereInput = {
    AND?: ConferenceRanksWhereInput | ConferenceRanksWhereInput[]
    OR?: ConferenceRanksWhereInput[]
    NOT?: ConferenceRanksWhereInput | ConferenceRanksWhereInput[]
    id?: StringFilter<"ConferenceRanks"> | string
    year?: IntFilter<"ConferenceRanks"> | number
    conferenceId?: StringFilter<"ConferenceRanks"> | string
    fieldOfResearchId?: StringFilter<"ConferenceRanks"> | string
    rankId?: StringFilter<"ConferenceRanks"> | string
    inFieldOfResearch?: XOR<FieldOfResearchsScalarRelationFilter, FieldOfResearchsWhereInput>
    byRank?: XOR<RanksScalarRelationFilter, RanksWhereInput>
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
  }

  export type ConferenceRanksOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    conferenceId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
    inFieldOfResearch?: FieldOfResearchsOrderByWithRelationInput
    byRank?: RanksOrderByWithRelationInput
    belongsTo?: ConferencesOrderByWithRelationInput
  }

  export type ConferenceRanksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceRanksWhereInput | ConferenceRanksWhereInput[]
    OR?: ConferenceRanksWhereInput[]
    NOT?: ConferenceRanksWhereInput | ConferenceRanksWhereInput[]
    year?: IntFilter<"ConferenceRanks"> | number
    conferenceId?: StringFilter<"ConferenceRanks"> | string
    fieldOfResearchId?: StringFilter<"ConferenceRanks"> | string
    rankId?: StringFilter<"ConferenceRanks"> | string
    inFieldOfResearch?: XOR<FieldOfResearchsScalarRelationFilter, FieldOfResearchsWhereInput>
    byRank?: XOR<RanksScalarRelationFilter, RanksWhereInput>
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
  }, "id">

  export type ConferenceRanksOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    conferenceId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
    _count?: ConferenceRanksCountOrderByAggregateInput
    _avg?: ConferenceRanksAvgOrderByAggregateInput
    _max?: ConferenceRanksMaxOrderByAggregateInput
    _min?: ConferenceRanksMinOrderByAggregateInput
    _sum?: ConferenceRanksSumOrderByAggregateInput
  }

  export type ConferenceRanksScalarWhereWithAggregatesInput = {
    AND?: ConferenceRanksScalarWhereWithAggregatesInput | ConferenceRanksScalarWhereWithAggregatesInput[]
    OR?: ConferenceRanksScalarWhereWithAggregatesInput[]
    NOT?: ConferenceRanksScalarWhereWithAggregatesInput | ConferenceRanksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceRanks"> | string
    year?: IntWithAggregatesFilter<"ConferenceRanks"> | number
    conferenceId?: StringWithAggregatesFilter<"ConferenceRanks"> | string
    fieldOfResearchId?: StringWithAggregatesFilter<"ConferenceRanks"> | string
    rankId?: StringWithAggregatesFilter<"ConferenceRanks"> | string
  }

  export type FieldOfResearchsWhereInput = {
    AND?: FieldOfResearchsWhereInput | FieldOfResearchsWhereInput[]
    OR?: FieldOfResearchsWhereInput[]
    NOT?: FieldOfResearchsWhereInput | FieldOfResearchsWhereInput[]
    id?: StringFilter<"FieldOfResearchs"> | string
    name?: StringFilter<"FieldOfResearchs"> | string
    code?: StringFilter<"FieldOfResearchs"> | string
    journalRanks?: JournalRanksListRelationFilter
    conferenceRanks?: ConferenceRanksListRelationFilter
  }

  export type FieldOfResearchsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    journalRanks?: JournalRanksOrderByRelationAggregateInput
    conferenceRanks?: ConferenceRanksOrderByRelationAggregateInput
  }

  export type FieldOfResearchsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FieldOfResearchsWhereInput | FieldOfResearchsWhereInput[]
    OR?: FieldOfResearchsWhereInput[]
    NOT?: FieldOfResearchsWhereInput | FieldOfResearchsWhereInput[]
    name?: StringFilter<"FieldOfResearchs"> | string
    code?: StringFilter<"FieldOfResearchs"> | string
    journalRanks?: JournalRanksListRelationFilter
    conferenceRanks?: ConferenceRanksListRelationFilter
  }, "id">

  export type FieldOfResearchsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    _count?: FieldOfResearchsCountOrderByAggregateInput
    _max?: FieldOfResearchsMaxOrderByAggregateInput
    _min?: FieldOfResearchsMinOrderByAggregateInput
  }

  export type FieldOfResearchsScalarWhereWithAggregatesInput = {
    AND?: FieldOfResearchsScalarWhereWithAggregatesInput | FieldOfResearchsScalarWhereWithAggregatesInput[]
    OR?: FieldOfResearchsScalarWhereWithAggregatesInput[]
    NOT?: FieldOfResearchsScalarWhereWithAggregatesInput | FieldOfResearchsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FieldOfResearchs"> | string
    name?: StringWithAggregatesFilter<"FieldOfResearchs"> | string
    code?: StringWithAggregatesFilter<"FieldOfResearchs"> | string
  }

  export type RanksWhereInput = {
    AND?: RanksWhereInput | RanksWhereInput[]
    OR?: RanksWhereInput[]
    NOT?: RanksWhereInput | RanksWhereInput[]
    id?: StringFilter<"Ranks"> | string
    name?: StringFilter<"Ranks"> | string
    value?: IntFilter<"Ranks"> | number
    sourceId?: StringFilter<"Ranks"> | string
    conferenceRanks?: ConferenceRanksListRelationFilter
    journalRanks?: JournalRanksListRelationFilter
    belongsToSource?: XOR<SourcesScalarRelationFilter, SourcesWhereInput>
  }

  export type RanksOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    sourceId?: SortOrder
    conferenceRanks?: ConferenceRanksOrderByRelationAggregateInput
    journalRanks?: JournalRanksOrderByRelationAggregateInput
    belongsToSource?: SourcesOrderByWithRelationInput
  }

  export type RanksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RanksWhereInput | RanksWhereInput[]
    OR?: RanksWhereInput[]
    NOT?: RanksWhereInput | RanksWhereInput[]
    name?: StringFilter<"Ranks"> | string
    value?: IntFilter<"Ranks"> | number
    sourceId?: StringFilter<"Ranks"> | string
    conferenceRanks?: ConferenceRanksListRelationFilter
    journalRanks?: JournalRanksListRelationFilter
    belongsToSource?: XOR<SourcesScalarRelationFilter, SourcesWhereInput>
  }, "id">

  export type RanksOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    sourceId?: SortOrder
    _count?: RanksCountOrderByAggregateInput
    _avg?: RanksAvgOrderByAggregateInput
    _max?: RanksMaxOrderByAggregateInput
    _min?: RanksMinOrderByAggregateInput
    _sum?: RanksSumOrderByAggregateInput
  }

  export type RanksScalarWhereWithAggregatesInput = {
    AND?: RanksScalarWhereWithAggregatesInput | RanksScalarWhereWithAggregatesInput[]
    OR?: RanksScalarWhereWithAggregatesInput[]
    NOT?: RanksScalarWhereWithAggregatesInput | RanksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ranks"> | string
    name?: StringWithAggregatesFilter<"Ranks"> | string
    value?: IntWithAggregatesFilter<"Ranks"> | number
    sourceId?: StringWithAggregatesFilter<"Ranks"> | string
  }

  export type SourcesWhereInput = {
    AND?: SourcesWhereInput | SourcesWhereInput[]
    OR?: SourcesWhereInput[]
    NOT?: SourcesWhereInput | SourcesWhereInput[]
    id?: StringFilter<"Sources"> | string
    name?: StringFilter<"Sources"> | string
    link?: StringNullableFilter<"Sources"> | string | null
    ranks?: RanksListRelationFilter
  }

  export type SourcesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrderInput | SortOrder
    ranks?: RanksOrderByRelationAggregateInput
  }

  export type SourcesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SourcesWhereInput | SourcesWhereInput[]
    OR?: SourcesWhereInput[]
    NOT?: SourcesWhereInput | SourcesWhereInput[]
    link?: StringNullableFilter<"Sources"> | string | null
    ranks?: RanksListRelationFilter
  }, "id" | "name">

  export type SourcesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrderInput | SortOrder
    _count?: SourcesCountOrderByAggregateInput
    _max?: SourcesMaxOrderByAggregateInput
    _min?: SourcesMinOrderByAggregateInput
  }

  export type SourcesScalarWhereWithAggregatesInput = {
    AND?: SourcesScalarWhereWithAggregatesInput | SourcesScalarWhereWithAggregatesInput[]
    OR?: SourcesScalarWhereWithAggregatesInput[]
    NOT?: SourcesScalarWhereWithAggregatesInput | SourcesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sources"> | string
    name?: StringWithAggregatesFilter<"Sources"> | string
    link?: StringNullableWithAggregatesFilter<"Sources"> | string | null
  }

  export type JournalTopicsWhereInput = {
    AND?: JournalTopicsWhereInput | JournalTopicsWhereInput[]
    OR?: JournalTopicsWhereInput[]
    NOT?: JournalTopicsWhereInput | JournalTopicsWhereInput[]
    id?: StringFilter<"JournalTopics"> | string
    journalId?: StringFilter<"JournalTopics"> | string
    topicId?: StringFilter<"JournalTopics"> | string
    belongsToTopics?: XOR<TopicsScalarRelationFilter, TopicsWhereInput>
    inJournals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
  }

  export type JournalTopicsOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    topicId?: SortOrder
    belongsToTopics?: TopicsOrderByWithRelationInput
    inJournals?: JournalsOrderByWithRelationInput
  }

  export type JournalTopicsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalTopicsWhereInput | JournalTopicsWhereInput[]
    OR?: JournalTopicsWhereInput[]
    NOT?: JournalTopicsWhereInput | JournalTopicsWhereInput[]
    journalId?: StringFilter<"JournalTopics"> | string
    topicId?: StringFilter<"JournalTopics"> | string
    belongsToTopics?: XOR<TopicsScalarRelationFilter, TopicsWhereInput>
    inJournals?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
  }, "id">

  export type JournalTopicsOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    topicId?: SortOrder
    _count?: JournalTopicsCountOrderByAggregateInput
    _max?: JournalTopicsMaxOrderByAggregateInput
    _min?: JournalTopicsMinOrderByAggregateInput
  }

  export type JournalTopicsScalarWhereWithAggregatesInput = {
    AND?: JournalTopicsScalarWhereWithAggregatesInput | JournalTopicsScalarWhereWithAggregatesInput[]
    OR?: JournalTopicsScalarWhereWithAggregatesInput[]
    NOT?: JournalTopicsScalarWhereWithAggregatesInput | JournalTopicsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalTopics"> | string
    journalId?: StringWithAggregatesFilter<"JournalTopics"> | string
    topicId?: StringWithAggregatesFilter<"JournalTopics"> | string
  }

  export type JournalRanksWhereInput = {
    AND?: JournalRanksWhereInput | JournalRanksWhereInput[]
    OR?: JournalRanksWhereInput[]
    NOT?: JournalRanksWhereInput | JournalRanksWhereInput[]
    id?: StringFilter<"JournalRanks"> | string
    year?: IntFilter<"JournalRanks"> | number
    journalId?: StringFilter<"JournalRanks"> | string
    fieldOfResearchId?: StringFilter<"JournalRanks"> | string
    rankId?: StringFilter<"JournalRanks"> | string
    inFieldOfResearch?: XOR<FieldOfResearchsScalarRelationFilter, FieldOfResearchsWhereInput>
    byRank?: XOR<RanksScalarRelationFilter, RanksWhereInput>
    belongsTo?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
  }

  export type JournalRanksOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    journalId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
    inFieldOfResearch?: FieldOfResearchsOrderByWithRelationInput
    byRank?: RanksOrderByWithRelationInput
    belongsTo?: JournalsOrderByWithRelationInput
  }

  export type JournalRanksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalRanksWhereInput | JournalRanksWhereInput[]
    OR?: JournalRanksWhereInput[]
    NOT?: JournalRanksWhereInput | JournalRanksWhereInput[]
    year?: IntFilter<"JournalRanks"> | number
    journalId?: StringFilter<"JournalRanks"> | string
    fieldOfResearchId?: StringFilter<"JournalRanks"> | string
    rankId?: StringFilter<"JournalRanks"> | string
    inFieldOfResearch?: XOR<FieldOfResearchsScalarRelationFilter, FieldOfResearchsWhereInput>
    byRank?: XOR<RanksScalarRelationFilter, RanksWhereInput>
    belongsTo?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
  }, "id">

  export type JournalRanksOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    journalId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
    _count?: JournalRanksCountOrderByAggregateInput
    _avg?: JournalRanksAvgOrderByAggregateInput
    _max?: JournalRanksMaxOrderByAggregateInput
    _min?: JournalRanksMinOrderByAggregateInput
    _sum?: JournalRanksSumOrderByAggregateInput
  }

  export type JournalRanksScalarWhereWithAggregatesInput = {
    AND?: JournalRanksScalarWhereWithAggregatesInput | JournalRanksScalarWhereWithAggregatesInput[]
    OR?: JournalRanksScalarWhereWithAggregatesInput[]
    NOT?: JournalRanksScalarWhereWithAggregatesInput | JournalRanksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalRanks"> | string
    year?: IntWithAggregatesFilter<"JournalRanks"> | number
    journalId?: StringWithAggregatesFilter<"JournalRanks"> | string
    fieldOfResearchId?: StringWithAggregatesFilter<"JournalRanks"> | string
    rankId?: StringWithAggregatesFilter<"JournalRanks"> | string
  }

  export type JournalsWhereInput = {
    AND?: JournalsWhereInput | JournalsWhereInput[]
    OR?: JournalsWhereInput[]
    NOT?: JournalsWhereInput | JournalsWhereInput[]
    id?: StringFilter<"Journals"> | string
    name?: StringFilter<"Journals"> | string
    issn?: StringFilter<"Journals"> | string
    hIndex?: IntFilter<"Journals"> | number
    publisher?: StringFilter<"Journals"> | string
    nation?: StringFilter<"Journals"> | string
    scope?: StringFilter<"Journals"> | string
    emailSubmission?: StringFilter<"Journals"> | string
    creator?: StringFilter<"Journals"> | string
    topics?: JournalTopicsListRelationFilter
    journalRanks?: JournalRanksListRelationFilter
    journalLikes?: JournalLikesListRelationFilter
    journalFollows?: JournalFollowsListRelationFilter
    crawlJobs?: JournalCrawlJobsListRelationFilter
    createdByUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type JournalsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    issn?: SortOrder
    hIndex?: SortOrder
    publisher?: SortOrder
    nation?: SortOrder
    scope?: SortOrder
    emailSubmission?: SortOrder
    creator?: SortOrder
    topics?: JournalTopicsOrderByRelationAggregateInput
    journalRanks?: JournalRanksOrderByRelationAggregateInput
    journalLikes?: JournalLikesOrderByRelationAggregateInput
    journalFollows?: JournalFollowsOrderByRelationAggregateInput
    crawlJobs?: JournalCrawlJobsOrderByRelationAggregateInput
    createdByUser?: UsersOrderByWithRelationInput
  }

  export type JournalsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalsWhereInput | JournalsWhereInput[]
    OR?: JournalsWhereInput[]
    NOT?: JournalsWhereInput | JournalsWhereInput[]
    name?: StringFilter<"Journals"> | string
    issn?: StringFilter<"Journals"> | string
    hIndex?: IntFilter<"Journals"> | number
    publisher?: StringFilter<"Journals"> | string
    nation?: StringFilter<"Journals"> | string
    scope?: StringFilter<"Journals"> | string
    emailSubmission?: StringFilter<"Journals"> | string
    creator?: StringFilter<"Journals"> | string
    topics?: JournalTopicsListRelationFilter
    journalRanks?: JournalRanksListRelationFilter
    journalLikes?: JournalLikesListRelationFilter
    journalFollows?: JournalFollowsListRelationFilter
    crawlJobs?: JournalCrawlJobsListRelationFilter
    createdByUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type JournalsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    issn?: SortOrder
    hIndex?: SortOrder
    publisher?: SortOrder
    nation?: SortOrder
    scope?: SortOrder
    emailSubmission?: SortOrder
    creator?: SortOrder
    _count?: JournalsCountOrderByAggregateInput
    _avg?: JournalsAvgOrderByAggregateInput
    _max?: JournalsMaxOrderByAggregateInput
    _min?: JournalsMinOrderByAggregateInput
    _sum?: JournalsSumOrderByAggregateInput
  }

  export type JournalsScalarWhereWithAggregatesInput = {
    AND?: JournalsScalarWhereWithAggregatesInput | JournalsScalarWhereWithAggregatesInput[]
    OR?: JournalsScalarWhereWithAggregatesInput[]
    NOT?: JournalsScalarWhereWithAggregatesInput | JournalsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Journals"> | string
    name?: StringWithAggregatesFilter<"Journals"> | string
    issn?: StringWithAggregatesFilter<"Journals"> | string
    hIndex?: IntWithAggregatesFilter<"Journals"> | number
    publisher?: StringWithAggregatesFilter<"Journals"> | string
    nation?: StringWithAggregatesFilter<"Journals"> | string
    scope?: StringWithAggregatesFilter<"Journals"> | string
    emailSubmission?: StringWithAggregatesFilter<"Journals"> | string
    creator?: StringWithAggregatesFilter<"Journals"> | string
  }

  export type ConferenceFollowsWhereInput = {
    AND?: ConferenceFollowsWhereInput | ConferenceFollowsWhereInput[]
    OR?: ConferenceFollowsWhereInput[]
    NOT?: ConferenceFollowsWhereInput | ConferenceFollowsWhereInput[]
    id?: StringFilter<"ConferenceFollows"> | string
    conferenceId?: StringFilter<"ConferenceFollows"> | string
    userId?: StringFilter<"ConferenceFollows"> | string
    createdAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ConferenceFollowsOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    belongsTo?: ConferencesOrderByWithRelationInput
    byUser?: UsersOrderByWithRelationInput
  }

  export type ConferenceFollowsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conferenceId_userId?: ConferenceFollowsConferenceIdUserIdCompoundUniqueInput
    AND?: ConferenceFollowsWhereInput | ConferenceFollowsWhereInput[]
    OR?: ConferenceFollowsWhereInput[]
    NOT?: ConferenceFollowsWhereInput | ConferenceFollowsWhereInput[]
    conferenceId?: StringFilter<"ConferenceFollows"> | string
    userId?: StringFilter<"ConferenceFollows"> | string
    createdAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "conferenceId_userId">

  export type ConferenceFollowsOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceFollowsCountOrderByAggregateInput
    _max?: ConferenceFollowsMaxOrderByAggregateInput
    _min?: ConferenceFollowsMinOrderByAggregateInput
  }

  export type ConferenceFollowsScalarWhereWithAggregatesInput = {
    AND?: ConferenceFollowsScalarWhereWithAggregatesInput | ConferenceFollowsScalarWhereWithAggregatesInput[]
    OR?: ConferenceFollowsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceFollowsScalarWhereWithAggregatesInput | ConferenceFollowsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceFollows"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceFollows"> | string
    userId?: StringWithAggregatesFilter<"ConferenceFollows"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceFollows"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceFollows"> | Date | string
  }

  export type ConferenceLikesWhereInput = {
    AND?: ConferenceLikesWhereInput | ConferenceLikesWhereInput[]
    OR?: ConferenceLikesWhereInput[]
    NOT?: ConferenceLikesWhereInput | ConferenceLikesWhereInput[]
    id?: StringFilter<"ConferenceLikes"> | string
    conferenceId?: StringFilter<"ConferenceLikes"> | string
    userId?: StringFilter<"ConferenceLikes"> | string
    createdAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ConferenceLikesOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    belongsTo?: ConferencesOrderByWithRelationInput
    byUser?: UsersOrderByWithRelationInput
  }

  export type ConferenceLikesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conferenceId_userId?: ConferenceLikesConferenceIdUserIdCompoundUniqueInput
    AND?: ConferenceLikesWhereInput | ConferenceLikesWhereInput[]
    OR?: ConferenceLikesWhereInput[]
    NOT?: ConferenceLikesWhereInput | ConferenceLikesWhereInput[]
    conferenceId?: StringFilter<"ConferenceLikes"> | string
    userId?: StringFilter<"ConferenceLikes"> | string
    createdAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "conferenceId_userId">

  export type ConferenceLikesOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceLikesCountOrderByAggregateInput
    _max?: ConferenceLikesMaxOrderByAggregateInput
    _min?: ConferenceLikesMinOrderByAggregateInput
  }

  export type ConferenceLikesScalarWhereWithAggregatesInput = {
    AND?: ConferenceLikesScalarWhereWithAggregatesInput | ConferenceLikesScalarWhereWithAggregatesInput[]
    OR?: ConferenceLikesScalarWhereWithAggregatesInput[]
    NOT?: ConferenceLikesScalarWhereWithAggregatesInput | ConferenceLikesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceLikes"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceLikes"> | string
    userId?: StringWithAggregatesFilter<"ConferenceLikes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceLikes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceLikes"> | Date | string
  }

  export type ConferenceFeedbacksWhereInput = {
    AND?: ConferenceFeedbacksWhereInput | ConferenceFeedbacksWhereInput[]
    OR?: ConferenceFeedbacksWhereInput[]
    NOT?: ConferenceFeedbacksWhereInput | ConferenceFeedbacksWhereInput[]
    id?: StringFilter<"ConferenceFeedbacks"> | string
    conferenceId?: StringFilter<"ConferenceFeedbacks"> | string
    creatorId?: StringFilter<"ConferenceFeedbacks"> | string
    description?: StringFilter<"ConferenceFeedbacks"> | string
    star?: IntFilter<"ConferenceFeedbacks"> | number
    createdAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ConferenceFeedbacksOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    creatorId?: SortOrder
    description?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    belongsTo?: ConferencesOrderByWithRelationInput
    byUser?: UsersOrderByWithRelationInput
  }

  export type ConferenceFeedbacksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceFeedbacksWhereInput | ConferenceFeedbacksWhereInput[]
    OR?: ConferenceFeedbacksWhereInput[]
    NOT?: ConferenceFeedbacksWhereInput | ConferenceFeedbacksWhereInput[]
    conferenceId?: StringFilter<"ConferenceFeedbacks"> | string
    creatorId?: StringFilter<"ConferenceFeedbacks"> | string
    description?: StringFilter<"ConferenceFeedbacks"> | string
    star?: IntFilter<"ConferenceFeedbacks"> | number
    createdAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type ConferenceFeedbacksOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    creatorId?: SortOrder
    description?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceFeedbacksCountOrderByAggregateInput
    _avg?: ConferenceFeedbacksAvgOrderByAggregateInput
    _max?: ConferenceFeedbacksMaxOrderByAggregateInput
    _min?: ConferenceFeedbacksMinOrderByAggregateInput
    _sum?: ConferenceFeedbacksSumOrderByAggregateInput
  }

  export type ConferenceFeedbacksScalarWhereWithAggregatesInput = {
    AND?: ConferenceFeedbacksScalarWhereWithAggregatesInput | ConferenceFeedbacksScalarWhereWithAggregatesInput[]
    OR?: ConferenceFeedbacksScalarWhereWithAggregatesInput[]
    NOT?: ConferenceFeedbacksScalarWhereWithAggregatesInput | ConferenceFeedbacksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceFeedbacks"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceFeedbacks"> | string
    creatorId?: StringWithAggregatesFilter<"ConferenceFeedbacks"> | string
    description?: StringWithAggregatesFilter<"ConferenceFeedbacks"> | string
    star?: IntWithAggregatesFilter<"ConferenceFeedbacks"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceFeedbacks"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceFeedbacks"> | Date | string
  }

  export type ConferenceCalendarsWhereInput = {
    AND?: ConferenceCalendarsWhereInput | ConferenceCalendarsWhereInput[]
    OR?: ConferenceCalendarsWhereInput[]
    NOT?: ConferenceCalendarsWhereInput | ConferenceCalendarsWhereInput[]
    id?: StringFilter<"ConferenceCalendars"> | string
    conferenceId?: StringFilter<"ConferenceCalendars"> | string
    userId?: StringFilter<"ConferenceCalendars"> | string
    createdAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ConferenceCalendarsOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    belongsTo?: ConferencesOrderByWithRelationInput
    byUser?: UsersOrderByWithRelationInput
  }

  export type ConferenceCalendarsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conferenceId_userId?: ConferenceCalendarsConferenceIdUserIdCompoundUniqueInput
    AND?: ConferenceCalendarsWhereInput | ConferenceCalendarsWhereInput[]
    OR?: ConferenceCalendarsWhereInput[]
    NOT?: ConferenceCalendarsWhereInput | ConferenceCalendarsWhereInput[]
    conferenceId?: StringFilter<"ConferenceCalendars"> | string
    userId?: StringFilter<"ConferenceCalendars"> | string
    createdAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "conferenceId_userId">

  export type ConferenceCalendarsOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceCalendarsCountOrderByAggregateInput
    _max?: ConferenceCalendarsMaxOrderByAggregateInput
    _min?: ConferenceCalendarsMinOrderByAggregateInput
  }

  export type ConferenceCalendarsScalarWhereWithAggregatesInput = {
    AND?: ConferenceCalendarsScalarWhereWithAggregatesInput | ConferenceCalendarsScalarWhereWithAggregatesInput[]
    OR?: ConferenceCalendarsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceCalendarsScalarWhereWithAggregatesInput | ConferenceCalendarsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceCalendars"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceCalendars"> | string
    userId?: StringWithAggregatesFilter<"ConferenceCalendars"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceCalendars"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceCalendars"> | Date | string
  }

  export type JournalLikesWhereInput = {
    AND?: JournalLikesWhereInput | JournalLikesWhereInput[]
    OR?: JournalLikesWhereInput[]
    NOT?: JournalLikesWhereInput | JournalLikesWhereInput[]
    id?: StringFilter<"JournalLikes"> | string
    journalId?: StringFilter<"JournalLikes"> | string
    userId?: StringFilter<"JournalLikes"> | string
    createdAt?: DateTimeFilter<"JournalLikes"> | Date | string
    updatedAt?: DateTimeFilter<"JournalLikes"> | Date | string
    belongsTo?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type JournalLikesOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    belongsTo?: JournalsOrderByWithRelationInput
    byUser?: UsersOrderByWithRelationInput
  }

  export type JournalLikesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalLikesWhereInput | JournalLikesWhereInput[]
    OR?: JournalLikesWhereInput[]
    NOT?: JournalLikesWhereInput | JournalLikesWhereInput[]
    journalId?: StringFilter<"JournalLikes"> | string
    userId?: StringFilter<"JournalLikes"> | string
    createdAt?: DateTimeFilter<"JournalLikes"> | Date | string
    updatedAt?: DateTimeFilter<"JournalLikes"> | Date | string
    belongsTo?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type JournalLikesOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalLikesCountOrderByAggregateInput
    _max?: JournalLikesMaxOrderByAggregateInput
    _min?: JournalLikesMinOrderByAggregateInput
  }

  export type JournalLikesScalarWhereWithAggregatesInput = {
    AND?: JournalLikesScalarWhereWithAggregatesInput | JournalLikesScalarWhereWithAggregatesInput[]
    OR?: JournalLikesScalarWhereWithAggregatesInput[]
    NOT?: JournalLikesScalarWhereWithAggregatesInput | JournalLikesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalLikes"> | string
    journalId?: StringWithAggregatesFilter<"JournalLikes"> | string
    userId?: StringWithAggregatesFilter<"JournalLikes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JournalLikes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalLikes"> | Date | string
  }

  export type JournalFollowsWhereInput = {
    AND?: JournalFollowsWhereInput | JournalFollowsWhereInput[]
    OR?: JournalFollowsWhereInput[]
    NOT?: JournalFollowsWhereInput | JournalFollowsWhereInput[]
    id?: StringFilter<"JournalFollows"> | string
    journalId?: StringFilter<"JournalFollows"> | string
    userId?: StringFilter<"JournalFollows"> | string
    createdAt?: DateTimeFilter<"JournalFollows"> | Date | string
    updatedAt?: DateTimeFilter<"JournalFollows"> | Date | string
    belongsTo?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type JournalFollowsOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    belongsTo?: JournalsOrderByWithRelationInput
    byUser?: UsersOrderByWithRelationInput
  }

  export type JournalFollowsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalFollowsWhereInput | JournalFollowsWhereInput[]
    OR?: JournalFollowsWhereInput[]
    NOT?: JournalFollowsWhereInput | JournalFollowsWhereInput[]
    journalId?: StringFilter<"JournalFollows"> | string
    userId?: StringFilter<"JournalFollows"> | string
    createdAt?: DateTimeFilter<"JournalFollows"> | Date | string
    updatedAt?: DateTimeFilter<"JournalFollows"> | Date | string
    belongsTo?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
    byUser?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type JournalFollowsOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalFollowsCountOrderByAggregateInput
    _max?: JournalFollowsMaxOrderByAggregateInput
    _min?: JournalFollowsMinOrderByAggregateInput
  }

  export type JournalFollowsScalarWhereWithAggregatesInput = {
    AND?: JournalFollowsScalarWhereWithAggregatesInput | JournalFollowsScalarWhereWithAggregatesInput[]
    OR?: JournalFollowsScalarWhereWithAggregatesInput[]
    NOT?: JournalFollowsScalarWhereWithAggregatesInput | JournalFollowsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalFollows"> | string
    journalId?: StringWithAggregatesFilter<"JournalFollows"> | string
    userId?: StringWithAggregatesFilter<"JournalFollows"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JournalFollows"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalFollows"> | Date | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    firstName?: StringFilter<"Users"> | string
    lastName?: StringFilter<"Users"> | string
    dob?: DateTimeFilter<"Users"> | Date | string
    role?: StringFilter<"Users"> | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    followConference?: ConferenceFollowsListRelationFilter
    likes?: ConferenceLikesListRelationFilter
    calendar?: ConferenceCalendarsListRelationFilter
    createdConferences?: ConferencesListRelationFilter
    createdJournals?: JournalsListRelationFilter
    journalLikes?: JournalLikesListRelationFilter
    journalFollows?: JournalFollowsListRelationFilter
    feedbacks?: ConferenceFeedbacksListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    followConference?: ConferenceFollowsOrderByRelationAggregateInput
    likes?: ConferenceLikesOrderByRelationAggregateInput
    calendar?: ConferenceCalendarsOrderByRelationAggregateInput
    createdConferences?: ConferencesOrderByRelationAggregateInput
    createdJournals?: JournalsOrderByRelationAggregateInput
    journalLikes?: JournalLikesOrderByRelationAggregateInput
    journalFollows?: JournalFollowsOrderByRelationAggregateInput
    feedbacks?: ConferenceFeedbacksOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    password?: StringFilter<"Users"> | string
    firstName?: StringFilter<"Users"> | string
    lastName?: StringFilter<"Users"> | string
    dob?: DateTimeFilter<"Users"> | Date | string
    role?: StringFilter<"Users"> | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    followConference?: ConferenceFollowsListRelationFilter
    likes?: ConferenceLikesListRelationFilter
    calendar?: ConferenceCalendarsListRelationFilter
    createdConferences?: ConferencesListRelationFilter
    createdJournals?: JournalsListRelationFilter
    journalLikes?: JournalLikesListRelationFilter
    journalFollows?: JournalFollowsListRelationFilter
    feedbacks?: ConferenceFeedbacksListRelationFilter
  }, "id" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    firstName?: StringWithAggregatesFilter<"Users"> | string
    lastName?: StringWithAggregatesFilter<"Users"> | string
    dob?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    role?: StringWithAggregatesFilter<"Users"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
  }

  export type ConferenceCrawlJobsWhereInput = {
    AND?: ConferenceCrawlJobsWhereInput | ConferenceCrawlJobsWhereInput[]
    OR?: ConferenceCrawlJobsWhereInput[]
    NOT?: ConferenceCrawlJobsWhereInput | ConferenceCrawlJobsWhereInput[]
    id?: StringFilter<"ConferenceCrawlJobs"> | string
    conferenceId?: StringFilter<"ConferenceCrawlJobs"> | string
    status?: StringFilter<"ConferenceCrawlJobs"> | string
    progress?: IntFilter<"ConferenceCrawlJobs"> | number
    message?: StringFilter<"ConferenceCrawlJobs"> | string
    createdAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
  }

  export type ConferenceCrawlJobsOrderByWithRelationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    belongsTo?: ConferencesOrderByWithRelationInput
  }

  export type ConferenceCrawlJobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConferenceCrawlJobsWhereInput | ConferenceCrawlJobsWhereInput[]
    OR?: ConferenceCrawlJobsWhereInput[]
    NOT?: ConferenceCrawlJobsWhereInput | ConferenceCrawlJobsWhereInput[]
    conferenceId?: StringFilter<"ConferenceCrawlJobs"> | string
    status?: StringFilter<"ConferenceCrawlJobs"> | string
    progress?: IntFilter<"ConferenceCrawlJobs"> | number
    message?: StringFilter<"ConferenceCrawlJobs"> | string
    createdAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
    belongsTo?: XOR<ConferencesScalarRelationFilter, ConferencesWhereInput>
  }, "id">

  export type ConferenceCrawlJobsOrderByWithAggregationInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConferenceCrawlJobsCountOrderByAggregateInput
    _avg?: ConferenceCrawlJobsAvgOrderByAggregateInput
    _max?: ConferenceCrawlJobsMaxOrderByAggregateInput
    _min?: ConferenceCrawlJobsMinOrderByAggregateInput
    _sum?: ConferenceCrawlJobsSumOrderByAggregateInput
  }

  export type ConferenceCrawlJobsScalarWhereWithAggregatesInput = {
    AND?: ConferenceCrawlJobsScalarWhereWithAggregatesInput | ConferenceCrawlJobsScalarWhereWithAggregatesInput[]
    OR?: ConferenceCrawlJobsScalarWhereWithAggregatesInput[]
    NOT?: ConferenceCrawlJobsScalarWhereWithAggregatesInput | ConferenceCrawlJobsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConferenceCrawlJobs"> | string
    conferenceId?: StringWithAggregatesFilter<"ConferenceCrawlJobs"> | string
    status?: StringWithAggregatesFilter<"ConferenceCrawlJobs"> | string
    progress?: IntWithAggregatesFilter<"ConferenceCrawlJobs"> | number
    message?: StringWithAggregatesFilter<"ConferenceCrawlJobs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConferenceCrawlJobs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConferenceCrawlJobs"> | Date | string
  }

  export type JournalCrawlJobsWhereInput = {
    AND?: JournalCrawlJobsWhereInput | JournalCrawlJobsWhereInput[]
    OR?: JournalCrawlJobsWhereInput[]
    NOT?: JournalCrawlJobsWhereInput | JournalCrawlJobsWhereInput[]
    id?: StringFilter<"JournalCrawlJobs"> | string
    journalId?: StringFilter<"JournalCrawlJobs"> | string
    status?: StringFilter<"JournalCrawlJobs"> | string
    progress?: IntFilter<"JournalCrawlJobs"> | number
    message?: StringFilter<"JournalCrawlJobs"> | string
    createdAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
    belongsTo?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
  }

  export type JournalCrawlJobsOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    belongsTo?: JournalsOrderByWithRelationInput
  }

  export type JournalCrawlJobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalCrawlJobsWhereInput | JournalCrawlJobsWhereInput[]
    OR?: JournalCrawlJobsWhereInput[]
    NOT?: JournalCrawlJobsWhereInput | JournalCrawlJobsWhereInput[]
    journalId?: StringFilter<"JournalCrawlJobs"> | string
    status?: StringFilter<"JournalCrawlJobs"> | string
    progress?: IntFilter<"JournalCrawlJobs"> | number
    message?: StringFilter<"JournalCrawlJobs"> | string
    createdAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
    belongsTo?: XOR<JournalsScalarRelationFilter, JournalsWhereInput>
  }, "id">

  export type JournalCrawlJobsOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalCrawlJobsCountOrderByAggregateInput
    _avg?: JournalCrawlJobsAvgOrderByAggregateInput
    _max?: JournalCrawlJobsMaxOrderByAggregateInput
    _min?: JournalCrawlJobsMinOrderByAggregateInput
    _sum?: JournalCrawlJobsSumOrderByAggregateInput
  }

  export type JournalCrawlJobsScalarWhereWithAggregatesInput = {
    AND?: JournalCrawlJobsScalarWhereWithAggregatesInput | JournalCrawlJobsScalarWhereWithAggregatesInput[]
    OR?: JournalCrawlJobsScalarWhereWithAggregatesInput[]
    NOT?: JournalCrawlJobsScalarWhereWithAggregatesInput | JournalCrawlJobsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalCrawlJobs"> | string
    journalId?: StringWithAggregatesFilter<"JournalCrawlJobs"> | string
    status?: StringWithAggregatesFilter<"JournalCrawlJobs"> | string
    progress?: IntWithAggregatesFilter<"JournalCrawlJobs"> | number
    message?: StringWithAggregatesFilter<"JournalCrawlJobs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JournalCrawlJobs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalCrawlJobs"> | Date | string
  }

  export type PassengerCreateInput = {
    id?: string
    firstName: string
    lastName: string
  }

  export type PassengerUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
  }

  export type PassengerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
  }

  export type PassengerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
  }

  export type PassengerCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
  }

  export type PassengerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
  }

  export type PassengerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
  }

  export type LocationsCreateInput = {
    id?: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
    belongsTo: ConferenceOrganizationsCreateNestedOneWithoutLocationsInput
  }

  export type LocationsUncheckedCreateInput = {
    id?: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
    organizeId: string
  }

  export type LocationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    belongsTo?: ConferenceOrganizationsUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    organizeId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationsCreateManyInput = {
    id?: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
    organizeId: string
  }

  export type LocationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    organizeId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceDatesCreateInput = {
    id?: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
    belongsTo: ConferenceOrganizationsCreateNestedOneWithoutConferenceDatesInput
  }

  export type ConferenceDatesUncheckedCreateInput = {
    id?: string
    organizedId: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
  }

  export type ConferenceDatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    belongsTo?: ConferenceOrganizationsUpdateOneRequiredWithoutConferenceDatesNestedInput
  }

  export type ConferenceDatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizedId?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceDatesCreateManyInput = {
    id?: string
    organizedId: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
  }

  export type ConferenceDatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceDatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizedId?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceOrganizationsCreateInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conferenceDates?: ConferenceDatesCreateNestedManyWithoutBelongsToInput
    locations?: LocationsCreateNestedManyWithoutBelongsToInput
    topics?: ConferenceTopicsCreateNestedManyWithoutBelongsToInput
    belongsTo: ConferencesCreateNestedOneWithoutOrganizationsInput
  }

  export type ConferenceOrganizationsUncheckedCreateInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conferenceDates?: ConferenceDatesUncheckedCreateNestedManyWithoutBelongsToInput
    locations?: LocationsUncheckedCreateNestedManyWithoutBelongsToInput
    topics?: ConferenceTopicsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferenceOrganizationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferenceDates?: ConferenceDatesUpdateManyWithoutBelongsToNestedInput
    locations?: LocationsUpdateManyWithoutBelongsToNestedInput
    topics?: ConferenceTopicsUpdateManyWithoutBelongsToNestedInput
    belongsTo?: ConferencesUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    conferenceId?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferenceDates?: ConferenceDatesUncheckedUpdateManyWithoutBelongsToNestedInput
    locations?: LocationsUncheckedUpdateManyWithoutBelongsToNestedInput
    topics?: ConferenceTopicsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferenceOrganizationsCreateManyInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceOrganizationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceOrganizationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    conferenceId?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceTopicsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferenceOrganizationsCreateNestedOneWithoutTopicsInput
    inTopic: TopicsCreateNestedOneWithoutInConferenceTopicsInput
  }

  export type ConferenceTopicsUncheckedCreateInput = {
    id?: string
    organizeId: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceTopicsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferenceOrganizationsUpdateOneRequiredWithoutTopicsNestedInput
    inTopic?: TopicsUpdateOneRequiredWithoutInConferenceTopicsNestedInput
  }

  export type ConferenceTopicsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizeId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceTopicsCreateManyInput = {
    id?: string
    organizeId: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceTopicsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceTopicsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizeId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inConferenceTopics?: ConferenceTopicsCreateNestedManyWithoutInTopicInput
    inJournalTopics?: JournalTopicsCreateNestedManyWithoutBelongsToTopicsInput
  }

  export type TopicsUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inConferenceTopics?: ConferenceTopicsUncheckedCreateNestedManyWithoutInTopicInput
    inJournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutBelongsToTopicsInput
  }

  export type TopicsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inConferenceTopics?: ConferenceTopicsUpdateManyWithoutInTopicNestedInput
    inJournalTopics?: JournalTopicsUpdateManyWithoutBelongsToTopicsNestedInput
  }

  export type TopicsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inConferenceTopics?: ConferenceTopicsUncheckedUpdateManyWithoutInTopicNestedInput
    inJournalTopics?: JournalTopicsUncheckedUpdateManyWithoutBelongsToTopicsNestedInput
  }

  export type TopicsCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferencesCreateInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedConferencesInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesUncheckedCreateInput = {
    id?: string
    title: string
    acronym: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedConferencesNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferencesCreateManyInput = {
    id?: string
    title: string
    acronym: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
  }

  export type ConferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksCreateInput = {
    id?: string
    year: number
    inFieldOfResearch: FieldOfResearchsCreateNestedOneWithoutConferenceRanksInput
    byRank: RanksCreateNestedOneWithoutConferenceRanksInput
    belongsTo: ConferencesCreateNestedOneWithoutRanksInput
  }

  export type ConferenceRanksUncheckedCreateInput = {
    id?: string
    year: number
    conferenceId: string
    fieldOfResearchId: string
    rankId: string
  }

  export type ConferenceRanksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    inFieldOfResearch?: FieldOfResearchsUpdateOneRequiredWithoutConferenceRanksNestedInput
    byRank?: RanksUpdateOneRequiredWithoutConferenceRanksNestedInput
    belongsTo?: ConferencesUpdateOneRequiredWithoutRanksNestedInput
  }

  export type ConferenceRanksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksCreateManyInput = {
    id?: string
    year: number
    conferenceId: string
    fieldOfResearchId: string
    rankId: string
  }

  export type ConferenceRanksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type ConferenceRanksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type FieldOfResearchsCreateInput = {
    id?: string
    name: string
    code: string
    journalRanks?: JournalRanksCreateNestedManyWithoutInFieldOfResearchInput
    conferenceRanks?: ConferenceRanksCreateNestedManyWithoutInFieldOfResearchInput
  }

  export type FieldOfResearchsUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutInFieldOfResearchInput
    conferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutInFieldOfResearchInput
  }

  export type FieldOfResearchsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    journalRanks?: JournalRanksUpdateManyWithoutInFieldOfResearchNestedInput
    conferenceRanks?: ConferenceRanksUpdateManyWithoutInFieldOfResearchNestedInput
  }

  export type FieldOfResearchsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutInFieldOfResearchNestedInput
    conferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutInFieldOfResearchNestedInput
  }

  export type FieldOfResearchsCreateManyInput = {
    id?: string
    name: string
    code: string
  }

  export type FieldOfResearchsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type FieldOfResearchsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type RanksCreateInput = {
    id?: string
    name: string
    value: number
    conferenceRanks?: ConferenceRanksCreateNestedManyWithoutByRankInput
    journalRanks?: JournalRanksCreateNestedManyWithoutByRankInput
    belongsToSource: SourcesCreateNestedOneWithoutRanksInput
  }

  export type RanksUncheckedCreateInput = {
    id?: string
    name: string
    value: number
    sourceId: string
    conferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutByRankInput
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutByRankInput
  }

  export type RanksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    conferenceRanks?: ConferenceRanksUpdateManyWithoutByRankNestedInput
    journalRanks?: JournalRanksUpdateManyWithoutByRankNestedInput
    belongsToSource?: SourcesUpdateOneRequiredWithoutRanksNestedInput
  }

  export type RanksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
    conferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutByRankNestedInput
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutByRankNestedInput
  }

  export type RanksCreateManyInput = {
    id?: string
    name: string
    value: number
    sourceId: string
  }

  export type RanksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RanksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
  }

  export type SourcesCreateInput = {
    id?: string
    name: string
    link?: string | null
    ranks?: RanksCreateNestedManyWithoutBelongsToSourceInput
  }

  export type SourcesUncheckedCreateInput = {
    id?: string
    name: string
    link?: string | null
    ranks?: RanksUncheckedCreateNestedManyWithoutBelongsToSourceInput
  }

  export type SourcesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    ranks?: RanksUpdateManyWithoutBelongsToSourceNestedInput
  }

  export type SourcesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    ranks?: RanksUncheckedUpdateManyWithoutBelongsToSourceNestedInput
  }

  export type SourcesCreateManyInput = {
    id?: string
    name: string
    link?: string | null
  }

  export type SourcesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourcesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalTopicsCreateInput = {
    id?: string
    belongsToTopics: TopicsCreateNestedOneWithoutInJournalTopicsInput
    inJournals: JournalsCreateNestedOneWithoutTopicsInput
  }

  export type JournalTopicsUncheckedCreateInput = {
    id?: string
    journalId: string
    topicId: string
  }

  export type JournalTopicsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    belongsToTopics?: TopicsUpdateOneRequiredWithoutInJournalTopicsNestedInput
    inJournals?: JournalsUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type JournalTopicsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalTopicsCreateManyInput = {
    id?: string
    journalId: string
    topicId: string
  }

  export type JournalTopicsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type JournalTopicsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksCreateInput = {
    id?: string
    year: number
    inFieldOfResearch: FieldOfResearchsCreateNestedOneWithoutJournalRanksInput
    byRank: RanksCreateNestedOneWithoutJournalRanksInput
    belongsTo: JournalsCreateNestedOneWithoutJournalRanksInput
  }

  export type JournalRanksUncheckedCreateInput = {
    id?: string
    year: number
    journalId: string
    fieldOfResearchId: string
    rankId: string
  }

  export type JournalRanksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    inFieldOfResearch?: FieldOfResearchsUpdateOneRequiredWithoutJournalRanksNestedInput
    byRank?: RanksUpdateOneRequiredWithoutJournalRanksNestedInput
    belongsTo?: JournalsUpdateOneRequiredWithoutJournalRanksNestedInput
  }

  export type JournalRanksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksCreateManyInput = {
    id?: string
    year: number
    journalId: string
    fieldOfResearchId: string
    rankId: string
  }

  export type JournalRanksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type JournalRanksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalsCreateInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    topics?: JournalTopicsCreateNestedManyWithoutInJournalsInput
    journalRanks?: JournalRanksCreateNestedManyWithoutBelongsToInput
    journalLikes?: JournalLikesCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedJournalsInput
  }

  export type JournalsUncheckedCreateInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    topics?: JournalTopicsUncheckedCreateNestedManyWithoutInJournalsInput
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutBelongsToInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type JournalsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUpdateManyWithoutInJournalsNestedInput
    journalRanks?: JournalRanksUpdateManyWithoutBelongsToNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedJournalsNestedInput
  }

  export type JournalsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUncheckedUpdateManyWithoutInJournalsNestedInput
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type JournalsCreateManyInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
  }

  export type JournalsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
  }

  export type JournalsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceFollowsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferencesCreateNestedOneWithoutFollowsInput
    byUser: UsersCreateNestedOneWithoutFollowConferenceInput
  }

  export type ConferenceFollowsUncheckedCreateInput = {
    id?: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFollowsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferencesUpdateOneRequiredWithoutFollowsNestedInput
    byUser?: UsersUpdateOneRequiredWithoutFollowConferenceNestedInput
  }

  export type ConferenceFollowsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsCreateManyInput = {
    id?: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFollowsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferencesCreateNestedOneWithoutLikesInput
    byUser: UsersCreateNestedOneWithoutLikesInput
  }

  export type ConferenceLikesUncheckedCreateInput = {
    id?: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceLikesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferencesUpdateOneRequiredWithoutLikesNestedInput
    byUser?: UsersUpdateOneRequiredWithoutLikesNestedInput
  }

  export type ConferenceLikesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesCreateManyInput = {
    id?: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceLikesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksCreateInput = {
    id?: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferencesCreateNestedOneWithoutFeedbacksInput
    byUser: UsersCreateNestedOneWithoutFeedbacksInput
  }

  export type ConferenceFeedbacksUncheckedCreateInput = {
    id?: string
    conferenceId: string
    creatorId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFeedbacksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferencesUpdateOneRequiredWithoutFeedbacksNestedInput
    byUser?: UsersUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type ConferenceFeedbacksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksCreateManyInput = {
    id?: string
    conferenceId: string
    creatorId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFeedbacksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferencesCreateNestedOneWithoutCalendarsInput
    byUser: UsersCreateNestedOneWithoutCalendarInput
  }

  export type ConferenceCalendarsUncheckedCreateInput = {
    id?: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceCalendarsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferencesUpdateOneRequiredWithoutCalendarsNestedInput
    byUser?: UsersUpdateOneRequiredWithoutCalendarNestedInput
  }

  export type ConferenceCalendarsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsCreateManyInput = {
    id?: string
    conferenceId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceCalendarsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: JournalsCreateNestedOneWithoutJournalLikesInput
    byUser: UsersCreateNestedOneWithoutJournalLikesInput
  }

  export type JournalLikesUncheckedCreateInput = {
    id?: string
    journalId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalLikesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: JournalsUpdateOneRequiredWithoutJournalLikesNestedInput
    byUser?: UsersUpdateOneRequiredWithoutJournalLikesNestedInput
  }

  export type JournalLikesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesCreateManyInput = {
    id?: string
    journalId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalLikesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: JournalsCreateNestedOneWithoutJournalFollowsInput
    byUser: UsersCreateNestedOneWithoutJournalFollowsInput
  }

  export type JournalFollowsUncheckedCreateInput = {
    id?: string
    journalId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalFollowsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: JournalsUpdateOneRequiredWithoutJournalFollowsNestedInput
    byUser?: UsersUpdateOneRequiredWithoutJournalFollowsNestedInput
  }

  export type JournalFollowsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsCreateManyInput = {
    id?: string
    journalId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalFollowsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutByUserInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsUncheckedCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsUncheckedCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsUncheckedCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutByUserInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutByUserNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUncheckedUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUncheckedUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutByUserNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsCreateInput = {
    id?: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferencesCreateNestedOneWithoutCrawlJobsInput
  }

  export type ConferenceCrawlJobsUncheckedCreateInput = {
    id?: string
    conferenceId: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceCrawlJobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferencesUpdateOneRequiredWithoutCrawlJobsNestedInput
  }

  export type ConferenceCrawlJobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsCreateManyInput = {
    id?: string
    conferenceId: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceCrawlJobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCrawlJobsCreateInput = {
    id?: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: JournalsCreateNestedOneWithoutCrawlJobsInput
  }

  export type JournalCrawlJobsUncheckedCreateInput = {
    id?: string
    journalId: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalCrawlJobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: JournalsUpdateOneRequiredWithoutCrawlJobsNestedInput
  }

  export type JournalCrawlJobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCrawlJobsCreateManyInput = {
    id?: string
    journalId: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalCrawlJobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCrawlJobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type PassengerCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type PassengerMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type PassengerMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ConferenceOrganizationsScalarRelationFilter = {
    is?: ConferenceOrganizationsWhereInput
    isNot?: ConferenceOrganizationsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LocationsCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityStateProvince?: SortOrder
    country?: SortOrder
    continent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    organizeId?: SortOrder
  }

  export type LocationsMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityStateProvince?: SortOrder
    country?: SortOrder
    continent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    organizeId?: SortOrder
  }

  export type LocationsMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityStateProvince?: SortOrder
    country?: SortOrder
    continent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
    organizeId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ConferenceDatesCountOrderByAggregateInput = {
    id?: SortOrder
    organizedId?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
  }

  export type ConferenceDatesMaxOrderByAggregateInput = {
    id?: SortOrder
    organizedId?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
  }

  export type ConferenceDatesMinOrderByAggregateInput = {
    id?: SortOrder
    organizedId?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAvailable?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ConferenceDatesListRelationFilter = {
    every?: ConferenceDatesWhereInput
    some?: ConferenceDatesWhereInput
    none?: ConferenceDatesWhereInput
  }

  export type LocationsListRelationFilter = {
    every?: LocationsWhereInput
    some?: LocationsWhereInput
    none?: LocationsWhereInput
  }

  export type ConferenceTopicsListRelationFilter = {
    every?: ConferenceTopicsWhereInput
    some?: ConferenceTopicsWhereInput
    none?: ConferenceTopicsWhereInput
  }

  export type ConferencesScalarRelationFilter = {
    is?: ConferencesWhereInput
    isNot?: ConferencesWhereInput
  }

  export type ConferenceDatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceTopicsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceOrganizationsCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    accessType?: SortOrder
    isAvailable?: SortOrder
    conferenceId?: SortOrder
    publisher?: SortOrder
    summerize?: SortOrder
    callForPaper?: SortOrder
    link?: SortOrder
    cfpLink?: SortOrder
    impLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceOrganizationsAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type ConferenceOrganizationsMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    accessType?: SortOrder
    isAvailable?: SortOrder
    conferenceId?: SortOrder
    publisher?: SortOrder
    summerize?: SortOrder
    callForPaper?: SortOrder
    link?: SortOrder
    cfpLink?: SortOrder
    impLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceOrganizationsMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    accessType?: SortOrder
    isAvailable?: SortOrder
    conferenceId?: SortOrder
    publisher?: SortOrder
    summerize?: SortOrder
    callForPaper?: SortOrder
    link?: SortOrder
    cfpLink?: SortOrder
    impLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceOrganizationsSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TopicsScalarRelationFilter = {
    is?: TopicsWhereInput
    isNot?: TopicsWhereInput
  }

  export type ConferenceTopicsCountOrderByAggregateInput = {
    id?: SortOrder
    organizeId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceTopicsMaxOrderByAggregateInput = {
    id?: SortOrder
    organizeId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceTopicsMinOrderByAggregateInput = {
    id?: SortOrder
    organizeId?: SortOrder
    topicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalTopicsListRelationFilter = {
    every?: JournalTopicsWhereInput
    some?: JournalTopicsWhereInput
    none?: JournalTopicsWhereInput
  }

  export type JournalTopicsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFollowsListRelationFilter = {
    every?: ConferenceFollowsWhereInput
    some?: ConferenceFollowsWhereInput
    none?: ConferenceFollowsWhereInput
  }

  export type ConferenceLikesListRelationFilter = {
    every?: ConferenceLikesWhereInput
    some?: ConferenceLikesWhereInput
    none?: ConferenceLikesWhereInput
  }

  export type ConferenceCalendarsListRelationFilter = {
    every?: ConferenceCalendarsWhereInput
    some?: ConferenceCalendarsWhereInput
    none?: ConferenceCalendarsWhereInput
  }

  export type ConferenceOrganizationsListRelationFilter = {
    every?: ConferenceOrganizationsWhereInput
    some?: ConferenceOrganizationsWhereInput
    none?: ConferenceOrganizationsWhereInput
  }

  export type ConferenceRanksListRelationFilter = {
    every?: ConferenceRanksWhereInput
    some?: ConferenceRanksWhereInput
    none?: ConferenceRanksWhereInput
  }

  export type ConferenceCrawlJobsListRelationFilter = {
    every?: ConferenceCrawlJobsWhereInput
    some?: ConferenceCrawlJobsWhereInput
    none?: ConferenceCrawlJobsWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type ConferenceFeedbacksListRelationFilter = {
    every?: ConferenceFeedbacksWhereInput
    some?: ConferenceFeedbacksWhereInput
    none?: ConferenceFeedbacksWhereInput
  }

  export type ConferenceFollowsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceLikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceCalendarsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceOrganizationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceRanksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceCrawlJobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferenceFeedbacksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConferencesTitleAcronymCompoundUniqueInput = {
    title: string
    acronym: string
  }

  export type ConferencesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    acronym?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ConferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    acronym?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ConferencesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    acronym?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type FieldOfResearchsScalarRelationFilter = {
    is?: FieldOfResearchsWhereInput
    isNot?: FieldOfResearchsWhereInput
  }

  export type RanksScalarRelationFilter = {
    is?: RanksWhereInput
    isNot?: RanksWhereInput
  }

  export type ConferenceRanksCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    conferenceId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type ConferenceRanksAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type ConferenceRanksMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    conferenceId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type ConferenceRanksMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    conferenceId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type ConferenceRanksSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type JournalRanksListRelationFilter = {
    every?: JournalRanksWhereInput
    some?: JournalRanksWhereInput
    none?: JournalRanksWhereInput
  }

  export type JournalRanksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldOfResearchsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type FieldOfResearchsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type FieldOfResearchsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type SourcesScalarRelationFilter = {
    is?: SourcesWhereInput
    isNot?: SourcesWhereInput
  }

  export type RanksCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    sourceId?: SortOrder
  }

  export type RanksAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type RanksMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    sourceId?: SortOrder
  }

  export type RanksMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    sourceId?: SortOrder
  }

  export type RanksSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type RanksListRelationFilter = {
    every?: RanksWhereInput
    some?: RanksWhereInput
    none?: RanksWhereInput
  }

  export type RanksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourcesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
  }

  export type SourcesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
  }

  export type SourcesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
  }

  export type JournalsScalarRelationFilter = {
    is?: JournalsWhereInput
    isNot?: JournalsWhereInput
  }

  export type JournalTopicsCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    topicId?: SortOrder
  }

  export type JournalTopicsMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    topicId?: SortOrder
  }

  export type JournalTopicsMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    topicId?: SortOrder
  }

  export type JournalRanksCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    journalId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type JournalRanksAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type JournalRanksMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    journalId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type JournalRanksMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    journalId?: SortOrder
    fieldOfResearchId?: SortOrder
    rankId?: SortOrder
  }

  export type JournalRanksSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type JournalLikesListRelationFilter = {
    every?: JournalLikesWhereInput
    some?: JournalLikesWhereInput
    none?: JournalLikesWhereInput
  }

  export type JournalFollowsListRelationFilter = {
    every?: JournalFollowsWhereInput
    some?: JournalFollowsWhereInput
    none?: JournalFollowsWhereInput
  }

  export type JournalCrawlJobsListRelationFilter = {
    every?: JournalCrawlJobsWhereInput
    some?: JournalCrawlJobsWhereInput
    none?: JournalCrawlJobsWhereInput
  }

  export type JournalLikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalFollowsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalCrawlJobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    issn?: SortOrder
    hIndex?: SortOrder
    publisher?: SortOrder
    nation?: SortOrder
    scope?: SortOrder
    emailSubmission?: SortOrder
    creator?: SortOrder
  }

  export type JournalsAvgOrderByAggregateInput = {
    hIndex?: SortOrder
  }

  export type JournalsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    issn?: SortOrder
    hIndex?: SortOrder
    publisher?: SortOrder
    nation?: SortOrder
    scope?: SortOrder
    emailSubmission?: SortOrder
    creator?: SortOrder
  }

  export type JournalsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    issn?: SortOrder
    hIndex?: SortOrder
    publisher?: SortOrder
    nation?: SortOrder
    scope?: SortOrder
    emailSubmission?: SortOrder
    creator?: SortOrder
  }

  export type JournalsSumOrderByAggregateInput = {
    hIndex?: SortOrder
  }

  export type ConferenceFollowsConferenceIdUserIdCompoundUniqueInput = {
    conferenceId: string
    userId: string
  }

  export type ConferenceFollowsCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFollowsMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFollowsMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceLikesConferenceIdUserIdCompoundUniqueInput = {
    conferenceId: string
    userId: string
  }

  export type ConferenceLikesCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceLikesMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceLikesMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFeedbacksCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    creatorId?: SortOrder
    description?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFeedbacksAvgOrderByAggregateInput = {
    star?: SortOrder
  }

  export type ConferenceFeedbacksMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    creatorId?: SortOrder
    description?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFeedbacksMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    creatorId?: SortOrder
    description?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceFeedbacksSumOrderByAggregateInput = {
    star?: SortOrder
  }

  export type ConferenceCalendarsConferenceIdUserIdCompoundUniqueInput = {
    conferenceId: string
    userId: string
  }

  export type ConferenceCalendarsCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCalendarsMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCalendarsMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalLikesCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalLikesMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalLikesMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalFollowsCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalFollowsMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalFollowsMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferencesListRelationFilter = {
    every?: ConferencesWhereInput
    some?: ConferencesWhereInput
    none?: ConferencesWhereInput
  }

  export type JournalsListRelationFilter = {
    every?: JournalsWhereInput
    some?: JournalsWhereInput
    none?: JournalsWhereInput
  }

  export type ConferencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCrawlJobsCountOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCrawlJobsAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type ConferenceCrawlJobsMaxOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCrawlJobsMinOrderByAggregateInput = {
    id?: SortOrder
    conferenceId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConferenceCrawlJobsSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type JournalCrawlJobsCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalCrawlJobsAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type JournalCrawlJobsMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalCrawlJobsMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalCrawlJobsSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ConferenceOrganizationsCreateNestedOneWithoutLocationsInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutLocationsInput, ConferenceOrganizationsUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutLocationsInput
    connect?: ConferenceOrganizationsWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ConferenceOrganizationsUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutLocationsInput, ConferenceOrganizationsUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutLocationsInput
    upsert?: ConferenceOrganizationsUpsertWithoutLocationsInput
    connect?: ConferenceOrganizationsWhereUniqueInput
    update?: XOR<XOR<ConferenceOrganizationsUpdateToOneWithWhereWithoutLocationsInput, ConferenceOrganizationsUpdateWithoutLocationsInput>, ConferenceOrganizationsUncheckedUpdateWithoutLocationsInput>
  }

  export type ConferenceOrganizationsCreateNestedOneWithoutConferenceDatesInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceDatesInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutConferenceDatesInput
    connect?: ConferenceOrganizationsWhereUniqueInput
  }

  export type ConferenceOrganizationsUpdateOneRequiredWithoutConferenceDatesNestedInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceDatesInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutConferenceDatesInput
    upsert?: ConferenceOrganizationsUpsertWithoutConferenceDatesInput
    connect?: ConferenceOrganizationsWhereUniqueInput
    update?: XOR<XOR<ConferenceOrganizationsUpdateToOneWithWhereWithoutConferenceDatesInput, ConferenceOrganizationsUpdateWithoutConferenceDatesInput>, ConferenceOrganizationsUncheckedUpdateWithoutConferenceDatesInput>
  }

  export type ConferenceDatesCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceDatesCreateWithoutBelongsToInput, ConferenceDatesUncheckedCreateWithoutBelongsToInput> | ConferenceDatesCreateWithoutBelongsToInput[] | ConferenceDatesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceDatesCreateOrConnectWithoutBelongsToInput | ConferenceDatesCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceDatesCreateManyBelongsToInputEnvelope
    connect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
  }

  export type LocationsCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<LocationsCreateWithoutBelongsToInput, LocationsUncheckedCreateWithoutBelongsToInput> | LocationsCreateWithoutBelongsToInput[] | LocationsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: LocationsCreateOrConnectWithoutBelongsToInput | LocationsCreateOrConnectWithoutBelongsToInput[]
    createMany?: LocationsCreateManyBelongsToInputEnvelope
    connect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
  }

  export type ConferenceTopicsCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceTopicsCreateWithoutBelongsToInput, ConferenceTopicsUncheckedCreateWithoutBelongsToInput> | ConferenceTopicsCreateWithoutBelongsToInput[] | ConferenceTopicsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutBelongsToInput | ConferenceTopicsCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceTopicsCreateManyBelongsToInputEnvelope
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
  }

  export type ConferencesCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<ConferencesCreateWithoutOrganizationsInput, ConferencesUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutOrganizationsInput
    connect?: ConferencesWhereUniqueInput
  }

  export type ConferenceDatesUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceDatesCreateWithoutBelongsToInput, ConferenceDatesUncheckedCreateWithoutBelongsToInput> | ConferenceDatesCreateWithoutBelongsToInput[] | ConferenceDatesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceDatesCreateOrConnectWithoutBelongsToInput | ConferenceDatesCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceDatesCreateManyBelongsToInputEnvelope
    connect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
  }

  export type LocationsUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<LocationsCreateWithoutBelongsToInput, LocationsUncheckedCreateWithoutBelongsToInput> | LocationsCreateWithoutBelongsToInput[] | LocationsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: LocationsCreateOrConnectWithoutBelongsToInput | LocationsCreateOrConnectWithoutBelongsToInput[]
    createMany?: LocationsCreateManyBelongsToInputEnvelope
    connect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
  }

  export type ConferenceTopicsUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceTopicsCreateWithoutBelongsToInput, ConferenceTopicsUncheckedCreateWithoutBelongsToInput> | ConferenceTopicsCreateWithoutBelongsToInput[] | ConferenceTopicsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutBelongsToInput | ConferenceTopicsCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceTopicsCreateManyBelongsToInputEnvelope
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConferenceDatesUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceDatesCreateWithoutBelongsToInput, ConferenceDatesUncheckedCreateWithoutBelongsToInput> | ConferenceDatesCreateWithoutBelongsToInput[] | ConferenceDatesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceDatesCreateOrConnectWithoutBelongsToInput | ConferenceDatesCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceDatesUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceDatesUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceDatesCreateManyBelongsToInputEnvelope
    set?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    disconnect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    delete?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    connect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    update?: ConferenceDatesUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceDatesUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceDatesUpdateManyWithWhereWithoutBelongsToInput | ConferenceDatesUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceDatesScalarWhereInput | ConferenceDatesScalarWhereInput[]
  }

  export type LocationsUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<LocationsCreateWithoutBelongsToInput, LocationsUncheckedCreateWithoutBelongsToInput> | LocationsCreateWithoutBelongsToInput[] | LocationsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: LocationsCreateOrConnectWithoutBelongsToInput | LocationsCreateOrConnectWithoutBelongsToInput[]
    upsert?: LocationsUpsertWithWhereUniqueWithoutBelongsToInput | LocationsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: LocationsCreateManyBelongsToInputEnvelope
    set?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    disconnect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    delete?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    connect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    update?: LocationsUpdateWithWhereUniqueWithoutBelongsToInput | LocationsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: LocationsUpdateManyWithWhereWithoutBelongsToInput | LocationsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: LocationsScalarWhereInput | LocationsScalarWhereInput[]
  }

  export type ConferenceTopicsUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceTopicsCreateWithoutBelongsToInput, ConferenceTopicsUncheckedCreateWithoutBelongsToInput> | ConferenceTopicsCreateWithoutBelongsToInput[] | ConferenceTopicsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutBelongsToInput | ConferenceTopicsCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceTopicsUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceTopicsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceTopicsCreateManyBelongsToInputEnvelope
    set?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    disconnect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    delete?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    update?: ConferenceTopicsUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceTopicsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceTopicsUpdateManyWithWhereWithoutBelongsToInput | ConferenceTopicsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
  }

  export type ConferencesUpdateOneRequiredWithoutOrganizationsNestedInput = {
    create?: XOR<ConferencesCreateWithoutOrganizationsInput, ConferencesUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutOrganizationsInput
    upsert?: ConferencesUpsertWithoutOrganizationsInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutOrganizationsInput, ConferencesUpdateWithoutOrganizationsInput>, ConferencesUncheckedUpdateWithoutOrganizationsInput>
  }

  export type ConferenceDatesUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceDatesCreateWithoutBelongsToInput, ConferenceDatesUncheckedCreateWithoutBelongsToInput> | ConferenceDatesCreateWithoutBelongsToInput[] | ConferenceDatesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceDatesCreateOrConnectWithoutBelongsToInput | ConferenceDatesCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceDatesUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceDatesUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceDatesCreateManyBelongsToInputEnvelope
    set?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    disconnect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    delete?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    connect?: ConferenceDatesWhereUniqueInput | ConferenceDatesWhereUniqueInput[]
    update?: ConferenceDatesUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceDatesUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceDatesUpdateManyWithWhereWithoutBelongsToInput | ConferenceDatesUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceDatesScalarWhereInput | ConferenceDatesScalarWhereInput[]
  }

  export type LocationsUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<LocationsCreateWithoutBelongsToInput, LocationsUncheckedCreateWithoutBelongsToInput> | LocationsCreateWithoutBelongsToInput[] | LocationsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: LocationsCreateOrConnectWithoutBelongsToInput | LocationsCreateOrConnectWithoutBelongsToInput[]
    upsert?: LocationsUpsertWithWhereUniqueWithoutBelongsToInput | LocationsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: LocationsCreateManyBelongsToInputEnvelope
    set?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    disconnect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    delete?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    connect?: LocationsWhereUniqueInput | LocationsWhereUniqueInput[]
    update?: LocationsUpdateWithWhereUniqueWithoutBelongsToInput | LocationsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: LocationsUpdateManyWithWhereWithoutBelongsToInput | LocationsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: LocationsScalarWhereInput | LocationsScalarWhereInput[]
  }

  export type ConferenceTopicsUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceTopicsCreateWithoutBelongsToInput, ConferenceTopicsUncheckedCreateWithoutBelongsToInput> | ConferenceTopicsCreateWithoutBelongsToInput[] | ConferenceTopicsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutBelongsToInput | ConferenceTopicsCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceTopicsUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceTopicsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceTopicsCreateManyBelongsToInputEnvelope
    set?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    disconnect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    delete?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    update?: ConferenceTopicsUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceTopicsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceTopicsUpdateManyWithWhereWithoutBelongsToInput | ConferenceTopicsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
  }

  export type ConferenceOrganizationsCreateNestedOneWithoutTopicsInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutTopicsInput, ConferenceOrganizationsUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutTopicsInput
    connect?: ConferenceOrganizationsWhereUniqueInput
  }

  export type TopicsCreateNestedOneWithoutInConferenceTopicsInput = {
    create?: XOR<TopicsCreateWithoutInConferenceTopicsInput, TopicsUncheckedCreateWithoutInConferenceTopicsInput>
    connectOrCreate?: TopicsCreateOrConnectWithoutInConferenceTopicsInput
    connect?: TopicsWhereUniqueInput
  }

  export type ConferenceOrganizationsUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutTopicsInput, ConferenceOrganizationsUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutTopicsInput
    upsert?: ConferenceOrganizationsUpsertWithoutTopicsInput
    connect?: ConferenceOrganizationsWhereUniqueInput
    update?: XOR<XOR<ConferenceOrganizationsUpdateToOneWithWhereWithoutTopicsInput, ConferenceOrganizationsUpdateWithoutTopicsInput>, ConferenceOrganizationsUncheckedUpdateWithoutTopicsInput>
  }

  export type TopicsUpdateOneRequiredWithoutInConferenceTopicsNestedInput = {
    create?: XOR<TopicsCreateWithoutInConferenceTopicsInput, TopicsUncheckedCreateWithoutInConferenceTopicsInput>
    connectOrCreate?: TopicsCreateOrConnectWithoutInConferenceTopicsInput
    upsert?: TopicsUpsertWithoutInConferenceTopicsInput
    connect?: TopicsWhereUniqueInput
    update?: XOR<XOR<TopicsUpdateToOneWithWhereWithoutInConferenceTopicsInput, TopicsUpdateWithoutInConferenceTopicsInput>, TopicsUncheckedUpdateWithoutInConferenceTopicsInput>
  }

  export type ConferenceTopicsCreateNestedManyWithoutInTopicInput = {
    create?: XOR<ConferenceTopicsCreateWithoutInTopicInput, ConferenceTopicsUncheckedCreateWithoutInTopicInput> | ConferenceTopicsCreateWithoutInTopicInput[] | ConferenceTopicsUncheckedCreateWithoutInTopicInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutInTopicInput | ConferenceTopicsCreateOrConnectWithoutInTopicInput[]
    createMany?: ConferenceTopicsCreateManyInTopicInputEnvelope
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
  }

  export type JournalTopicsCreateNestedManyWithoutBelongsToTopicsInput = {
    create?: XOR<JournalTopicsCreateWithoutBelongsToTopicsInput, JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput> | JournalTopicsCreateWithoutBelongsToTopicsInput[] | JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutBelongsToTopicsInput | JournalTopicsCreateOrConnectWithoutBelongsToTopicsInput[]
    createMany?: JournalTopicsCreateManyBelongsToTopicsInputEnvelope
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
  }

  export type ConferenceTopicsUncheckedCreateNestedManyWithoutInTopicInput = {
    create?: XOR<ConferenceTopicsCreateWithoutInTopicInput, ConferenceTopicsUncheckedCreateWithoutInTopicInput> | ConferenceTopicsCreateWithoutInTopicInput[] | ConferenceTopicsUncheckedCreateWithoutInTopicInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutInTopicInput | ConferenceTopicsCreateOrConnectWithoutInTopicInput[]
    createMany?: ConferenceTopicsCreateManyInTopicInputEnvelope
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
  }

  export type JournalTopicsUncheckedCreateNestedManyWithoutBelongsToTopicsInput = {
    create?: XOR<JournalTopicsCreateWithoutBelongsToTopicsInput, JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput> | JournalTopicsCreateWithoutBelongsToTopicsInput[] | JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutBelongsToTopicsInput | JournalTopicsCreateOrConnectWithoutBelongsToTopicsInput[]
    createMany?: JournalTopicsCreateManyBelongsToTopicsInputEnvelope
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
  }

  export type ConferenceTopicsUpdateManyWithoutInTopicNestedInput = {
    create?: XOR<ConferenceTopicsCreateWithoutInTopicInput, ConferenceTopicsUncheckedCreateWithoutInTopicInput> | ConferenceTopicsCreateWithoutInTopicInput[] | ConferenceTopicsUncheckedCreateWithoutInTopicInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutInTopicInput | ConferenceTopicsCreateOrConnectWithoutInTopicInput[]
    upsert?: ConferenceTopicsUpsertWithWhereUniqueWithoutInTopicInput | ConferenceTopicsUpsertWithWhereUniqueWithoutInTopicInput[]
    createMany?: ConferenceTopicsCreateManyInTopicInputEnvelope
    set?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    disconnect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    delete?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    update?: ConferenceTopicsUpdateWithWhereUniqueWithoutInTopicInput | ConferenceTopicsUpdateWithWhereUniqueWithoutInTopicInput[]
    updateMany?: ConferenceTopicsUpdateManyWithWhereWithoutInTopicInput | ConferenceTopicsUpdateManyWithWhereWithoutInTopicInput[]
    deleteMany?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
  }

  export type JournalTopicsUpdateManyWithoutBelongsToTopicsNestedInput = {
    create?: XOR<JournalTopicsCreateWithoutBelongsToTopicsInput, JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput> | JournalTopicsCreateWithoutBelongsToTopicsInput[] | JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutBelongsToTopicsInput | JournalTopicsCreateOrConnectWithoutBelongsToTopicsInput[]
    upsert?: JournalTopicsUpsertWithWhereUniqueWithoutBelongsToTopicsInput | JournalTopicsUpsertWithWhereUniqueWithoutBelongsToTopicsInput[]
    createMany?: JournalTopicsCreateManyBelongsToTopicsInputEnvelope
    set?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    disconnect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    delete?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    update?: JournalTopicsUpdateWithWhereUniqueWithoutBelongsToTopicsInput | JournalTopicsUpdateWithWhereUniqueWithoutBelongsToTopicsInput[]
    updateMany?: JournalTopicsUpdateManyWithWhereWithoutBelongsToTopicsInput | JournalTopicsUpdateManyWithWhereWithoutBelongsToTopicsInput[]
    deleteMany?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
  }

  export type ConferenceTopicsUncheckedUpdateManyWithoutInTopicNestedInput = {
    create?: XOR<ConferenceTopicsCreateWithoutInTopicInput, ConferenceTopicsUncheckedCreateWithoutInTopicInput> | ConferenceTopicsCreateWithoutInTopicInput[] | ConferenceTopicsUncheckedCreateWithoutInTopicInput[]
    connectOrCreate?: ConferenceTopicsCreateOrConnectWithoutInTopicInput | ConferenceTopicsCreateOrConnectWithoutInTopicInput[]
    upsert?: ConferenceTopicsUpsertWithWhereUniqueWithoutInTopicInput | ConferenceTopicsUpsertWithWhereUniqueWithoutInTopicInput[]
    createMany?: ConferenceTopicsCreateManyInTopicInputEnvelope
    set?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    disconnect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    delete?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    connect?: ConferenceTopicsWhereUniqueInput | ConferenceTopicsWhereUniqueInput[]
    update?: ConferenceTopicsUpdateWithWhereUniqueWithoutInTopicInput | ConferenceTopicsUpdateWithWhereUniqueWithoutInTopicInput[]
    updateMany?: ConferenceTopicsUpdateManyWithWhereWithoutInTopicInput | ConferenceTopicsUpdateManyWithWhereWithoutInTopicInput[]
    deleteMany?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
  }

  export type JournalTopicsUncheckedUpdateManyWithoutBelongsToTopicsNestedInput = {
    create?: XOR<JournalTopicsCreateWithoutBelongsToTopicsInput, JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput> | JournalTopicsCreateWithoutBelongsToTopicsInput[] | JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutBelongsToTopicsInput | JournalTopicsCreateOrConnectWithoutBelongsToTopicsInput[]
    upsert?: JournalTopicsUpsertWithWhereUniqueWithoutBelongsToTopicsInput | JournalTopicsUpsertWithWhereUniqueWithoutBelongsToTopicsInput[]
    createMany?: JournalTopicsCreateManyBelongsToTopicsInputEnvelope
    set?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    disconnect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    delete?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    update?: JournalTopicsUpdateWithWhereUniqueWithoutBelongsToTopicsInput | JournalTopicsUpdateWithWhereUniqueWithoutBelongsToTopicsInput[]
    updateMany?: JournalTopicsUpdateManyWithWhereWithoutBelongsToTopicsInput | JournalTopicsUpdateManyWithWhereWithoutBelongsToTopicsInput[]
    deleteMany?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
  }

  export type ConferenceFollowsCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceFollowsCreateWithoutBelongsToInput, ConferenceFollowsUncheckedCreateWithoutBelongsToInput> | ConferenceFollowsCreateWithoutBelongsToInput[] | ConferenceFollowsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutBelongsToInput | ConferenceFollowsCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceFollowsCreateManyBelongsToInputEnvelope
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
  }

  export type ConferenceLikesCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceLikesCreateWithoutBelongsToInput, ConferenceLikesUncheckedCreateWithoutBelongsToInput> | ConferenceLikesCreateWithoutBelongsToInput[] | ConferenceLikesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutBelongsToInput | ConferenceLikesCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceLikesCreateManyBelongsToInputEnvelope
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
  }

  export type ConferenceCalendarsCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutBelongsToInput, ConferenceCalendarsUncheckedCreateWithoutBelongsToInput> | ConferenceCalendarsCreateWithoutBelongsToInput[] | ConferenceCalendarsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutBelongsToInput | ConferenceCalendarsCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceCalendarsCreateManyBelongsToInputEnvelope
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
  }

  export type ConferenceOrganizationsCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutBelongsToInput, ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput> | ConferenceOrganizationsCreateWithoutBelongsToInput[] | ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutBelongsToInput | ConferenceOrganizationsCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceOrganizationsCreateManyBelongsToInputEnvelope
    connect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
  }

  export type ConferenceRanksCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceRanksCreateWithoutBelongsToInput, ConferenceRanksUncheckedCreateWithoutBelongsToInput> | ConferenceRanksCreateWithoutBelongsToInput[] | ConferenceRanksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutBelongsToInput | ConferenceRanksCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceRanksCreateManyBelongsToInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type ConferenceCrawlJobsCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceCrawlJobsCreateWithoutBelongsToInput, ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput> | ConferenceCrawlJobsCreateWithoutBelongsToInput[] | ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceCrawlJobsCreateOrConnectWithoutBelongsToInput | ConferenceCrawlJobsCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceCrawlJobsCreateManyBelongsToInputEnvelope
    connect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutCreatedConferencesInput = {
    create?: XOR<UsersCreateWithoutCreatedConferencesInput, UsersUncheckedCreateWithoutCreatedConferencesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCreatedConferencesInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferenceFeedbacksCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutBelongsToInput, ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput> | ConferenceFeedbacksCreateWithoutBelongsToInput[] | ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutBelongsToInput | ConferenceFeedbacksCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceFeedbacksCreateManyBelongsToInputEnvelope
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
  }

  export type ConferenceFollowsUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceFollowsCreateWithoutBelongsToInput, ConferenceFollowsUncheckedCreateWithoutBelongsToInput> | ConferenceFollowsCreateWithoutBelongsToInput[] | ConferenceFollowsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutBelongsToInput | ConferenceFollowsCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceFollowsCreateManyBelongsToInputEnvelope
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
  }

  export type ConferenceLikesUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceLikesCreateWithoutBelongsToInput, ConferenceLikesUncheckedCreateWithoutBelongsToInput> | ConferenceLikesCreateWithoutBelongsToInput[] | ConferenceLikesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutBelongsToInput | ConferenceLikesCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceLikesCreateManyBelongsToInputEnvelope
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
  }

  export type ConferenceCalendarsUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutBelongsToInput, ConferenceCalendarsUncheckedCreateWithoutBelongsToInput> | ConferenceCalendarsCreateWithoutBelongsToInput[] | ConferenceCalendarsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutBelongsToInput | ConferenceCalendarsCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceCalendarsCreateManyBelongsToInputEnvelope
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
  }

  export type ConferenceOrganizationsUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutBelongsToInput, ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput> | ConferenceOrganizationsCreateWithoutBelongsToInput[] | ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutBelongsToInput | ConferenceOrganizationsCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceOrganizationsCreateManyBelongsToInputEnvelope
    connect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
  }

  export type ConferenceRanksUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceRanksCreateWithoutBelongsToInput, ConferenceRanksUncheckedCreateWithoutBelongsToInput> | ConferenceRanksCreateWithoutBelongsToInput[] | ConferenceRanksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutBelongsToInput | ConferenceRanksCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceRanksCreateManyBelongsToInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type ConferenceCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceCrawlJobsCreateWithoutBelongsToInput, ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput> | ConferenceCrawlJobsCreateWithoutBelongsToInput[] | ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceCrawlJobsCreateOrConnectWithoutBelongsToInput | ConferenceCrawlJobsCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceCrawlJobsCreateManyBelongsToInputEnvelope
    connect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
  }

  export type ConferenceFeedbacksUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutBelongsToInput, ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput> | ConferenceFeedbacksCreateWithoutBelongsToInput[] | ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutBelongsToInput | ConferenceFeedbacksCreateOrConnectWithoutBelongsToInput[]
    createMany?: ConferenceFeedbacksCreateManyBelongsToInputEnvelope
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
  }

  export type ConferenceFollowsUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceFollowsCreateWithoutBelongsToInput, ConferenceFollowsUncheckedCreateWithoutBelongsToInput> | ConferenceFollowsCreateWithoutBelongsToInput[] | ConferenceFollowsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutBelongsToInput | ConferenceFollowsCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceFollowsUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceFollowsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceFollowsCreateManyBelongsToInputEnvelope
    set?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    disconnect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    delete?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    update?: ConferenceFollowsUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceFollowsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceFollowsUpdateManyWithWhereWithoutBelongsToInput | ConferenceFollowsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
  }

  export type ConferenceLikesUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceLikesCreateWithoutBelongsToInput, ConferenceLikesUncheckedCreateWithoutBelongsToInput> | ConferenceLikesCreateWithoutBelongsToInput[] | ConferenceLikesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutBelongsToInput | ConferenceLikesCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceLikesUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceLikesUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceLikesCreateManyBelongsToInputEnvelope
    set?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    disconnect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    delete?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    update?: ConferenceLikesUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceLikesUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceLikesUpdateManyWithWhereWithoutBelongsToInput | ConferenceLikesUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
  }

  export type ConferenceCalendarsUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutBelongsToInput, ConferenceCalendarsUncheckedCreateWithoutBelongsToInput> | ConferenceCalendarsCreateWithoutBelongsToInput[] | ConferenceCalendarsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutBelongsToInput | ConferenceCalendarsCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceCalendarsUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceCalendarsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceCalendarsCreateManyBelongsToInputEnvelope
    set?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    disconnect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    delete?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    update?: ConferenceCalendarsUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceCalendarsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceCalendarsUpdateManyWithWhereWithoutBelongsToInput | ConferenceCalendarsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
  }

  export type ConferenceOrganizationsUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutBelongsToInput, ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput> | ConferenceOrganizationsCreateWithoutBelongsToInput[] | ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutBelongsToInput | ConferenceOrganizationsCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceOrganizationsUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceOrganizationsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceOrganizationsCreateManyBelongsToInputEnvelope
    set?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    disconnect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    delete?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    connect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    update?: ConferenceOrganizationsUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceOrganizationsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceOrganizationsUpdateManyWithWhereWithoutBelongsToInput | ConferenceOrganizationsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceOrganizationsScalarWhereInput | ConferenceOrganizationsScalarWhereInput[]
  }

  export type ConferenceRanksUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutBelongsToInput, ConferenceRanksUncheckedCreateWithoutBelongsToInput> | ConferenceRanksCreateWithoutBelongsToInput[] | ConferenceRanksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutBelongsToInput | ConferenceRanksCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceRanksUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceRanksCreateManyBelongsToInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceRanksUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutBelongsToInput | ConferenceRanksUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type ConferenceCrawlJobsUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceCrawlJobsCreateWithoutBelongsToInput, ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput> | ConferenceCrawlJobsCreateWithoutBelongsToInput[] | ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceCrawlJobsCreateOrConnectWithoutBelongsToInput | ConferenceCrawlJobsCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceCrawlJobsUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceCrawlJobsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceCrawlJobsCreateManyBelongsToInputEnvelope
    set?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    disconnect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    delete?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    connect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    update?: ConferenceCrawlJobsUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceCrawlJobsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceCrawlJobsUpdateManyWithWhereWithoutBelongsToInput | ConferenceCrawlJobsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceCrawlJobsScalarWhereInput | ConferenceCrawlJobsScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutCreatedConferencesNestedInput = {
    create?: XOR<UsersCreateWithoutCreatedConferencesInput, UsersUncheckedCreateWithoutCreatedConferencesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCreatedConferencesInput
    upsert?: UsersUpsertWithoutCreatedConferencesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCreatedConferencesInput, UsersUpdateWithoutCreatedConferencesInput>, UsersUncheckedUpdateWithoutCreatedConferencesInput>
  }

  export type ConferenceFeedbacksUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutBelongsToInput, ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput> | ConferenceFeedbacksCreateWithoutBelongsToInput[] | ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutBelongsToInput | ConferenceFeedbacksCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceFeedbacksUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceFeedbacksUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceFeedbacksCreateManyBelongsToInputEnvelope
    set?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    disconnect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    delete?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    update?: ConferenceFeedbacksUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceFeedbacksUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceFeedbacksUpdateManyWithWhereWithoutBelongsToInput | ConferenceFeedbacksUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
  }

  export type ConferenceFollowsUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceFollowsCreateWithoutBelongsToInput, ConferenceFollowsUncheckedCreateWithoutBelongsToInput> | ConferenceFollowsCreateWithoutBelongsToInput[] | ConferenceFollowsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutBelongsToInput | ConferenceFollowsCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceFollowsUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceFollowsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceFollowsCreateManyBelongsToInputEnvelope
    set?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    disconnect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    delete?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    update?: ConferenceFollowsUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceFollowsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceFollowsUpdateManyWithWhereWithoutBelongsToInput | ConferenceFollowsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
  }

  export type ConferenceLikesUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceLikesCreateWithoutBelongsToInput, ConferenceLikesUncheckedCreateWithoutBelongsToInput> | ConferenceLikesCreateWithoutBelongsToInput[] | ConferenceLikesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutBelongsToInput | ConferenceLikesCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceLikesUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceLikesUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceLikesCreateManyBelongsToInputEnvelope
    set?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    disconnect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    delete?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    update?: ConferenceLikesUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceLikesUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceLikesUpdateManyWithWhereWithoutBelongsToInput | ConferenceLikesUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
  }

  export type ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutBelongsToInput, ConferenceCalendarsUncheckedCreateWithoutBelongsToInput> | ConferenceCalendarsCreateWithoutBelongsToInput[] | ConferenceCalendarsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutBelongsToInput | ConferenceCalendarsCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceCalendarsUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceCalendarsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceCalendarsCreateManyBelongsToInputEnvelope
    set?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    disconnect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    delete?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    update?: ConferenceCalendarsUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceCalendarsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceCalendarsUpdateManyWithWhereWithoutBelongsToInput | ConferenceCalendarsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
  }

  export type ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceOrganizationsCreateWithoutBelongsToInput, ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput> | ConferenceOrganizationsCreateWithoutBelongsToInput[] | ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceOrganizationsCreateOrConnectWithoutBelongsToInput | ConferenceOrganizationsCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceOrganizationsUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceOrganizationsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceOrganizationsCreateManyBelongsToInputEnvelope
    set?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    disconnect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    delete?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    connect?: ConferenceOrganizationsWhereUniqueInput | ConferenceOrganizationsWhereUniqueInput[]
    update?: ConferenceOrganizationsUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceOrganizationsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceOrganizationsUpdateManyWithWhereWithoutBelongsToInput | ConferenceOrganizationsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceOrganizationsScalarWhereInput | ConferenceOrganizationsScalarWhereInput[]
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutBelongsToInput, ConferenceRanksUncheckedCreateWithoutBelongsToInput> | ConferenceRanksCreateWithoutBelongsToInput[] | ConferenceRanksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutBelongsToInput | ConferenceRanksCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceRanksUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceRanksCreateManyBelongsToInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceRanksUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutBelongsToInput | ConferenceRanksUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceCrawlJobsCreateWithoutBelongsToInput, ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput> | ConferenceCrawlJobsCreateWithoutBelongsToInput[] | ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceCrawlJobsCreateOrConnectWithoutBelongsToInput | ConferenceCrawlJobsCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceCrawlJobsUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceCrawlJobsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceCrawlJobsCreateManyBelongsToInputEnvelope
    set?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    disconnect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    delete?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    connect?: ConferenceCrawlJobsWhereUniqueInput | ConferenceCrawlJobsWhereUniqueInput[]
    update?: ConferenceCrawlJobsUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceCrawlJobsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceCrawlJobsUpdateManyWithWhereWithoutBelongsToInput | ConferenceCrawlJobsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceCrawlJobsScalarWhereInput | ConferenceCrawlJobsScalarWhereInput[]
  }

  export type ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutBelongsToInput, ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput> | ConferenceFeedbacksCreateWithoutBelongsToInput[] | ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutBelongsToInput | ConferenceFeedbacksCreateOrConnectWithoutBelongsToInput[]
    upsert?: ConferenceFeedbacksUpsertWithWhereUniqueWithoutBelongsToInput | ConferenceFeedbacksUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: ConferenceFeedbacksCreateManyBelongsToInputEnvelope
    set?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    disconnect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    delete?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    update?: ConferenceFeedbacksUpdateWithWhereUniqueWithoutBelongsToInput | ConferenceFeedbacksUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: ConferenceFeedbacksUpdateManyWithWhereWithoutBelongsToInput | ConferenceFeedbacksUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
  }

  export type FieldOfResearchsCreateNestedOneWithoutConferenceRanksInput = {
    create?: XOR<FieldOfResearchsCreateWithoutConferenceRanksInput, FieldOfResearchsUncheckedCreateWithoutConferenceRanksInput>
    connectOrCreate?: FieldOfResearchsCreateOrConnectWithoutConferenceRanksInput
    connect?: FieldOfResearchsWhereUniqueInput
  }

  export type RanksCreateNestedOneWithoutConferenceRanksInput = {
    create?: XOR<RanksCreateWithoutConferenceRanksInput, RanksUncheckedCreateWithoutConferenceRanksInput>
    connectOrCreate?: RanksCreateOrConnectWithoutConferenceRanksInput
    connect?: RanksWhereUniqueInput
  }

  export type ConferencesCreateNestedOneWithoutRanksInput = {
    create?: XOR<ConferencesCreateWithoutRanksInput, ConferencesUncheckedCreateWithoutRanksInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutRanksInput
    connect?: ConferencesWhereUniqueInput
  }

  export type FieldOfResearchsUpdateOneRequiredWithoutConferenceRanksNestedInput = {
    create?: XOR<FieldOfResearchsCreateWithoutConferenceRanksInput, FieldOfResearchsUncheckedCreateWithoutConferenceRanksInput>
    connectOrCreate?: FieldOfResearchsCreateOrConnectWithoutConferenceRanksInput
    upsert?: FieldOfResearchsUpsertWithoutConferenceRanksInput
    connect?: FieldOfResearchsWhereUniqueInput
    update?: XOR<XOR<FieldOfResearchsUpdateToOneWithWhereWithoutConferenceRanksInput, FieldOfResearchsUpdateWithoutConferenceRanksInput>, FieldOfResearchsUncheckedUpdateWithoutConferenceRanksInput>
  }

  export type RanksUpdateOneRequiredWithoutConferenceRanksNestedInput = {
    create?: XOR<RanksCreateWithoutConferenceRanksInput, RanksUncheckedCreateWithoutConferenceRanksInput>
    connectOrCreate?: RanksCreateOrConnectWithoutConferenceRanksInput
    upsert?: RanksUpsertWithoutConferenceRanksInput
    connect?: RanksWhereUniqueInput
    update?: XOR<XOR<RanksUpdateToOneWithWhereWithoutConferenceRanksInput, RanksUpdateWithoutConferenceRanksInput>, RanksUncheckedUpdateWithoutConferenceRanksInput>
  }

  export type ConferencesUpdateOneRequiredWithoutRanksNestedInput = {
    create?: XOR<ConferencesCreateWithoutRanksInput, ConferencesUncheckedCreateWithoutRanksInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutRanksInput
    upsert?: ConferencesUpsertWithoutRanksInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutRanksInput, ConferencesUpdateWithoutRanksInput>, ConferencesUncheckedUpdateWithoutRanksInput>
  }

  export type JournalRanksCreateNestedManyWithoutInFieldOfResearchInput = {
    create?: XOR<JournalRanksCreateWithoutInFieldOfResearchInput, JournalRanksUncheckedCreateWithoutInFieldOfResearchInput> | JournalRanksCreateWithoutInFieldOfResearchInput[] | JournalRanksUncheckedCreateWithoutInFieldOfResearchInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutInFieldOfResearchInput | JournalRanksCreateOrConnectWithoutInFieldOfResearchInput[]
    createMany?: JournalRanksCreateManyInFieldOfResearchInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type ConferenceRanksCreateNestedManyWithoutInFieldOfResearchInput = {
    create?: XOR<ConferenceRanksCreateWithoutInFieldOfResearchInput, ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput> | ConferenceRanksCreateWithoutInFieldOfResearchInput[] | ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutInFieldOfResearchInput | ConferenceRanksCreateOrConnectWithoutInFieldOfResearchInput[]
    createMany?: ConferenceRanksCreateManyInFieldOfResearchInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type JournalRanksUncheckedCreateNestedManyWithoutInFieldOfResearchInput = {
    create?: XOR<JournalRanksCreateWithoutInFieldOfResearchInput, JournalRanksUncheckedCreateWithoutInFieldOfResearchInput> | JournalRanksCreateWithoutInFieldOfResearchInput[] | JournalRanksUncheckedCreateWithoutInFieldOfResearchInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutInFieldOfResearchInput | JournalRanksCreateOrConnectWithoutInFieldOfResearchInput[]
    createMany?: JournalRanksCreateManyInFieldOfResearchInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type ConferenceRanksUncheckedCreateNestedManyWithoutInFieldOfResearchInput = {
    create?: XOR<ConferenceRanksCreateWithoutInFieldOfResearchInput, ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput> | ConferenceRanksCreateWithoutInFieldOfResearchInput[] | ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutInFieldOfResearchInput | ConferenceRanksCreateOrConnectWithoutInFieldOfResearchInput[]
    createMany?: ConferenceRanksCreateManyInFieldOfResearchInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type JournalRanksUpdateManyWithoutInFieldOfResearchNestedInput = {
    create?: XOR<JournalRanksCreateWithoutInFieldOfResearchInput, JournalRanksUncheckedCreateWithoutInFieldOfResearchInput> | JournalRanksCreateWithoutInFieldOfResearchInput[] | JournalRanksUncheckedCreateWithoutInFieldOfResearchInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutInFieldOfResearchInput | JournalRanksCreateOrConnectWithoutInFieldOfResearchInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutInFieldOfResearchInput | JournalRanksUpsertWithWhereUniqueWithoutInFieldOfResearchInput[]
    createMany?: JournalRanksCreateManyInFieldOfResearchInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutInFieldOfResearchInput | JournalRanksUpdateWithWhereUniqueWithoutInFieldOfResearchInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutInFieldOfResearchInput | JournalRanksUpdateManyWithWhereWithoutInFieldOfResearchInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type ConferenceRanksUpdateManyWithoutInFieldOfResearchNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutInFieldOfResearchInput, ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput> | ConferenceRanksCreateWithoutInFieldOfResearchInput[] | ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutInFieldOfResearchInput | ConferenceRanksCreateOrConnectWithoutInFieldOfResearchInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutInFieldOfResearchInput | ConferenceRanksUpsertWithWhereUniqueWithoutInFieldOfResearchInput[]
    createMany?: ConferenceRanksCreateManyInFieldOfResearchInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutInFieldOfResearchInput | ConferenceRanksUpdateWithWhereUniqueWithoutInFieldOfResearchInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutInFieldOfResearchInput | ConferenceRanksUpdateManyWithWhereWithoutInFieldOfResearchInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type JournalRanksUncheckedUpdateManyWithoutInFieldOfResearchNestedInput = {
    create?: XOR<JournalRanksCreateWithoutInFieldOfResearchInput, JournalRanksUncheckedCreateWithoutInFieldOfResearchInput> | JournalRanksCreateWithoutInFieldOfResearchInput[] | JournalRanksUncheckedCreateWithoutInFieldOfResearchInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutInFieldOfResearchInput | JournalRanksCreateOrConnectWithoutInFieldOfResearchInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutInFieldOfResearchInput | JournalRanksUpsertWithWhereUniqueWithoutInFieldOfResearchInput[]
    createMany?: JournalRanksCreateManyInFieldOfResearchInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutInFieldOfResearchInput | JournalRanksUpdateWithWhereUniqueWithoutInFieldOfResearchInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutInFieldOfResearchInput | JournalRanksUpdateManyWithWhereWithoutInFieldOfResearchInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutInFieldOfResearchNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutInFieldOfResearchInput, ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput> | ConferenceRanksCreateWithoutInFieldOfResearchInput[] | ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutInFieldOfResearchInput | ConferenceRanksCreateOrConnectWithoutInFieldOfResearchInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutInFieldOfResearchInput | ConferenceRanksUpsertWithWhereUniqueWithoutInFieldOfResearchInput[]
    createMany?: ConferenceRanksCreateManyInFieldOfResearchInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutInFieldOfResearchInput | ConferenceRanksUpdateWithWhereUniqueWithoutInFieldOfResearchInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutInFieldOfResearchInput | ConferenceRanksUpdateManyWithWhereWithoutInFieldOfResearchInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type ConferenceRanksCreateNestedManyWithoutByRankInput = {
    create?: XOR<ConferenceRanksCreateWithoutByRankInput, ConferenceRanksUncheckedCreateWithoutByRankInput> | ConferenceRanksCreateWithoutByRankInput[] | ConferenceRanksUncheckedCreateWithoutByRankInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutByRankInput | ConferenceRanksCreateOrConnectWithoutByRankInput[]
    createMany?: ConferenceRanksCreateManyByRankInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type JournalRanksCreateNestedManyWithoutByRankInput = {
    create?: XOR<JournalRanksCreateWithoutByRankInput, JournalRanksUncheckedCreateWithoutByRankInput> | JournalRanksCreateWithoutByRankInput[] | JournalRanksUncheckedCreateWithoutByRankInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutByRankInput | JournalRanksCreateOrConnectWithoutByRankInput[]
    createMany?: JournalRanksCreateManyByRankInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type SourcesCreateNestedOneWithoutRanksInput = {
    create?: XOR<SourcesCreateWithoutRanksInput, SourcesUncheckedCreateWithoutRanksInput>
    connectOrCreate?: SourcesCreateOrConnectWithoutRanksInput
    connect?: SourcesWhereUniqueInput
  }

  export type ConferenceRanksUncheckedCreateNestedManyWithoutByRankInput = {
    create?: XOR<ConferenceRanksCreateWithoutByRankInput, ConferenceRanksUncheckedCreateWithoutByRankInput> | ConferenceRanksCreateWithoutByRankInput[] | ConferenceRanksUncheckedCreateWithoutByRankInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutByRankInput | ConferenceRanksCreateOrConnectWithoutByRankInput[]
    createMany?: ConferenceRanksCreateManyByRankInputEnvelope
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
  }

  export type JournalRanksUncheckedCreateNestedManyWithoutByRankInput = {
    create?: XOR<JournalRanksCreateWithoutByRankInput, JournalRanksUncheckedCreateWithoutByRankInput> | JournalRanksCreateWithoutByRankInput[] | JournalRanksUncheckedCreateWithoutByRankInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutByRankInput | JournalRanksCreateOrConnectWithoutByRankInput[]
    createMany?: JournalRanksCreateManyByRankInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type ConferenceRanksUpdateManyWithoutByRankNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutByRankInput, ConferenceRanksUncheckedCreateWithoutByRankInput> | ConferenceRanksCreateWithoutByRankInput[] | ConferenceRanksUncheckedCreateWithoutByRankInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutByRankInput | ConferenceRanksCreateOrConnectWithoutByRankInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutByRankInput | ConferenceRanksUpsertWithWhereUniqueWithoutByRankInput[]
    createMany?: ConferenceRanksCreateManyByRankInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutByRankInput | ConferenceRanksUpdateWithWhereUniqueWithoutByRankInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutByRankInput | ConferenceRanksUpdateManyWithWhereWithoutByRankInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type JournalRanksUpdateManyWithoutByRankNestedInput = {
    create?: XOR<JournalRanksCreateWithoutByRankInput, JournalRanksUncheckedCreateWithoutByRankInput> | JournalRanksCreateWithoutByRankInput[] | JournalRanksUncheckedCreateWithoutByRankInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutByRankInput | JournalRanksCreateOrConnectWithoutByRankInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutByRankInput | JournalRanksUpsertWithWhereUniqueWithoutByRankInput[]
    createMany?: JournalRanksCreateManyByRankInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutByRankInput | JournalRanksUpdateWithWhereUniqueWithoutByRankInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutByRankInput | JournalRanksUpdateManyWithWhereWithoutByRankInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type SourcesUpdateOneRequiredWithoutRanksNestedInput = {
    create?: XOR<SourcesCreateWithoutRanksInput, SourcesUncheckedCreateWithoutRanksInput>
    connectOrCreate?: SourcesCreateOrConnectWithoutRanksInput
    upsert?: SourcesUpsertWithoutRanksInput
    connect?: SourcesWhereUniqueInput
    update?: XOR<XOR<SourcesUpdateToOneWithWhereWithoutRanksInput, SourcesUpdateWithoutRanksInput>, SourcesUncheckedUpdateWithoutRanksInput>
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutByRankNestedInput = {
    create?: XOR<ConferenceRanksCreateWithoutByRankInput, ConferenceRanksUncheckedCreateWithoutByRankInput> | ConferenceRanksCreateWithoutByRankInput[] | ConferenceRanksUncheckedCreateWithoutByRankInput[]
    connectOrCreate?: ConferenceRanksCreateOrConnectWithoutByRankInput | ConferenceRanksCreateOrConnectWithoutByRankInput[]
    upsert?: ConferenceRanksUpsertWithWhereUniqueWithoutByRankInput | ConferenceRanksUpsertWithWhereUniqueWithoutByRankInput[]
    createMany?: ConferenceRanksCreateManyByRankInputEnvelope
    set?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    disconnect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    delete?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    connect?: ConferenceRanksWhereUniqueInput | ConferenceRanksWhereUniqueInput[]
    update?: ConferenceRanksUpdateWithWhereUniqueWithoutByRankInput | ConferenceRanksUpdateWithWhereUniqueWithoutByRankInput[]
    updateMany?: ConferenceRanksUpdateManyWithWhereWithoutByRankInput | ConferenceRanksUpdateManyWithWhereWithoutByRankInput[]
    deleteMany?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
  }

  export type JournalRanksUncheckedUpdateManyWithoutByRankNestedInput = {
    create?: XOR<JournalRanksCreateWithoutByRankInput, JournalRanksUncheckedCreateWithoutByRankInput> | JournalRanksCreateWithoutByRankInput[] | JournalRanksUncheckedCreateWithoutByRankInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutByRankInput | JournalRanksCreateOrConnectWithoutByRankInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutByRankInput | JournalRanksUpsertWithWhereUniqueWithoutByRankInput[]
    createMany?: JournalRanksCreateManyByRankInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutByRankInput | JournalRanksUpdateWithWhereUniqueWithoutByRankInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutByRankInput | JournalRanksUpdateManyWithWhereWithoutByRankInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type RanksCreateNestedManyWithoutBelongsToSourceInput = {
    create?: XOR<RanksCreateWithoutBelongsToSourceInput, RanksUncheckedCreateWithoutBelongsToSourceInput> | RanksCreateWithoutBelongsToSourceInput[] | RanksUncheckedCreateWithoutBelongsToSourceInput[]
    connectOrCreate?: RanksCreateOrConnectWithoutBelongsToSourceInput | RanksCreateOrConnectWithoutBelongsToSourceInput[]
    createMany?: RanksCreateManyBelongsToSourceInputEnvelope
    connect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
  }

  export type RanksUncheckedCreateNestedManyWithoutBelongsToSourceInput = {
    create?: XOR<RanksCreateWithoutBelongsToSourceInput, RanksUncheckedCreateWithoutBelongsToSourceInput> | RanksCreateWithoutBelongsToSourceInput[] | RanksUncheckedCreateWithoutBelongsToSourceInput[]
    connectOrCreate?: RanksCreateOrConnectWithoutBelongsToSourceInput | RanksCreateOrConnectWithoutBelongsToSourceInput[]
    createMany?: RanksCreateManyBelongsToSourceInputEnvelope
    connect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
  }

  export type RanksUpdateManyWithoutBelongsToSourceNestedInput = {
    create?: XOR<RanksCreateWithoutBelongsToSourceInput, RanksUncheckedCreateWithoutBelongsToSourceInput> | RanksCreateWithoutBelongsToSourceInput[] | RanksUncheckedCreateWithoutBelongsToSourceInput[]
    connectOrCreate?: RanksCreateOrConnectWithoutBelongsToSourceInput | RanksCreateOrConnectWithoutBelongsToSourceInput[]
    upsert?: RanksUpsertWithWhereUniqueWithoutBelongsToSourceInput | RanksUpsertWithWhereUniqueWithoutBelongsToSourceInput[]
    createMany?: RanksCreateManyBelongsToSourceInputEnvelope
    set?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    disconnect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    delete?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    connect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    update?: RanksUpdateWithWhereUniqueWithoutBelongsToSourceInput | RanksUpdateWithWhereUniqueWithoutBelongsToSourceInput[]
    updateMany?: RanksUpdateManyWithWhereWithoutBelongsToSourceInput | RanksUpdateManyWithWhereWithoutBelongsToSourceInput[]
    deleteMany?: RanksScalarWhereInput | RanksScalarWhereInput[]
  }

  export type RanksUncheckedUpdateManyWithoutBelongsToSourceNestedInput = {
    create?: XOR<RanksCreateWithoutBelongsToSourceInput, RanksUncheckedCreateWithoutBelongsToSourceInput> | RanksCreateWithoutBelongsToSourceInput[] | RanksUncheckedCreateWithoutBelongsToSourceInput[]
    connectOrCreate?: RanksCreateOrConnectWithoutBelongsToSourceInput | RanksCreateOrConnectWithoutBelongsToSourceInput[]
    upsert?: RanksUpsertWithWhereUniqueWithoutBelongsToSourceInput | RanksUpsertWithWhereUniqueWithoutBelongsToSourceInput[]
    createMany?: RanksCreateManyBelongsToSourceInputEnvelope
    set?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    disconnect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    delete?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    connect?: RanksWhereUniqueInput | RanksWhereUniqueInput[]
    update?: RanksUpdateWithWhereUniqueWithoutBelongsToSourceInput | RanksUpdateWithWhereUniqueWithoutBelongsToSourceInput[]
    updateMany?: RanksUpdateManyWithWhereWithoutBelongsToSourceInput | RanksUpdateManyWithWhereWithoutBelongsToSourceInput[]
    deleteMany?: RanksScalarWhereInput | RanksScalarWhereInput[]
  }

  export type TopicsCreateNestedOneWithoutInJournalTopicsInput = {
    create?: XOR<TopicsCreateWithoutInJournalTopicsInput, TopicsUncheckedCreateWithoutInJournalTopicsInput>
    connectOrCreate?: TopicsCreateOrConnectWithoutInJournalTopicsInput
    connect?: TopicsWhereUniqueInput
  }

  export type JournalsCreateNestedOneWithoutTopicsInput = {
    create?: XOR<JournalsCreateWithoutTopicsInput, JournalsUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutTopicsInput
    connect?: JournalsWhereUniqueInput
  }

  export type TopicsUpdateOneRequiredWithoutInJournalTopicsNestedInput = {
    create?: XOR<TopicsCreateWithoutInJournalTopicsInput, TopicsUncheckedCreateWithoutInJournalTopicsInput>
    connectOrCreate?: TopicsCreateOrConnectWithoutInJournalTopicsInput
    upsert?: TopicsUpsertWithoutInJournalTopicsInput
    connect?: TopicsWhereUniqueInput
    update?: XOR<XOR<TopicsUpdateToOneWithWhereWithoutInJournalTopicsInput, TopicsUpdateWithoutInJournalTopicsInput>, TopicsUncheckedUpdateWithoutInJournalTopicsInput>
  }

  export type JournalsUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<JournalsCreateWithoutTopicsInput, JournalsUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutTopicsInput
    upsert?: JournalsUpsertWithoutTopicsInput
    connect?: JournalsWhereUniqueInput
    update?: XOR<XOR<JournalsUpdateToOneWithWhereWithoutTopicsInput, JournalsUpdateWithoutTopicsInput>, JournalsUncheckedUpdateWithoutTopicsInput>
  }

  export type FieldOfResearchsCreateNestedOneWithoutJournalRanksInput = {
    create?: XOR<FieldOfResearchsCreateWithoutJournalRanksInput, FieldOfResearchsUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: FieldOfResearchsCreateOrConnectWithoutJournalRanksInput
    connect?: FieldOfResearchsWhereUniqueInput
  }

  export type RanksCreateNestedOneWithoutJournalRanksInput = {
    create?: XOR<RanksCreateWithoutJournalRanksInput, RanksUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: RanksCreateOrConnectWithoutJournalRanksInput
    connect?: RanksWhereUniqueInput
  }

  export type JournalsCreateNestedOneWithoutJournalRanksInput = {
    create?: XOR<JournalsCreateWithoutJournalRanksInput, JournalsUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalRanksInput
    connect?: JournalsWhereUniqueInput
  }

  export type FieldOfResearchsUpdateOneRequiredWithoutJournalRanksNestedInput = {
    create?: XOR<FieldOfResearchsCreateWithoutJournalRanksInput, FieldOfResearchsUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: FieldOfResearchsCreateOrConnectWithoutJournalRanksInput
    upsert?: FieldOfResearchsUpsertWithoutJournalRanksInput
    connect?: FieldOfResearchsWhereUniqueInput
    update?: XOR<XOR<FieldOfResearchsUpdateToOneWithWhereWithoutJournalRanksInput, FieldOfResearchsUpdateWithoutJournalRanksInput>, FieldOfResearchsUncheckedUpdateWithoutJournalRanksInput>
  }

  export type RanksUpdateOneRequiredWithoutJournalRanksNestedInput = {
    create?: XOR<RanksCreateWithoutJournalRanksInput, RanksUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: RanksCreateOrConnectWithoutJournalRanksInput
    upsert?: RanksUpsertWithoutJournalRanksInput
    connect?: RanksWhereUniqueInput
    update?: XOR<XOR<RanksUpdateToOneWithWhereWithoutJournalRanksInput, RanksUpdateWithoutJournalRanksInput>, RanksUncheckedUpdateWithoutJournalRanksInput>
  }

  export type JournalsUpdateOneRequiredWithoutJournalRanksNestedInput = {
    create?: XOR<JournalsCreateWithoutJournalRanksInput, JournalsUncheckedCreateWithoutJournalRanksInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalRanksInput
    upsert?: JournalsUpsertWithoutJournalRanksInput
    connect?: JournalsWhereUniqueInput
    update?: XOR<XOR<JournalsUpdateToOneWithWhereWithoutJournalRanksInput, JournalsUpdateWithoutJournalRanksInput>, JournalsUncheckedUpdateWithoutJournalRanksInput>
  }

  export type JournalTopicsCreateNestedManyWithoutInJournalsInput = {
    create?: XOR<JournalTopicsCreateWithoutInJournalsInput, JournalTopicsUncheckedCreateWithoutInJournalsInput> | JournalTopicsCreateWithoutInJournalsInput[] | JournalTopicsUncheckedCreateWithoutInJournalsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutInJournalsInput | JournalTopicsCreateOrConnectWithoutInJournalsInput[]
    createMany?: JournalTopicsCreateManyInJournalsInputEnvelope
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
  }

  export type JournalRanksCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<JournalRanksCreateWithoutBelongsToInput, JournalRanksUncheckedCreateWithoutBelongsToInput> | JournalRanksCreateWithoutBelongsToInput[] | JournalRanksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutBelongsToInput | JournalRanksCreateOrConnectWithoutBelongsToInput[]
    createMany?: JournalRanksCreateManyBelongsToInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type JournalLikesCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<JournalLikesCreateWithoutBelongsToInput, JournalLikesUncheckedCreateWithoutBelongsToInput> | JournalLikesCreateWithoutBelongsToInput[] | JournalLikesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutBelongsToInput | JournalLikesCreateOrConnectWithoutBelongsToInput[]
    createMany?: JournalLikesCreateManyBelongsToInputEnvelope
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
  }

  export type JournalFollowsCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<JournalFollowsCreateWithoutBelongsToInput, JournalFollowsUncheckedCreateWithoutBelongsToInput> | JournalFollowsCreateWithoutBelongsToInput[] | JournalFollowsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutBelongsToInput | JournalFollowsCreateOrConnectWithoutBelongsToInput[]
    createMany?: JournalFollowsCreateManyBelongsToInputEnvelope
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
  }

  export type JournalCrawlJobsCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<JournalCrawlJobsCreateWithoutBelongsToInput, JournalCrawlJobsUncheckedCreateWithoutBelongsToInput> | JournalCrawlJobsCreateWithoutBelongsToInput[] | JournalCrawlJobsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalCrawlJobsCreateOrConnectWithoutBelongsToInput | JournalCrawlJobsCreateOrConnectWithoutBelongsToInput[]
    createMany?: JournalCrawlJobsCreateManyBelongsToInputEnvelope
    connect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutCreatedJournalsInput = {
    create?: XOR<UsersCreateWithoutCreatedJournalsInput, UsersUncheckedCreateWithoutCreatedJournalsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCreatedJournalsInput
    connect?: UsersWhereUniqueInput
  }

  export type JournalTopicsUncheckedCreateNestedManyWithoutInJournalsInput = {
    create?: XOR<JournalTopicsCreateWithoutInJournalsInput, JournalTopicsUncheckedCreateWithoutInJournalsInput> | JournalTopicsCreateWithoutInJournalsInput[] | JournalTopicsUncheckedCreateWithoutInJournalsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutInJournalsInput | JournalTopicsCreateOrConnectWithoutInJournalsInput[]
    createMany?: JournalTopicsCreateManyInJournalsInputEnvelope
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
  }

  export type JournalRanksUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<JournalRanksCreateWithoutBelongsToInput, JournalRanksUncheckedCreateWithoutBelongsToInput> | JournalRanksCreateWithoutBelongsToInput[] | JournalRanksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutBelongsToInput | JournalRanksCreateOrConnectWithoutBelongsToInput[]
    createMany?: JournalRanksCreateManyBelongsToInputEnvelope
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
  }

  export type JournalLikesUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<JournalLikesCreateWithoutBelongsToInput, JournalLikesUncheckedCreateWithoutBelongsToInput> | JournalLikesCreateWithoutBelongsToInput[] | JournalLikesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutBelongsToInput | JournalLikesCreateOrConnectWithoutBelongsToInput[]
    createMany?: JournalLikesCreateManyBelongsToInputEnvelope
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
  }

  export type JournalFollowsUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<JournalFollowsCreateWithoutBelongsToInput, JournalFollowsUncheckedCreateWithoutBelongsToInput> | JournalFollowsCreateWithoutBelongsToInput[] | JournalFollowsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutBelongsToInput | JournalFollowsCreateOrConnectWithoutBelongsToInput[]
    createMany?: JournalFollowsCreateManyBelongsToInputEnvelope
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
  }

  export type JournalCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput = {
    create?: XOR<JournalCrawlJobsCreateWithoutBelongsToInput, JournalCrawlJobsUncheckedCreateWithoutBelongsToInput> | JournalCrawlJobsCreateWithoutBelongsToInput[] | JournalCrawlJobsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalCrawlJobsCreateOrConnectWithoutBelongsToInput | JournalCrawlJobsCreateOrConnectWithoutBelongsToInput[]
    createMany?: JournalCrawlJobsCreateManyBelongsToInputEnvelope
    connect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
  }

  export type JournalTopicsUpdateManyWithoutInJournalsNestedInput = {
    create?: XOR<JournalTopicsCreateWithoutInJournalsInput, JournalTopicsUncheckedCreateWithoutInJournalsInput> | JournalTopicsCreateWithoutInJournalsInput[] | JournalTopicsUncheckedCreateWithoutInJournalsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutInJournalsInput | JournalTopicsCreateOrConnectWithoutInJournalsInput[]
    upsert?: JournalTopicsUpsertWithWhereUniqueWithoutInJournalsInput | JournalTopicsUpsertWithWhereUniqueWithoutInJournalsInput[]
    createMany?: JournalTopicsCreateManyInJournalsInputEnvelope
    set?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    disconnect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    delete?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    update?: JournalTopicsUpdateWithWhereUniqueWithoutInJournalsInput | JournalTopicsUpdateWithWhereUniqueWithoutInJournalsInput[]
    updateMany?: JournalTopicsUpdateManyWithWhereWithoutInJournalsInput | JournalTopicsUpdateManyWithWhereWithoutInJournalsInput[]
    deleteMany?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
  }

  export type JournalRanksUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<JournalRanksCreateWithoutBelongsToInput, JournalRanksUncheckedCreateWithoutBelongsToInput> | JournalRanksCreateWithoutBelongsToInput[] | JournalRanksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutBelongsToInput | JournalRanksCreateOrConnectWithoutBelongsToInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutBelongsToInput | JournalRanksUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: JournalRanksCreateManyBelongsToInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutBelongsToInput | JournalRanksUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutBelongsToInput | JournalRanksUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type JournalLikesUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<JournalLikesCreateWithoutBelongsToInput, JournalLikesUncheckedCreateWithoutBelongsToInput> | JournalLikesCreateWithoutBelongsToInput[] | JournalLikesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutBelongsToInput | JournalLikesCreateOrConnectWithoutBelongsToInput[]
    upsert?: JournalLikesUpsertWithWhereUniqueWithoutBelongsToInput | JournalLikesUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: JournalLikesCreateManyBelongsToInputEnvelope
    set?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    disconnect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    delete?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    update?: JournalLikesUpdateWithWhereUniqueWithoutBelongsToInput | JournalLikesUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: JournalLikesUpdateManyWithWhereWithoutBelongsToInput | JournalLikesUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
  }

  export type JournalFollowsUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<JournalFollowsCreateWithoutBelongsToInput, JournalFollowsUncheckedCreateWithoutBelongsToInput> | JournalFollowsCreateWithoutBelongsToInput[] | JournalFollowsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutBelongsToInput | JournalFollowsCreateOrConnectWithoutBelongsToInput[]
    upsert?: JournalFollowsUpsertWithWhereUniqueWithoutBelongsToInput | JournalFollowsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: JournalFollowsCreateManyBelongsToInputEnvelope
    set?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    disconnect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    delete?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    update?: JournalFollowsUpdateWithWhereUniqueWithoutBelongsToInput | JournalFollowsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: JournalFollowsUpdateManyWithWhereWithoutBelongsToInput | JournalFollowsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
  }

  export type JournalCrawlJobsUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<JournalCrawlJobsCreateWithoutBelongsToInput, JournalCrawlJobsUncheckedCreateWithoutBelongsToInput> | JournalCrawlJobsCreateWithoutBelongsToInput[] | JournalCrawlJobsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalCrawlJobsCreateOrConnectWithoutBelongsToInput | JournalCrawlJobsCreateOrConnectWithoutBelongsToInput[]
    upsert?: JournalCrawlJobsUpsertWithWhereUniqueWithoutBelongsToInput | JournalCrawlJobsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: JournalCrawlJobsCreateManyBelongsToInputEnvelope
    set?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    disconnect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    delete?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    connect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    update?: JournalCrawlJobsUpdateWithWhereUniqueWithoutBelongsToInput | JournalCrawlJobsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: JournalCrawlJobsUpdateManyWithWhereWithoutBelongsToInput | JournalCrawlJobsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: JournalCrawlJobsScalarWhereInput | JournalCrawlJobsScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutCreatedJournalsNestedInput = {
    create?: XOR<UsersCreateWithoutCreatedJournalsInput, UsersUncheckedCreateWithoutCreatedJournalsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCreatedJournalsInput
    upsert?: UsersUpsertWithoutCreatedJournalsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCreatedJournalsInput, UsersUpdateWithoutCreatedJournalsInput>, UsersUncheckedUpdateWithoutCreatedJournalsInput>
  }

  export type JournalTopicsUncheckedUpdateManyWithoutInJournalsNestedInput = {
    create?: XOR<JournalTopicsCreateWithoutInJournalsInput, JournalTopicsUncheckedCreateWithoutInJournalsInput> | JournalTopicsCreateWithoutInJournalsInput[] | JournalTopicsUncheckedCreateWithoutInJournalsInput[]
    connectOrCreate?: JournalTopicsCreateOrConnectWithoutInJournalsInput | JournalTopicsCreateOrConnectWithoutInJournalsInput[]
    upsert?: JournalTopicsUpsertWithWhereUniqueWithoutInJournalsInput | JournalTopicsUpsertWithWhereUniqueWithoutInJournalsInput[]
    createMany?: JournalTopicsCreateManyInJournalsInputEnvelope
    set?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    disconnect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    delete?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    connect?: JournalTopicsWhereUniqueInput | JournalTopicsWhereUniqueInput[]
    update?: JournalTopicsUpdateWithWhereUniqueWithoutInJournalsInput | JournalTopicsUpdateWithWhereUniqueWithoutInJournalsInput[]
    updateMany?: JournalTopicsUpdateManyWithWhereWithoutInJournalsInput | JournalTopicsUpdateManyWithWhereWithoutInJournalsInput[]
    deleteMany?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
  }

  export type JournalRanksUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<JournalRanksCreateWithoutBelongsToInput, JournalRanksUncheckedCreateWithoutBelongsToInput> | JournalRanksCreateWithoutBelongsToInput[] | JournalRanksUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalRanksCreateOrConnectWithoutBelongsToInput | JournalRanksCreateOrConnectWithoutBelongsToInput[]
    upsert?: JournalRanksUpsertWithWhereUniqueWithoutBelongsToInput | JournalRanksUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: JournalRanksCreateManyBelongsToInputEnvelope
    set?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    disconnect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    delete?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    connect?: JournalRanksWhereUniqueInput | JournalRanksWhereUniqueInput[]
    update?: JournalRanksUpdateWithWhereUniqueWithoutBelongsToInput | JournalRanksUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: JournalRanksUpdateManyWithWhereWithoutBelongsToInput | JournalRanksUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
  }

  export type JournalLikesUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<JournalLikesCreateWithoutBelongsToInput, JournalLikesUncheckedCreateWithoutBelongsToInput> | JournalLikesCreateWithoutBelongsToInput[] | JournalLikesUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutBelongsToInput | JournalLikesCreateOrConnectWithoutBelongsToInput[]
    upsert?: JournalLikesUpsertWithWhereUniqueWithoutBelongsToInput | JournalLikesUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: JournalLikesCreateManyBelongsToInputEnvelope
    set?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    disconnect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    delete?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    update?: JournalLikesUpdateWithWhereUniqueWithoutBelongsToInput | JournalLikesUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: JournalLikesUpdateManyWithWhereWithoutBelongsToInput | JournalLikesUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
  }

  export type JournalFollowsUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<JournalFollowsCreateWithoutBelongsToInput, JournalFollowsUncheckedCreateWithoutBelongsToInput> | JournalFollowsCreateWithoutBelongsToInput[] | JournalFollowsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutBelongsToInput | JournalFollowsCreateOrConnectWithoutBelongsToInput[]
    upsert?: JournalFollowsUpsertWithWhereUniqueWithoutBelongsToInput | JournalFollowsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: JournalFollowsCreateManyBelongsToInputEnvelope
    set?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    disconnect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    delete?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    update?: JournalFollowsUpdateWithWhereUniqueWithoutBelongsToInput | JournalFollowsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: JournalFollowsUpdateManyWithWhereWithoutBelongsToInput | JournalFollowsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
  }

  export type JournalCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput = {
    create?: XOR<JournalCrawlJobsCreateWithoutBelongsToInput, JournalCrawlJobsUncheckedCreateWithoutBelongsToInput> | JournalCrawlJobsCreateWithoutBelongsToInput[] | JournalCrawlJobsUncheckedCreateWithoutBelongsToInput[]
    connectOrCreate?: JournalCrawlJobsCreateOrConnectWithoutBelongsToInput | JournalCrawlJobsCreateOrConnectWithoutBelongsToInput[]
    upsert?: JournalCrawlJobsUpsertWithWhereUniqueWithoutBelongsToInput | JournalCrawlJobsUpsertWithWhereUniqueWithoutBelongsToInput[]
    createMany?: JournalCrawlJobsCreateManyBelongsToInputEnvelope
    set?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    disconnect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    delete?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    connect?: JournalCrawlJobsWhereUniqueInput | JournalCrawlJobsWhereUniqueInput[]
    update?: JournalCrawlJobsUpdateWithWhereUniqueWithoutBelongsToInput | JournalCrawlJobsUpdateWithWhereUniqueWithoutBelongsToInput[]
    updateMany?: JournalCrawlJobsUpdateManyWithWhereWithoutBelongsToInput | JournalCrawlJobsUpdateManyWithWhereWithoutBelongsToInput[]
    deleteMany?: JournalCrawlJobsScalarWhereInput | JournalCrawlJobsScalarWhereInput[]
  }

  export type ConferencesCreateNestedOneWithoutFollowsInput = {
    create?: XOR<ConferencesCreateWithoutFollowsInput, ConferencesUncheckedCreateWithoutFollowsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutFollowsInput
    connect?: ConferencesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutFollowConferenceInput = {
    create?: XOR<UsersCreateWithoutFollowConferenceInput, UsersUncheckedCreateWithoutFollowConferenceInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFollowConferenceInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutFollowsNestedInput = {
    create?: XOR<ConferencesCreateWithoutFollowsInput, ConferencesUncheckedCreateWithoutFollowsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutFollowsInput
    upsert?: ConferencesUpsertWithoutFollowsInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutFollowsInput, ConferencesUpdateWithoutFollowsInput>, ConferencesUncheckedUpdateWithoutFollowsInput>
  }

  export type UsersUpdateOneRequiredWithoutFollowConferenceNestedInput = {
    create?: XOR<UsersCreateWithoutFollowConferenceInput, UsersUncheckedCreateWithoutFollowConferenceInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFollowConferenceInput
    upsert?: UsersUpsertWithoutFollowConferenceInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFollowConferenceInput, UsersUpdateWithoutFollowConferenceInput>, UsersUncheckedUpdateWithoutFollowConferenceInput>
  }

  export type ConferencesCreateNestedOneWithoutLikesInput = {
    create?: XOR<ConferencesCreateWithoutLikesInput, ConferencesUncheckedCreateWithoutLikesInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutLikesInput
    connect?: ConferencesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutLikesInput = {
    create?: XOR<UsersCreateWithoutLikesInput, UsersUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutLikesInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<ConferencesCreateWithoutLikesInput, ConferencesUncheckedCreateWithoutLikesInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutLikesInput
    upsert?: ConferencesUpsertWithoutLikesInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutLikesInput, ConferencesUpdateWithoutLikesInput>, ConferencesUncheckedUpdateWithoutLikesInput>
  }

  export type UsersUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UsersCreateWithoutLikesInput, UsersUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutLikesInput
    upsert?: UsersUpsertWithoutLikesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutLikesInput, UsersUpdateWithoutLikesInput>, UsersUncheckedUpdateWithoutLikesInput>
  }

  export type ConferencesCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<ConferencesCreateWithoutFeedbacksInput, ConferencesUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutFeedbacksInput
    connect?: ConferencesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UsersCreateWithoutFeedbacksInput, UsersUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFeedbacksInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<ConferencesCreateWithoutFeedbacksInput, ConferencesUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutFeedbacksInput
    upsert?: ConferencesUpsertWithoutFeedbacksInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutFeedbacksInput, ConferencesUpdateWithoutFeedbacksInput>, ConferencesUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UsersUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UsersCreateWithoutFeedbacksInput, UsersUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFeedbacksInput
    upsert?: UsersUpsertWithoutFeedbacksInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFeedbacksInput, UsersUpdateWithoutFeedbacksInput>, UsersUncheckedUpdateWithoutFeedbacksInput>
  }

  export type ConferencesCreateNestedOneWithoutCalendarsInput = {
    create?: XOR<ConferencesCreateWithoutCalendarsInput, ConferencesUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutCalendarsInput
    connect?: ConferencesWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutCalendarInput = {
    create?: XOR<UsersCreateWithoutCalendarInput, UsersUncheckedCreateWithoutCalendarInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCalendarInput
    connect?: UsersWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutCalendarsNestedInput = {
    create?: XOR<ConferencesCreateWithoutCalendarsInput, ConferencesUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutCalendarsInput
    upsert?: ConferencesUpsertWithoutCalendarsInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutCalendarsInput, ConferencesUpdateWithoutCalendarsInput>, ConferencesUncheckedUpdateWithoutCalendarsInput>
  }

  export type UsersUpdateOneRequiredWithoutCalendarNestedInput = {
    create?: XOR<UsersCreateWithoutCalendarInput, UsersUncheckedCreateWithoutCalendarInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCalendarInput
    upsert?: UsersUpsertWithoutCalendarInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCalendarInput, UsersUpdateWithoutCalendarInput>, UsersUncheckedUpdateWithoutCalendarInput>
  }

  export type JournalsCreateNestedOneWithoutJournalLikesInput = {
    create?: XOR<JournalsCreateWithoutJournalLikesInput, JournalsUncheckedCreateWithoutJournalLikesInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalLikesInput
    connect?: JournalsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutJournalLikesInput = {
    create?: XOR<UsersCreateWithoutJournalLikesInput, UsersUncheckedCreateWithoutJournalLikesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutJournalLikesInput
    connect?: UsersWhereUniqueInput
  }

  export type JournalsUpdateOneRequiredWithoutJournalLikesNestedInput = {
    create?: XOR<JournalsCreateWithoutJournalLikesInput, JournalsUncheckedCreateWithoutJournalLikesInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalLikesInput
    upsert?: JournalsUpsertWithoutJournalLikesInput
    connect?: JournalsWhereUniqueInput
    update?: XOR<XOR<JournalsUpdateToOneWithWhereWithoutJournalLikesInput, JournalsUpdateWithoutJournalLikesInput>, JournalsUncheckedUpdateWithoutJournalLikesInput>
  }

  export type UsersUpdateOneRequiredWithoutJournalLikesNestedInput = {
    create?: XOR<UsersCreateWithoutJournalLikesInput, UsersUncheckedCreateWithoutJournalLikesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutJournalLikesInput
    upsert?: UsersUpsertWithoutJournalLikesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutJournalLikesInput, UsersUpdateWithoutJournalLikesInput>, UsersUncheckedUpdateWithoutJournalLikesInput>
  }

  export type JournalsCreateNestedOneWithoutJournalFollowsInput = {
    create?: XOR<JournalsCreateWithoutJournalFollowsInput, JournalsUncheckedCreateWithoutJournalFollowsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalFollowsInput
    connect?: JournalsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutJournalFollowsInput = {
    create?: XOR<UsersCreateWithoutJournalFollowsInput, UsersUncheckedCreateWithoutJournalFollowsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutJournalFollowsInput
    connect?: UsersWhereUniqueInput
  }

  export type JournalsUpdateOneRequiredWithoutJournalFollowsNestedInput = {
    create?: XOR<JournalsCreateWithoutJournalFollowsInput, JournalsUncheckedCreateWithoutJournalFollowsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutJournalFollowsInput
    upsert?: JournalsUpsertWithoutJournalFollowsInput
    connect?: JournalsWhereUniqueInput
    update?: XOR<XOR<JournalsUpdateToOneWithWhereWithoutJournalFollowsInput, JournalsUpdateWithoutJournalFollowsInput>, JournalsUncheckedUpdateWithoutJournalFollowsInput>
  }

  export type UsersUpdateOneRequiredWithoutJournalFollowsNestedInput = {
    create?: XOR<UsersCreateWithoutJournalFollowsInput, UsersUncheckedCreateWithoutJournalFollowsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutJournalFollowsInput
    upsert?: UsersUpsertWithoutJournalFollowsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutJournalFollowsInput, UsersUpdateWithoutJournalFollowsInput>, UsersUncheckedUpdateWithoutJournalFollowsInput>
  }

  export type ConferenceFollowsCreateNestedManyWithoutByUserInput = {
    create?: XOR<ConferenceFollowsCreateWithoutByUserInput, ConferenceFollowsUncheckedCreateWithoutByUserInput> | ConferenceFollowsCreateWithoutByUserInput[] | ConferenceFollowsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutByUserInput | ConferenceFollowsCreateOrConnectWithoutByUserInput[]
    createMany?: ConferenceFollowsCreateManyByUserInputEnvelope
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
  }

  export type ConferenceLikesCreateNestedManyWithoutByUserInput = {
    create?: XOR<ConferenceLikesCreateWithoutByUserInput, ConferenceLikesUncheckedCreateWithoutByUserInput> | ConferenceLikesCreateWithoutByUserInput[] | ConferenceLikesUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutByUserInput | ConferenceLikesCreateOrConnectWithoutByUserInput[]
    createMany?: ConferenceLikesCreateManyByUserInputEnvelope
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
  }

  export type ConferenceCalendarsCreateNestedManyWithoutByUserInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutByUserInput, ConferenceCalendarsUncheckedCreateWithoutByUserInput> | ConferenceCalendarsCreateWithoutByUserInput[] | ConferenceCalendarsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutByUserInput | ConferenceCalendarsCreateOrConnectWithoutByUserInput[]
    createMany?: ConferenceCalendarsCreateManyByUserInputEnvelope
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
  }

  export type ConferencesCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<ConferencesCreateWithoutCreatedByUserInput, ConferencesUncheckedCreateWithoutCreatedByUserInput> | ConferencesCreateWithoutCreatedByUserInput[] | ConferencesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutCreatedByUserInput | ConferencesCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: ConferencesCreateManyCreatedByUserInputEnvelope
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
  }

  export type JournalsCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<JournalsCreateWithoutCreatedByUserInput, JournalsUncheckedCreateWithoutCreatedByUserInput> | JournalsCreateWithoutCreatedByUserInput[] | JournalsUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: JournalsCreateOrConnectWithoutCreatedByUserInput | JournalsCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: JournalsCreateManyCreatedByUserInputEnvelope
    connect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
  }

  export type JournalLikesCreateNestedManyWithoutByUserInput = {
    create?: XOR<JournalLikesCreateWithoutByUserInput, JournalLikesUncheckedCreateWithoutByUserInput> | JournalLikesCreateWithoutByUserInput[] | JournalLikesUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutByUserInput | JournalLikesCreateOrConnectWithoutByUserInput[]
    createMany?: JournalLikesCreateManyByUserInputEnvelope
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
  }

  export type JournalFollowsCreateNestedManyWithoutByUserInput = {
    create?: XOR<JournalFollowsCreateWithoutByUserInput, JournalFollowsUncheckedCreateWithoutByUserInput> | JournalFollowsCreateWithoutByUserInput[] | JournalFollowsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutByUserInput | JournalFollowsCreateOrConnectWithoutByUserInput[]
    createMany?: JournalFollowsCreateManyByUserInputEnvelope
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
  }

  export type ConferenceFeedbacksCreateNestedManyWithoutByUserInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutByUserInput, ConferenceFeedbacksUncheckedCreateWithoutByUserInput> | ConferenceFeedbacksCreateWithoutByUserInput[] | ConferenceFeedbacksUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutByUserInput | ConferenceFeedbacksCreateOrConnectWithoutByUserInput[]
    createMany?: ConferenceFeedbacksCreateManyByUserInputEnvelope
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
  }

  export type ConferenceFollowsUncheckedCreateNestedManyWithoutByUserInput = {
    create?: XOR<ConferenceFollowsCreateWithoutByUserInput, ConferenceFollowsUncheckedCreateWithoutByUserInput> | ConferenceFollowsCreateWithoutByUserInput[] | ConferenceFollowsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutByUserInput | ConferenceFollowsCreateOrConnectWithoutByUserInput[]
    createMany?: ConferenceFollowsCreateManyByUserInputEnvelope
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
  }

  export type ConferenceLikesUncheckedCreateNestedManyWithoutByUserInput = {
    create?: XOR<ConferenceLikesCreateWithoutByUserInput, ConferenceLikesUncheckedCreateWithoutByUserInput> | ConferenceLikesCreateWithoutByUserInput[] | ConferenceLikesUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutByUserInput | ConferenceLikesCreateOrConnectWithoutByUserInput[]
    createMany?: ConferenceLikesCreateManyByUserInputEnvelope
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
  }

  export type ConferenceCalendarsUncheckedCreateNestedManyWithoutByUserInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutByUserInput, ConferenceCalendarsUncheckedCreateWithoutByUserInput> | ConferenceCalendarsCreateWithoutByUserInput[] | ConferenceCalendarsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutByUserInput | ConferenceCalendarsCreateOrConnectWithoutByUserInput[]
    createMany?: ConferenceCalendarsCreateManyByUserInputEnvelope
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
  }

  export type ConferencesUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<ConferencesCreateWithoutCreatedByUserInput, ConferencesUncheckedCreateWithoutCreatedByUserInput> | ConferencesCreateWithoutCreatedByUserInput[] | ConferencesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutCreatedByUserInput | ConferencesCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: ConferencesCreateManyCreatedByUserInputEnvelope
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
  }

  export type JournalsUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<JournalsCreateWithoutCreatedByUserInput, JournalsUncheckedCreateWithoutCreatedByUserInput> | JournalsCreateWithoutCreatedByUserInput[] | JournalsUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: JournalsCreateOrConnectWithoutCreatedByUserInput | JournalsCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: JournalsCreateManyCreatedByUserInputEnvelope
    connect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
  }

  export type JournalLikesUncheckedCreateNestedManyWithoutByUserInput = {
    create?: XOR<JournalLikesCreateWithoutByUserInput, JournalLikesUncheckedCreateWithoutByUserInput> | JournalLikesCreateWithoutByUserInput[] | JournalLikesUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutByUserInput | JournalLikesCreateOrConnectWithoutByUserInput[]
    createMany?: JournalLikesCreateManyByUserInputEnvelope
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
  }

  export type JournalFollowsUncheckedCreateNestedManyWithoutByUserInput = {
    create?: XOR<JournalFollowsCreateWithoutByUserInput, JournalFollowsUncheckedCreateWithoutByUserInput> | JournalFollowsCreateWithoutByUserInput[] | JournalFollowsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutByUserInput | JournalFollowsCreateOrConnectWithoutByUserInput[]
    createMany?: JournalFollowsCreateManyByUserInputEnvelope
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
  }

  export type ConferenceFeedbacksUncheckedCreateNestedManyWithoutByUserInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutByUserInput, ConferenceFeedbacksUncheckedCreateWithoutByUserInput> | ConferenceFeedbacksCreateWithoutByUserInput[] | ConferenceFeedbacksUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutByUserInput | ConferenceFeedbacksCreateOrConnectWithoutByUserInput[]
    createMany?: ConferenceFeedbacksCreateManyByUserInputEnvelope
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
  }

  export type ConferenceFollowsUpdateManyWithoutByUserNestedInput = {
    create?: XOR<ConferenceFollowsCreateWithoutByUserInput, ConferenceFollowsUncheckedCreateWithoutByUserInput> | ConferenceFollowsCreateWithoutByUserInput[] | ConferenceFollowsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutByUserInput | ConferenceFollowsCreateOrConnectWithoutByUserInput[]
    upsert?: ConferenceFollowsUpsertWithWhereUniqueWithoutByUserInput | ConferenceFollowsUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: ConferenceFollowsCreateManyByUserInputEnvelope
    set?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    disconnect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    delete?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    update?: ConferenceFollowsUpdateWithWhereUniqueWithoutByUserInput | ConferenceFollowsUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: ConferenceFollowsUpdateManyWithWhereWithoutByUserInput | ConferenceFollowsUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
  }

  export type ConferenceLikesUpdateManyWithoutByUserNestedInput = {
    create?: XOR<ConferenceLikesCreateWithoutByUserInput, ConferenceLikesUncheckedCreateWithoutByUserInput> | ConferenceLikesCreateWithoutByUserInput[] | ConferenceLikesUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutByUserInput | ConferenceLikesCreateOrConnectWithoutByUserInput[]
    upsert?: ConferenceLikesUpsertWithWhereUniqueWithoutByUserInput | ConferenceLikesUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: ConferenceLikesCreateManyByUserInputEnvelope
    set?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    disconnect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    delete?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    update?: ConferenceLikesUpdateWithWhereUniqueWithoutByUserInput | ConferenceLikesUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: ConferenceLikesUpdateManyWithWhereWithoutByUserInput | ConferenceLikesUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
  }

  export type ConferenceCalendarsUpdateManyWithoutByUserNestedInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutByUserInput, ConferenceCalendarsUncheckedCreateWithoutByUserInput> | ConferenceCalendarsCreateWithoutByUserInput[] | ConferenceCalendarsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutByUserInput | ConferenceCalendarsCreateOrConnectWithoutByUserInput[]
    upsert?: ConferenceCalendarsUpsertWithWhereUniqueWithoutByUserInput | ConferenceCalendarsUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: ConferenceCalendarsCreateManyByUserInputEnvelope
    set?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    disconnect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    delete?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    update?: ConferenceCalendarsUpdateWithWhereUniqueWithoutByUserInput | ConferenceCalendarsUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: ConferenceCalendarsUpdateManyWithWhereWithoutByUserInput | ConferenceCalendarsUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
  }

  export type ConferencesUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<ConferencesCreateWithoutCreatedByUserInput, ConferencesUncheckedCreateWithoutCreatedByUserInput> | ConferencesCreateWithoutCreatedByUserInput[] | ConferencesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutCreatedByUserInput | ConferencesCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: ConferencesUpsertWithWhereUniqueWithoutCreatedByUserInput | ConferencesUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: ConferencesCreateManyCreatedByUserInputEnvelope
    set?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    disconnect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    delete?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    update?: ConferencesUpdateWithWhereUniqueWithoutCreatedByUserInput | ConferencesUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: ConferencesUpdateManyWithWhereWithoutCreatedByUserInput | ConferencesUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: ConferencesScalarWhereInput | ConferencesScalarWhereInput[]
  }

  export type JournalsUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<JournalsCreateWithoutCreatedByUserInput, JournalsUncheckedCreateWithoutCreatedByUserInput> | JournalsCreateWithoutCreatedByUserInput[] | JournalsUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: JournalsCreateOrConnectWithoutCreatedByUserInput | JournalsCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: JournalsUpsertWithWhereUniqueWithoutCreatedByUserInput | JournalsUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: JournalsCreateManyCreatedByUserInputEnvelope
    set?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    disconnect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    delete?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    connect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    update?: JournalsUpdateWithWhereUniqueWithoutCreatedByUserInput | JournalsUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: JournalsUpdateManyWithWhereWithoutCreatedByUserInput | JournalsUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: JournalsScalarWhereInput | JournalsScalarWhereInput[]
  }

  export type JournalLikesUpdateManyWithoutByUserNestedInput = {
    create?: XOR<JournalLikesCreateWithoutByUserInput, JournalLikesUncheckedCreateWithoutByUserInput> | JournalLikesCreateWithoutByUserInput[] | JournalLikesUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutByUserInput | JournalLikesCreateOrConnectWithoutByUserInput[]
    upsert?: JournalLikesUpsertWithWhereUniqueWithoutByUserInput | JournalLikesUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: JournalLikesCreateManyByUserInputEnvelope
    set?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    disconnect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    delete?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    update?: JournalLikesUpdateWithWhereUniqueWithoutByUserInput | JournalLikesUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: JournalLikesUpdateManyWithWhereWithoutByUserInput | JournalLikesUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
  }

  export type JournalFollowsUpdateManyWithoutByUserNestedInput = {
    create?: XOR<JournalFollowsCreateWithoutByUserInput, JournalFollowsUncheckedCreateWithoutByUserInput> | JournalFollowsCreateWithoutByUserInput[] | JournalFollowsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutByUserInput | JournalFollowsCreateOrConnectWithoutByUserInput[]
    upsert?: JournalFollowsUpsertWithWhereUniqueWithoutByUserInput | JournalFollowsUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: JournalFollowsCreateManyByUserInputEnvelope
    set?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    disconnect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    delete?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    update?: JournalFollowsUpdateWithWhereUniqueWithoutByUserInput | JournalFollowsUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: JournalFollowsUpdateManyWithWhereWithoutByUserInput | JournalFollowsUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
  }

  export type ConferenceFeedbacksUpdateManyWithoutByUserNestedInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutByUserInput, ConferenceFeedbacksUncheckedCreateWithoutByUserInput> | ConferenceFeedbacksCreateWithoutByUserInput[] | ConferenceFeedbacksUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutByUserInput | ConferenceFeedbacksCreateOrConnectWithoutByUserInput[]
    upsert?: ConferenceFeedbacksUpsertWithWhereUniqueWithoutByUserInput | ConferenceFeedbacksUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: ConferenceFeedbacksCreateManyByUserInputEnvelope
    set?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    disconnect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    delete?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    update?: ConferenceFeedbacksUpdateWithWhereUniqueWithoutByUserInput | ConferenceFeedbacksUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: ConferenceFeedbacksUpdateManyWithWhereWithoutByUserInput | ConferenceFeedbacksUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
  }

  export type ConferenceFollowsUncheckedUpdateManyWithoutByUserNestedInput = {
    create?: XOR<ConferenceFollowsCreateWithoutByUserInput, ConferenceFollowsUncheckedCreateWithoutByUserInput> | ConferenceFollowsCreateWithoutByUserInput[] | ConferenceFollowsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceFollowsCreateOrConnectWithoutByUserInput | ConferenceFollowsCreateOrConnectWithoutByUserInput[]
    upsert?: ConferenceFollowsUpsertWithWhereUniqueWithoutByUserInput | ConferenceFollowsUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: ConferenceFollowsCreateManyByUserInputEnvelope
    set?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    disconnect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    delete?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    connect?: ConferenceFollowsWhereUniqueInput | ConferenceFollowsWhereUniqueInput[]
    update?: ConferenceFollowsUpdateWithWhereUniqueWithoutByUserInput | ConferenceFollowsUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: ConferenceFollowsUpdateManyWithWhereWithoutByUserInput | ConferenceFollowsUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
  }

  export type ConferenceLikesUncheckedUpdateManyWithoutByUserNestedInput = {
    create?: XOR<ConferenceLikesCreateWithoutByUserInput, ConferenceLikesUncheckedCreateWithoutByUserInput> | ConferenceLikesCreateWithoutByUserInput[] | ConferenceLikesUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceLikesCreateOrConnectWithoutByUserInput | ConferenceLikesCreateOrConnectWithoutByUserInput[]
    upsert?: ConferenceLikesUpsertWithWhereUniqueWithoutByUserInput | ConferenceLikesUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: ConferenceLikesCreateManyByUserInputEnvelope
    set?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    disconnect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    delete?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    connect?: ConferenceLikesWhereUniqueInput | ConferenceLikesWhereUniqueInput[]
    update?: ConferenceLikesUpdateWithWhereUniqueWithoutByUserInput | ConferenceLikesUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: ConferenceLikesUpdateManyWithWhereWithoutByUserInput | ConferenceLikesUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
  }

  export type ConferenceCalendarsUncheckedUpdateManyWithoutByUserNestedInput = {
    create?: XOR<ConferenceCalendarsCreateWithoutByUserInput, ConferenceCalendarsUncheckedCreateWithoutByUserInput> | ConferenceCalendarsCreateWithoutByUserInput[] | ConferenceCalendarsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceCalendarsCreateOrConnectWithoutByUserInput | ConferenceCalendarsCreateOrConnectWithoutByUserInput[]
    upsert?: ConferenceCalendarsUpsertWithWhereUniqueWithoutByUserInput | ConferenceCalendarsUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: ConferenceCalendarsCreateManyByUserInputEnvelope
    set?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    disconnect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    delete?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    connect?: ConferenceCalendarsWhereUniqueInput | ConferenceCalendarsWhereUniqueInput[]
    update?: ConferenceCalendarsUpdateWithWhereUniqueWithoutByUserInput | ConferenceCalendarsUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: ConferenceCalendarsUpdateManyWithWhereWithoutByUserInput | ConferenceCalendarsUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
  }

  export type ConferencesUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<ConferencesCreateWithoutCreatedByUserInput, ConferencesUncheckedCreateWithoutCreatedByUserInput> | ConferencesCreateWithoutCreatedByUserInput[] | ConferencesUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ConferencesCreateOrConnectWithoutCreatedByUserInput | ConferencesCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: ConferencesUpsertWithWhereUniqueWithoutCreatedByUserInput | ConferencesUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: ConferencesCreateManyCreatedByUserInputEnvelope
    set?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    disconnect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    delete?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    connect?: ConferencesWhereUniqueInput | ConferencesWhereUniqueInput[]
    update?: ConferencesUpdateWithWhereUniqueWithoutCreatedByUserInput | ConferencesUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: ConferencesUpdateManyWithWhereWithoutCreatedByUserInput | ConferencesUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: ConferencesScalarWhereInput | ConferencesScalarWhereInput[]
  }

  export type JournalsUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<JournalsCreateWithoutCreatedByUserInput, JournalsUncheckedCreateWithoutCreatedByUserInput> | JournalsCreateWithoutCreatedByUserInput[] | JournalsUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: JournalsCreateOrConnectWithoutCreatedByUserInput | JournalsCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: JournalsUpsertWithWhereUniqueWithoutCreatedByUserInput | JournalsUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: JournalsCreateManyCreatedByUserInputEnvelope
    set?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    disconnect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    delete?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    connect?: JournalsWhereUniqueInput | JournalsWhereUniqueInput[]
    update?: JournalsUpdateWithWhereUniqueWithoutCreatedByUserInput | JournalsUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: JournalsUpdateManyWithWhereWithoutCreatedByUserInput | JournalsUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: JournalsScalarWhereInput | JournalsScalarWhereInput[]
  }

  export type JournalLikesUncheckedUpdateManyWithoutByUserNestedInput = {
    create?: XOR<JournalLikesCreateWithoutByUserInput, JournalLikesUncheckedCreateWithoutByUserInput> | JournalLikesCreateWithoutByUserInput[] | JournalLikesUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: JournalLikesCreateOrConnectWithoutByUserInput | JournalLikesCreateOrConnectWithoutByUserInput[]
    upsert?: JournalLikesUpsertWithWhereUniqueWithoutByUserInput | JournalLikesUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: JournalLikesCreateManyByUserInputEnvelope
    set?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    disconnect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    delete?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    connect?: JournalLikesWhereUniqueInput | JournalLikesWhereUniqueInput[]
    update?: JournalLikesUpdateWithWhereUniqueWithoutByUserInput | JournalLikesUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: JournalLikesUpdateManyWithWhereWithoutByUserInput | JournalLikesUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
  }

  export type JournalFollowsUncheckedUpdateManyWithoutByUserNestedInput = {
    create?: XOR<JournalFollowsCreateWithoutByUserInput, JournalFollowsUncheckedCreateWithoutByUserInput> | JournalFollowsCreateWithoutByUserInput[] | JournalFollowsUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: JournalFollowsCreateOrConnectWithoutByUserInput | JournalFollowsCreateOrConnectWithoutByUserInput[]
    upsert?: JournalFollowsUpsertWithWhereUniqueWithoutByUserInput | JournalFollowsUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: JournalFollowsCreateManyByUserInputEnvelope
    set?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    disconnect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    delete?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    connect?: JournalFollowsWhereUniqueInput | JournalFollowsWhereUniqueInput[]
    update?: JournalFollowsUpdateWithWhereUniqueWithoutByUserInput | JournalFollowsUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: JournalFollowsUpdateManyWithWhereWithoutByUserInput | JournalFollowsUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
  }

  export type ConferenceFeedbacksUncheckedUpdateManyWithoutByUserNestedInput = {
    create?: XOR<ConferenceFeedbacksCreateWithoutByUserInput, ConferenceFeedbacksUncheckedCreateWithoutByUserInput> | ConferenceFeedbacksCreateWithoutByUserInput[] | ConferenceFeedbacksUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ConferenceFeedbacksCreateOrConnectWithoutByUserInput | ConferenceFeedbacksCreateOrConnectWithoutByUserInput[]
    upsert?: ConferenceFeedbacksUpsertWithWhereUniqueWithoutByUserInput | ConferenceFeedbacksUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: ConferenceFeedbacksCreateManyByUserInputEnvelope
    set?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    disconnect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    delete?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    connect?: ConferenceFeedbacksWhereUniqueInput | ConferenceFeedbacksWhereUniqueInput[]
    update?: ConferenceFeedbacksUpdateWithWhereUniqueWithoutByUserInput | ConferenceFeedbacksUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: ConferenceFeedbacksUpdateManyWithWhereWithoutByUserInput | ConferenceFeedbacksUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
  }

  export type ConferencesCreateNestedOneWithoutCrawlJobsInput = {
    create?: XOR<ConferencesCreateWithoutCrawlJobsInput, ConferencesUncheckedCreateWithoutCrawlJobsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutCrawlJobsInput
    connect?: ConferencesWhereUniqueInput
  }

  export type ConferencesUpdateOneRequiredWithoutCrawlJobsNestedInput = {
    create?: XOR<ConferencesCreateWithoutCrawlJobsInput, ConferencesUncheckedCreateWithoutCrawlJobsInput>
    connectOrCreate?: ConferencesCreateOrConnectWithoutCrawlJobsInput
    upsert?: ConferencesUpsertWithoutCrawlJobsInput
    connect?: ConferencesWhereUniqueInput
    update?: XOR<XOR<ConferencesUpdateToOneWithWhereWithoutCrawlJobsInput, ConferencesUpdateWithoutCrawlJobsInput>, ConferencesUncheckedUpdateWithoutCrawlJobsInput>
  }

  export type JournalsCreateNestedOneWithoutCrawlJobsInput = {
    create?: XOR<JournalsCreateWithoutCrawlJobsInput, JournalsUncheckedCreateWithoutCrawlJobsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutCrawlJobsInput
    connect?: JournalsWhereUniqueInput
  }

  export type JournalsUpdateOneRequiredWithoutCrawlJobsNestedInput = {
    create?: XOR<JournalsCreateWithoutCrawlJobsInput, JournalsUncheckedCreateWithoutCrawlJobsInput>
    connectOrCreate?: JournalsCreateOrConnectWithoutCrawlJobsInput
    upsert?: JournalsUpsertWithoutCrawlJobsInput
    connect?: JournalsWhereUniqueInput
    update?: XOR<XOR<JournalsUpdateToOneWithWhereWithoutCrawlJobsInput, JournalsUpdateWithoutCrawlJobsInput>, JournalsUncheckedUpdateWithoutCrawlJobsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ConferenceOrganizationsCreateWithoutLocationsInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conferenceDates?: ConferenceDatesCreateNestedManyWithoutBelongsToInput
    topics?: ConferenceTopicsCreateNestedManyWithoutBelongsToInput
    belongsTo: ConferencesCreateNestedOneWithoutOrganizationsInput
  }

  export type ConferenceOrganizationsUncheckedCreateWithoutLocationsInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conferenceDates?: ConferenceDatesUncheckedCreateNestedManyWithoutBelongsToInput
    topics?: ConferenceTopicsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferenceOrganizationsCreateOrConnectWithoutLocationsInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    create: XOR<ConferenceOrganizationsCreateWithoutLocationsInput, ConferenceOrganizationsUncheckedCreateWithoutLocationsInput>
  }

  export type ConferenceOrganizationsUpsertWithoutLocationsInput = {
    update: XOR<ConferenceOrganizationsUpdateWithoutLocationsInput, ConferenceOrganizationsUncheckedUpdateWithoutLocationsInput>
    create: XOR<ConferenceOrganizationsCreateWithoutLocationsInput, ConferenceOrganizationsUncheckedCreateWithoutLocationsInput>
    where?: ConferenceOrganizationsWhereInput
  }

  export type ConferenceOrganizationsUpdateToOneWithWhereWithoutLocationsInput = {
    where?: ConferenceOrganizationsWhereInput
    data: XOR<ConferenceOrganizationsUpdateWithoutLocationsInput, ConferenceOrganizationsUncheckedUpdateWithoutLocationsInput>
  }

  export type ConferenceOrganizationsUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferenceDates?: ConferenceDatesUpdateManyWithoutBelongsToNestedInput
    topics?: ConferenceTopicsUpdateManyWithoutBelongsToNestedInput
    belongsTo?: ConferencesUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    conferenceId?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferenceDates?: ConferenceDatesUncheckedUpdateManyWithoutBelongsToNestedInput
    topics?: ConferenceTopicsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferenceOrganizationsCreateWithoutConferenceDatesInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationsCreateNestedManyWithoutBelongsToInput
    topics?: ConferenceTopicsCreateNestedManyWithoutBelongsToInput
    belongsTo: ConferencesCreateNestedOneWithoutOrganizationsInput
  }

  export type ConferenceOrganizationsUncheckedCreateWithoutConferenceDatesInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationsUncheckedCreateNestedManyWithoutBelongsToInput
    topics?: ConferenceTopicsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferenceOrganizationsCreateOrConnectWithoutConferenceDatesInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    create: XOR<ConferenceOrganizationsCreateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceDatesInput>
  }

  export type ConferenceOrganizationsUpsertWithoutConferenceDatesInput = {
    update: XOR<ConferenceOrganizationsUpdateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedUpdateWithoutConferenceDatesInput>
    create: XOR<ConferenceOrganizationsCreateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedCreateWithoutConferenceDatesInput>
    where?: ConferenceOrganizationsWhereInput
  }

  export type ConferenceOrganizationsUpdateToOneWithWhereWithoutConferenceDatesInput = {
    where?: ConferenceOrganizationsWhereInput
    data: XOR<ConferenceOrganizationsUpdateWithoutConferenceDatesInput, ConferenceOrganizationsUncheckedUpdateWithoutConferenceDatesInput>
  }

  export type ConferenceOrganizationsUpdateWithoutConferenceDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationsUpdateManyWithoutBelongsToNestedInput
    topics?: ConferenceTopicsUpdateManyWithoutBelongsToNestedInput
    belongsTo?: ConferencesUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateWithoutConferenceDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    conferenceId?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationsUncheckedUpdateManyWithoutBelongsToNestedInput
    topics?: ConferenceTopicsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferenceDatesCreateWithoutBelongsToInput = {
    id?: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
  }

  export type ConferenceDatesUncheckedCreateWithoutBelongsToInput = {
    id?: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
  }

  export type ConferenceDatesCreateOrConnectWithoutBelongsToInput = {
    where: ConferenceDatesWhereUniqueInput
    create: XOR<ConferenceDatesCreateWithoutBelongsToInput, ConferenceDatesUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceDatesCreateManyBelongsToInputEnvelope = {
    data: ConferenceDatesCreateManyBelongsToInput | ConferenceDatesCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type LocationsCreateWithoutBelongsToInput = {
    id?: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
  }

  export type LocationsUncheckedCreateWithoutBelongsToInput = {
    id?: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
  }

  export type LocationsCreateOrConnectWithoutBelongsToInput = {
    where: LocationsWhereUniqueInput
    create: XOR<LocationsCreateWithoutBelongsToInput, LocationsUncheckedCreateWithoutBelongsToInput>
  }

  export type LocationsCreateManyBelongsToInputEnvelope = {
    data: LocationsCreateManyBelongsToInput | LocationsCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceTopicsCreateWithoutBelongsToInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inTopic: TopicsCreateNestedOneWithoutInConferenceTopicsInput
  }

  export type ConferenceTopicsUncheckedCreateWithoutBelongsToInput = {
    id?: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceTopicsCreateOrConnectWithoutBelongsToInput = {
    where: ConferenceTopicsWhereUniqueInput
    create: XOR<ConferenceTopicsCreateWithoutBelongsToInput, ConferenceTopicsUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceTopicsCreateManyBelongsToInputEnvelope = {
    data: ConferenceTopicsCreateManyBelongsToInput | ConferenceTopicsCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type ConferencesCreateWithoutOrganizationsInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedConferencesInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    title: string
    acronym: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesCreateOrConnectWithoutOrganizationsInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutOrganizationsInput, ConferencesUncheckedCreateWithoutOrganizationsInput>
  }

  export type ConferenceDatesUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceDatesWhereUniqueInput
    update: XOR<ConferenceDatesUpdateWithoutBelongsToInput, ConferenceDatesUncheckedUpdateWithoutBelongsToInput>
    create: XOR<ConferenceDatesCreateWithoutBelongsToInput, ConferenceDatesUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceDatesUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceDatesWhereUniqueInput
    data: XOR<ConferenceDatesUpdateWithoutBelongsToInput, ConferenceDatesUncheckedUpdateWithoutBelongsToInput>
  }

  export type ConferenceDatesUpdateManyWithWhereWithoutBelongsToInput = {
    where: ConferenceDatesScalarWhereInput
    data: XOR<ConferenceDatesUpdateManyMutationInput, ConferenceDatesUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type ConferenceDatesScalarWhereInput = {
    AND?: ConferenceDatesScalarWhereInput | ConferenceDatesScalarWhereInput[]
    OR?: ConferenceDatesScalarWhereInput[]
    NOT?: ConferenceDatesScalarWhereInput | ConferenceDatesScalarWhereInput[]
    id?: StringFilter<"ConferenceDates"> | string
    organizedId?: StringFilter<"ConferenceDates"> | string
    fromDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    toDate?: DateTimeFilter<"ConferenceDates"> | Date | string
    type?: StringFilter<"ConferenceDates"> | string
    name?: StringFilter<"ConferenceDates"> | string
    createdAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceDates"> | Date | string
    isAvailable?: BoolFilter<"ConferenceDates"> | boolean
  }

  export type LocationsUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: LocationsWhereUniqueInput
    update: XOR<LocationsUpdateWithoutBelongsToInput, LocationsUncheckedUpdateWithoutBelongsToInput>
    create: XOR<LocationsCreateWithoutBelongsToInput, LocationsUncheckedCreateWithoutBelongsToInput>
  }

  export type LocationsUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: LocationsWhereUniqueInput
    data: XOR<LocationsUpdateWithoutBelongsToInput, LocationsUncheckedUpdateWithoutBelongsToInput>
  }

  export type LocationsUpdateManyWithWhereWithoutBelongsToInput = {
    where: LocationsScalarWhereInput
    data: XOR<LocationsUpdateManyMutationInput, LocationsUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type LocationsScalarWhereInput = {
    AND?: LocationsScalarWhereInput | LocationsScalarWhereInput[]
    OR?: LocationsScalarWhereInput[]
    NOT?: LocationsScalarWhereInput | LocationsScalarWhereInput[]
    id?: StringFilter<"Locations"> | string
    address?: StringNullableFilter<"Locations"> | string | null
    cityStateProvince?: StringNullableFilter<"Locations"> | string | null
    country?: StringNullableFilter<"Locations"> | string | null
    continent?: StringNullableFilter<"Locations"> | string | null
    createdAt?: DateTimeFilter<"Locations"> | Date | string
    updatedAt?: DateTimeFilter<"Locations"> | Date | string
    isAvailable?: BoolFilter<"Locations"> | boolean
    organizeId?: StringFilter<"Locations"> | string
  }

  export type ConferenceTopicsUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceTopicsWhereUniqueInput
    update: XOR<ConferenceTopicsUpdateWithoutBelongsToInput, ConferenceTopicsUncheckedUpdateWithoutBelongsToInput>
    create: XOR<ConferenceTopicsCreateWithoutBelongsToInput, ConferenceTopicsUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceTopicsUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceTopicsWhereUniqueInput
    data: XOR<ConferenceTopicsUpdateWithoutBelongsToInput, ConferenceTopicsUncheckedUpdateWithoutBelongsToInput>
  }

  export type ConferenceTopicsUpdateManyWithWhereWithoutBelongsToInput = {
    where: ConferenceTopicsScalarWhereInput
    data: XOR<ConferenceTopicsUpdateManyMutationInput, ConferenceTopicsUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type ConferenceTopicsScalarWhereInput = {
    AND?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
    OR?: ConferenceTopicsScalarWhereInput[]
    NOT?: ConferenceTopicsScalarWhereInput | ConferenceTopicsScalarWhereInput[]
    id?: StringFilter<"ConferenceTopics"> | string
    organizeId?: StringFilter<"ConferenceTopics"> | string
    topicId?: StringFilter<"ConferenceTopics"> | string
    createdAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceTopics"> | Date | string
  }

  export type ConferencesUpsertWithoutOrganizationsInput = {
    update: XOR<ConferencesUpdateWithoutOrganizationsInput, ConferencesUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<ConferencesCreateWithoutOrganizationsInput, ConferencesUncheckedCreateWithoutOrganizationsInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutOrganizationsInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutOrganizationsInput, ConferencesUncheckedUpdateWithoutOrganizationsInput>
  }

  export type ConferencesUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedConferencesNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferenceOrganizationsCreateWithoutTopicsInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conferenceDates?: ConferenceDatesCreateNestedManyWithoutBelongsToInput
    locations?: LocationsCreateNestedManyWithoutBelongsToInput
    belongsTo: ConferencesCreateNestedOneWithoutOrganizationsInput
  }

  export type ConferenceOrganizationsUncheckedCreateWithoutTopicsInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    conferenceId: string
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conferenceDates?: ConferenceDatesUncheckedCreateNestedManyWithoutBelongsToInput
    locations?: LocationsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferenceOrganizationsCreateOrConnectWithoutTopicsInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    create: XOR<ConferenceOrganizationsCreateWithoutTopicsInput, ConferenceOrganizationsUncheckedCreateWithoutTopicsInput>
  }

  export type TopicsCreateWithoutInConferenceTopicsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inJournalTopics?: JournalTopicsCreateNestedManyWithoutBelongsToTopicsInput
  }

  export type TopicsUncheckedCreateWithoutInConferenceTopicsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inJournalTopics?: JournalTopicsUncheckedCreateNestedManyWithoutBelongsToTopicsInput
  }

  export type TopicsCreateOrConnectWithoutInConferenceTopicsInput = {
    where: TopicsWhereUniqueInput
    create: XOR<TopicsCreateWithoutInConferenceTopicsInput, TopicsUncheckedCreateWithoutInConferenceTopicsInput>
  }

  export type ConferenceOrganizationsUpsertWithoutTopicsInput = {
    update: XOR<ConferenceOrganizationsUpdateWithoutTopicsInput, ConferenceOrganizationsUncheckedUpdateWithoutTopicsInput>
    create: XOR<ConferenceOrganizationsCreateWithoutTopicsInput, ConferenceOrganizationsUncheckedCreateWithoutTopicsInput>
    where?: ConferenceOrganizationsWhereInput
  }

  export type ConferenceOrganizationsUpdateToOneWithWhereWithoutTopicsInput = {
    where?: ConferenceOrganizationsWhereInput
    data: XOR<ConferenceOrganizationsUpdateWithoutTopicsInput, ConferenceOrganizationsUncheckedUpdateWithoutTopicsInput>
  }

  export type ConferenceOrganizationsUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferenceDates?: ConferenceDatesUpdateManyWithoutBelongsToNestedInput
    locations?: LocationsUpdateManyWithoutBelongsToNestedInput
    belongsTo?: ConferencesUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    conferenceId?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferenceDates?: ConferenceDatesUncheckedUpdateManyWithoutBelongsToNestedInput
    locations?: LocationsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type TopicsUpsertWithoutInConferenceTopicsInput = {
    update: XOR<TopicsUpdateWithoutInConferenceTopicsInput, TopicsUncheckedUpdateWithoutInConferenceTopicsInput>
    create: XOR<TopicsCreateWithoutInConferenceTopicsInput, TopicsUncheckedCreateWithoutInConferenceTopicsInput>
    where?: TopicsWhereInput
  }

  export type TopicsUpdateToOneWithWhereWithoutInConferenceTopicsInput = {
    where?: TopicsWhereInput
    data: XOR<TopicsUpdateWithoutInConferenceTopicsInput, TopicsUncheckedUpdateWithoutInConferenceTopicsInput>
  }

  export type TopicsUpdateWithoutInConferenceTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inJournalTopics?: JournalTopicsUpdateManyWithoutBelongsToTopicsNestedInput
  }

  export type TopicsUncheckedUpdateWithoutInConferenceTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inJournalTopics?: JournalTopicsUncheckedUpdateManyWithoutBelongsToTopicsNestedInput
  }

  export type ConferenceTopicsCreateWithoutInTopicInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferenceOrganizationsCreateNestedOneWithoutTopicsInput
  }

  export type ConferenceTopicsUncheckedCreateWithoutInTopicInput = {
    id?: string
    organizeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceTopicsCreateOrConnectWithoutInTopicInput = {
    where: ConferenceTopicsWhereUniqueInput
    create: XOR<ConferenceTopicsCreateWithoutInTopicInput, ConferenceTopicsUncheckedCreateWithoutInTopicInput>
  }

  export type ConferenceTopicsCreateManyInTopicInputEnvelope = {
    data: ConferenceTopicsCreateManyInTopicInput | ConferenceTopicsCreateManyInTopicInput[]
    skipDuplicates?: boolean
  }

  export type JournalTopicsCreateWithoutBelongsToTopicsInput = {
    id?: string
    inJournals: JournalsCreateNestedOneWithoutTopicsInput
  }

  export type JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput = {
    id?: string
    journalId: string
  }

  export type JournalTopicsCreateOrConnectWithoutBelongsToTopicsInput = {
    where: JournalTopicsWhereUniqueInput
    create: XOR<JournalTopicsCreateWithoutBelongsToTopicsInput, JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput>
  }

  export type JournalTopicsCreateManyBelongsToTopicsInputEnvelope = {
    data: JournalTopicsCreateManyBelongsToTopicsInput | JournalTopicsCreateManyBelongsToTopicsInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceTopicsUpsertWithWhereUniqueWithoutInTopicInput = {
    where: ConferenceTopicsWhereUniqueInput
    update: XOR<ConferenceTopicsUpdateWithoutInTopicInput, ConferenceTopicsUncheckedUpdateWithoutInTopicInput>
    create: XOR<ConferenceTopicsCreateWithoutInTopicInput, ConferenceTopicsUncheckedCreateWithoutInTopicInput>
  }

  export type ConferenceTopicsUpdateWithWhereUniqueWithoutInTopicInput = {
    where: ConferenceTopicsWhereUniqueInput
    data: XOR<ConferenceTopicsUpdateWithoutInTopicInput, ConferenceTopicsUncheckedUpdateWithoutInTopicInput>
  }

  export type ConferenceTopicsUpdateManyWithWhereWithoutInTopicInput = {
    where: ConferenceTopicsScalarWhereInput
    data: XOR<ConferenceTopicsUpdateManyMutationInput, ConferenceTopicsUncheckedUpdateManyWithoutInTopicInput>
  }

  export type JournalTopicsUpsertWithWhereUniqueWithoutBelongsToTopicsInput = {
    where: JournalTopicsWhereUniqueInput
    update: XOR<JournalTopicsUpdateWithoutBelongsToTopicsInput, JournalTopicsUncheckedUpdateWithoutBelongsToTopicsInput>
    create: XOR<JournalTopicsCreateWithoutBelongsToTopicsInput, JournalTopicsUncheckedCreateWithoutBelongsToTopicsInput>
  }

  export type JournalTopicsUpdateWithWhereUniqueWithoutBelongsToTopicsInput = {
    where: JournalTopicsWhereUniqueInput
    data: XOR<JournalTopicsUpdateWithoutBelongsToTopicsInput, JournalTopicsUncheckedUpdateWithoutBelongsToTopicsInput>
  }

  export type JournalTopicsUpdateManyWithWhereWithoutBelongsToTopicsInput = {
    where: JournalTopicsScalarWhereInput
    data: XOR<JournalTopicsUpdateManyMutationInput, JournalTopicsUncheckedUpdateManyWithoutBelongsToTopicsInput>
  }

  export type JournalTopicsScalarWhereInput = {
    AND?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
    OR?: JournalTopicsScalarWhereInput[]
    NOT?: JournalTopicsScalarWhereInput | JournalTopicsScalarWhereInput[]
    id?: StringFilter<"JournalTopics"> | string
    journalId?: StringFilter<"JournalTopics"> | string
    topicId?: StringFilter<"JournalTopics"> | string
  }

  export type ConferenceFollowsCreateWithoutBelongsToInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    byUser: UsersCreateNestedOneWithoutFollowConferenceInput
  }

  export type ConferenceFollowsUncheckedCreateWithoutBelongsToInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFollowsCreateOrConnectWithoutBelongsToInput = {
    where: ConferenceFollowsWhereUniqueInput
    create: XOR<ConferenceFollowsCreateWithoutBelongsToInput, ConferenceFollowsUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceFollowsCreateManyBelongsToInputEnvelope = {
    data: ConferenceFollowsCreateManyBelongsToInput | ConferenceFollowsCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceLikesCreateWithoutBelongsToInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    byUser: UsersCreateNestedOneWithoutLikesInput
  }

  export type ConferenceLikesUncheckedCreateWithoutBelongsToInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceLikesCreateOrConnectWithoutBelongsToInput = {
    where: ConferenceLikesWhereUniqueInput
    create: XOR<ConferenceLikesCreateWithoutBelongsToInput, ConferenceLikesUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceLikesCreateManyBelongsToInputEnvelope = {
    data: ConferenceLikesCreateManyBelongsToInput | ConferenceLikesCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceCalendarsCreateWithoutBelongsToInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    byUser: UsersCreateNestedOneWithoutCalendarInput
  }

  export type ConferenceCalendarsUncheckedCreateWithoutBelongsToInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceCalendarsCreateOrConnectWithoutBelongsToInput = {
    where: ConferenceCalendarsWhereUniqueInput
    create: XOR<ConferenceCalendarsCreateWithoutBelongsToInput, ConferenceCalendarsUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceCalendarsCreateManyBelongsToInputEnvelope = {
    data: ConferenceCalendarsCreateManyBelongsToInput | ConferenceCalendarsCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceOrganizationsCreateWithoutBelongsToInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conferenceDates?: ConferenceDatesCreateNestedManyWithoutBelongsToInput
    locations?: LocationsCreateNestedManyWithoutBelongsToInput
    topics?: ConferenceTopicsCreateNestedManyWithoutBelongsToInput
  }

  export type ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conferenceDates?: ConferenceDatesUncheckedCreateNestedManyWithoutBelongsToInput
    locations?: LocationsUncheckedCreateNestedManyWithoutBelongsToInput
    topics?: ConferenceTopicsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferenceOrganizationsCreateOrConnectWithoutBelongsToInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    create: XOR<ConferenceOrganizationsCreateWithoutBelongsToInput, ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceOrganizationsCreateManyBelongsToInputEnvelope = {
    data: ConferenceOrganizationsCreateManyBelongsToInput | ConferenceOrganizationsCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceRanksCreateWithoutBelongsToInput = {
    id?: string
    year: number
    inFieldOfResearch: FieldOfResearchsCreateNestedOneWithoutConferenceRanksInput
    byRank: RanksCreateNestedOneWithoutConferenceRanksInput
  }

  export type ConferenceRanksUncheckedCreateWithoutBelongsToInput = {
    id?: string
    year: number
    fieldOfResearchId: string
    rankId: string
  }

  export type ConferenceRanksCreateOrConnectWithoutBelongsToInput = {
    where: ConferenceRanksWhereUniqueInput
    create: XOR<ConferenceRanksCreateWithoutBelongsToInput, ConferenceRanksUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceRanksCreateManyBelongsToInputEnvelope = {
    data: ConferenceRanksCreateManyBelongsToInput | ConferenceRanksCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceCrawlJobsCreateWithoutBelongsToInput = {
    id?: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput = {
    id?: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceCrawlJobsCreateOrConnectWithoutBelongsToInput = {
    where: ConferenceCrawlJobsWhereUniqueInput
    create: XOR<ConferenceCrawlJobsCreateWithoutBelongsToInput, ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceCrawlJobsCreateManyBelongsToInputEnvelope = {
    data: ConferenceCrawlJobsCreateManyBelongsToInput | ConferenceCrawlJobsCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutCreatedConferencesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsCreateNestedManyWithoutByUserInput
    createdJournals?: JournalsCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutByUserInput
  }

  export type UsersUncheckedCreateWithoutCreatedConferencesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsUncheckedCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsUncheckedCreateNestedManyWithoutByUserInput
    createdJournals?: JournalsUncheckedCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutByUserInput
  }

  export type UsersCreateOrConnectWithoutCreatedConferencesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCreatedConferencesInput, UsersUncheckedCreateWithoutCreatedConferencesInput>
  }

  export type ConferenceFeedbacksCreateWithoutBelongsToInput = {
    id?: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt?: Date | string
    byUser: UsersCreateNestedOneWithoutFeedbacksInput
  }

  export type ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput = {
    id?: string
    creatorId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFeedbacksCreateOrConnectWithoutBelongsToInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    create: XOR<ConferenceFeedbacksCreateWithoutBelongsToInput, ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceFeedbacksCreateManyBelongsToInputEnvelope = {
    data: ConferenceFeedbacksCreateManyBelongsToInput | ConferenceFeedbacksCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceFollowsUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceFollowsWhereUniqueInput
    update: XOR<ConferenceFollowsUpdateWithoutBelongsToInput, ConferenceFollowsUncheckedUpdateWithoutBelongsToInput>
    create: XOR<ConferenceFollowsCreateWithoutBelongsToInput, ConferenceFollowsUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceFollowsUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceFollowsWhereUniqueInput
    data: XOR<ConferenceFollowsUpdateWithoutBelongsToInput, ConferenceFollowsUncheckedUpdateWithoutBelongsToInput>
  }

  export type ConferenceFollowsUpdateManyWithWhereWithoutBelongsToInput = {
    where: ConferenceFollowsScalarWhereInput
    data: XOR<ConferenceFollowsUpdateManyMutationInput, ConferenceFollowsUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type ConferenceFollowsScalarWhereInput = {
    AND?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
    OR?: ConferenceFollowsScalarWhereInput[]
    NOT?: ConferenceFollowsScalarWhereInput | ConferenceFollowsScalarWhereInput[]
    id?: StringFilter<"ConferenceFollows"> | string
    conferenceId?: StringFilter<"ConferenceFollows"> | string
    userId?: StringFilter<"ConferenceFollows"> | string
    createdAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFollows"> | Date | string
  }

  export type ConferenceLikesUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceLikesWhereUniqueInput
    update: XOR<ConferenceLikesUpdateWithoutBelongsToInput, ConferenceLikesUncheckedUpdateWithoutBelongsToInput>
    create: XOR<ConferenceLikesCreateWithoutBelongsToInput, ConferenceLikesUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceLikesUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceLikesWhereUniqueInput
    data: XOR<ConferenceLikesUpdateWithoutBelongsToInput, ConferenceLikesUncheckedUpdateWithoutBelongsToInput>
  }

  export type ConferenceLikesUpdateManyWithWhereWithoutBelongsToInput = {
    where: ConferenceLikesScalarWhereInput
    data: XOR<ConferenceLikesUpdateManyMutationInput, ConferenceLikesUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type ConferenceLikesScalarWhereInput = {
    AND?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
    OR?: ConferenceLikesScalarWhereInput[]
    NOT?: ConferenceLikesScalarWhereInput | ConferenceLikesScalarWhereInput[]
    id?: StringFilter<"ConferenceLikes"> | string
    conferenceId?: StringFilter<"ConferenceLikes"> | string
    userId?: StringFilter<"ConferenceLikes"> | string
    createdAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceLikes"> | Date | string
  }

  export type ConferenceCalendarsUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceCalendarsWhereUniqueInput
    update: XOR<ConferenceCalendarsUpdateWithoutBelongsToInput, ConferenceCalendarsUncheckedUpdateWithoutBelongsToInput>
    create: XOR<ConferenceCalendarsCreateWithoutBelongsToInput, ConferenceCalendarsUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceCalendarsUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceCalendarsWhereUniqueInput
    data: XOR<ConferenceCalendarsUpdateWithoutBelongsToInput, ConferenceCalendarsUncheckedUpdateWithoutBelongsToInput>
  }

  export type ConferenceCalendarsUpdateManyWithWhereWithoutBelongsToInput = {
    where: ConferenceCalendarsScalarWhereInput
    data: XOR<ConferenceCalendarsUpdateManyMutationInput, ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type ConferenceCalendarsScalarWhereInput = {
    AND?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
    OR?: ConferenceCalendarsScalarWhereInput[]
    NOT?: ConferenceCalendarsScalarWhereInput | ConferenceCalendarsScalarWhereInput[]
    id?: StringFilter<"ConferenceCalendars"> | string
    conferenceId?: StringFilter<"ConferenceCalendars"> | string
    userId?: StringFilter<"ConferenceCalendars"> | string
    createdAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCalendars"> | Date | string
  }

  export type ConferenceOrganizationsUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    update: XOR<ConferenceOrganizationsUpdateWithoutBelongsToInput, ConferenceOrganizationsUncheckedUpdateWithoutBelongsToInput>
    create: XOR<ConferenceOrganizationsCreateWithoutBelongsToInput, ConferenceOrganizationsUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceOrganizationsUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceOrganizationsWhereUniqueInput
    data: XOR<ConferenceOrganizationsUpdateWithoutBelongsToInput, ConferenceOrganizationsUncheckedUpdateWithoutBelongsToInput>
  }

  export type ConferenceOrganizationsUpdateManyWithWhereWithoutBelongsToInput = {
    where: ConferenceOrganizationsScalarWhereInput
    data: XOR<ConferenceOrganizationsUpdateManyMutationInput, ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type ConferenceOrganizationsScalarWhereInput = {
    AND?: ConferenceOrganizationsScalarWhereInput | ConferenceOrganizationsScalarWhereInput[]
    OR?: ConferenceOrganizationsScalarWhereInput[]
    NOT?: ConferenceOrganizationsScalarWhereInput | ConferenceOrganizationsScalarWhereInput[]
    id?: StringFilter<"ConferenceOrganizations"> | string
    year?: IntFilter<"ConferenceOrganizations"> | number
    accessType?: StringFilter<"ConferenceOrganizations"> | string
    isAvailable?: BoolFilter<"ConferenceOrganizations"> | boolean
    conferenceId?: StringFilter<"ConferenceOrganizations"> | string
    publisher?: StringFilter<"ConferenceOrganizations"> | string
    summerize?: StringFilter<"ConferenceOrganizations"> | string
    callForPaper?: StringFilter<"ConferenceOrganizations"> | string
    link?: StringFilter<"ConferenceOrganizations"> | string
    cfpLink?: StringFilter<"ConferenceOrganizations"> | string
    impLink?: StringFilter<"ConferenceOrganizations"> | string
    createdAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceOrganizations"> | Date | string
  }

  export type ConferenceRanksUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceRanksWhereUniqueInput
    update: XOR<ConferenceRanksUpdateWithoutBelongsToInput, ConferenceRanksUncheckedUpdateWithoutBelongsToInput>
    create: XOR<ConferenceRanksCreateWithoutBelongsToInput, ConferenceRanksUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceRanksUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceRanksWhereUniqueInput
    data: XOR<ConferenceRanksUpdateWithoutBelongsToInput, ConferenceRanksUncheckedUpdateWithoutBelongsToInput>
  }

  export type ConferenceRanksUpdateManyWithWhereWithoutBelongsToInput = {
    where: ConferenceRanksScalarWhereInput
    data: XOR<ConferenceRanksUpdateManyMutationInput, ConferenceRanksUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type ConferenceRanksScalarWhereInput = {
    AND?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
    OR?: ConferenceRanksScalarWhereInput[]
    NOT?: ConferenceRanksScalarWhereInput | ConferenceRanksScalarWhereInput[]
    id?: StringFilter<"ConferenceRanks"> | string
    year?: IntFilter<"ConferenceRanks"> | number
    conferenceId?: StringFilter<"ConferenceRanks"> | string
    fieldOfResearchId?: StringFilter<"ConferenceRanks"> | string
    rankId?: StringFilter<"ConferenceRanks"> | string
  }

  export type ConferenceCrawlJobsUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceCrawlJobsWhereUniqueInput
    update: XOR<ConferenceCrawlJobsUpdateWithoutBelongsToInput, ConferenceCrawlJobsUncheckedUpdateWithoutBelongsToInput>
    create: XOR<ConferenceCrawlJobsCreateWithoutBelongsToInput, ConferenceCrawlJobsUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceCrawlJobsUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceCrawlJobsWhereUniqueInput
    data: XOR<ConferenceCrawlJobsUpdateWithoutBelongsToInput, ConferenceCrawlJobsUncheckedUpdateWithoutBelongsToInput>
  }

  export type ConferenceCrawlJobsUpdateManyWithWhereWithoutBelongsToInput = {
    where: ConferenceCrawlJobsScalarWhereInput
    data: XOR<ConferenceCrawlJobsUpdateManyMutationInput, ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type ConferenceCrawlJobsScalarWhereInput = {
    AND?: ConferenceCrawlJobsScalarWhereInput | ConferenceCrawlJobsScalarWhereInput[]
    OR?: ConferenceCrawlJobsScalarWhereInput[]
    NOT?: ConferenceCrawlJobsScalarWhereInput | ConferenceCrawlJobsScalarWhereInput[]
    id?: StringFilter<"ConferenceCrawlJobs"> | string
    conferenceId?: StringFilter<"ConferenceCrawlJobs"> | string
    status?: StringFilter<"ConferenceCrawlJobs"> | string
    progress?: IntFilter<"ConferenceCrawlJobs"> | number
    message?: StringFilter<"ConferenceCrawlJobs"> | string
    createdAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceCrawlJobs"> | Date | string
  }

  export type UsersUpsertWithoutCreatedConferencesInput = {
    update: XOR<UsersUpdateWithoutCreatedConferencesInput, UsersUncheckedUpdateWithoutCreatedConferencesInput>
    create: XOR<UsersCreateWithoutCreatedConferencesInput, UsersUncheckedCreateWithoutCreatedConferencesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCreatedConferencesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCreatedConferencesInput, UsersUncheckedUpdateWithoutCreatedConferencesInput>
  }

  export type UsersUpdateWithoutCreatedConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUpdateManyWithoutByUserNestedInput
    createdJournals?: JournalsUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutByUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutCreatedConferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUncheckedUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUncheckedUpdateManyWithoutByUserNestedInput
    createdJournals?: JournalsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutByUserNestedInput
  }

  export type ConferenceFeedbacksUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    update: XOR<ConferenceFeedbacksUpdateWithoutBelongsToInput, ConferenceFeedbacksUncheckedUpdateWithoutBelongsToInput>
    create: XOR<ConferenceFeedbacksCreateWithoutBelongsToInput, ConferenceFeedbacksUncheckedCreateWithoutBelongsToInput>
  }

  export type ConferenceFeedbacksUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    data: XOR<ConferenceFeedbacksUpdateWithoutBelongsToInput, ConferenceFeedbacksUncheckedUpdateWithoutBelongsToInput>
  }

  export type ConferenceFeedbacksUpdateManyWithWhereWithoutBelongsToInput = {
    where: ConferenceFeedbacksScalarWhereInput
    data: XOR<ConferenceFeedbacksUpdateManyMutationInput, ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type ConferenceFeedbacksScalarWhereInput = {
    AND?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
    OR?: ConferenceFeedbacksScalarWhereInput[]
    NOT?: ConferenceFeedbacksScalarWhereInput | ConferenceFeedbacksScalarWhereInput[]
    id?: StringFilter<"ConferenceFeedbacks"> | string
    conferenceId?: StringFilter<"ConferenceFeedbacks"> | string
    creatorId?: StringFilter<"ConferenceFeedbacks"> | string
    description?: StringFilter<"ConferenceFeedbacks"> | string
    star?: IntFilter<"ConferenceFeedbacks"> | number
    createdAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
    updatedAt?: DateTimeFilter<"ConferenceFeedbacks"> | Date | string
  }

  export type FieldOfResearchsCreateWithoutConferenceRanksInput = {
    id?: string
    name: string
    code: string
    journalRanks?: JournalRanksCreateNestedManyWithoutInFieldOfResearchInput
  }

  export type FieldOfResearchsUncheckedCreateWithoutConferenceRanksInput = {
    id?: string
    name: string
    code: string
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutInFieldOfResearchInput
  }

  export type FieldOfResearchsCreateOrConnectWithoutConferenceRanksInput = {
    where: FieldOfResearchsWhereUniqueInput
    create: XOR<FieldOfResearchsCreateWithoutConferenceRanksInput, FieldOfResearchsUncheckedCreateWithoutConferenceRanksInput>
  }

  export type RanksCreateWithoutConferenceRanksInput = {
    id?: string
    name: string
    value: number
    journalRanks?: JournalRanksCreateNestedManyWithoutByRankInput
    belongsToSource: SourcesCreateNestedOneWithoutRanksInput
  }

  export type RanksUncheckedCreateWithoutConferenceRanksInput = {
    id?: string
    name: string
    value: number
    sourceId: string
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutByRankInput
  }

  export type RanksCreateOrConnectWithoutConferenceRanksInput = {
    where: RanksWhereUniqueInput
    create: XOR<RanksCreateWithoutConferenceRanksInput, RanksUncheckedCreateWithoutConferenceRanksInput>
  }

  export type ConferencesCreateWithoutRanksInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedConferencesInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesUncheckedCreateWithoutRanksInput = {
    id?: string
    title: string
    acronym: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesCreateOrConnectWithoutRanksInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutRanksInput, ConferencesUncheckedCreateWithoutRanksInput>
  }

  export type FieldOfResearchsUpsertWithoutConferenceRanksInput = {
    update: XOR<FieldOfResearchsUpdateWithoutConferenceRanksInput, FieldOfResearchsUncheckedUpdateWithoutConferenceRanksInput>
    create: XOR<FieldOfResearchsCreateWithoutConferenceRanksInput, FieldOfResearchsUncheckedCreateWithoutConferenceRanksInput>
    where?: FieldOfResearchsWhereInput
  }

  export type FieldOfResearchsUpdateToOneWithWhereWithoutConferenceRanksInput = {
    where?: FieldOfResearchsWhereInput
    data: XOR<FieldOfResearchsUpdateWithoutConferenceRanksInput, FieldOfResearchsUncheckedUpdateWithoutConferenceRanksInput>
  }

  export type FieldOfResearchsUpdateWithoutConferenceRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    journalRanks?: JournalRanksUpdateManyWithoutInFieldOfResearchNestedInput
  }

  export type FieldOfResearchsUncheckedUpdateWithoutConferenceRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutInFieldOfResearchNestedInput
  }

  export type RanksUpsertWithoutConferenceRanksInput = {
    update: XOR<RanksUpdateWithoutConferenceRanksInput, RanksUncheckedUpdateWithoutConferenceRanksInput>
    create: XOR<RanksCreateWithoutConferenceRanksInput, RanksUncheckedCreateWithoutConferenceRanksInput>
    where?: RanksWhereInput
  }

  export type RanksUpdateToOneWithWhereWithoutConferenceRanksInput = {
    where?: RanksWhereInput
    data: XOR<RanksUpdateWithoutConferenceRanksInput, RanksUncheckedUpdateWithoutConferenceRanksInput>
  }

  export type RanksUpdateWithoutConferenceRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    journalRanks?: JournalRanksUpdateManyWithoutByRankNestedInput
    belongsToSource?: SourcesUpdateOneRequiredWithoutRanksNestedInput
  }

  export type RanksUncheckedUpdateWithoutConferenceRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutByRankNestedInput
  }

  export type ConferencesUpsertWithoutRanksInput = {
    update: XOR<ConferencesUpdateWithoutRanksInput, ConferencesUncheckedUpdateWithoutRanksInput>
    create: XOR<ConferencesCreateWithoutRanksInput, ConferencesUncheckedCreateWithoutRanksInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutRanksInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutRanksInput, ConferencesUncheckedUpdateWithoutRanksInput>
  }

  export type ConferencesUpdateWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedConferencesNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type JournalRanksCreateWithoutInFieldOfResearchInput = {
    id?: string
    year: number
    byRank: RanksCreateNestedOneWithoutJournalRanksInput
    belongsTo: JournalsCreateNestedOneWithoutJournalRanksInput
  }

  export type JournalRanksUncheckedCreateWithoutInFieldOfResearchInput = {
    id?: string
    year: number
    journalId: string
    rankId: string
  }

  export type JournalRanksCreateOrConnectWithoutInFieldOfResearchInput = {
    where: JournalRanksWhereUniqueInput
    create: XOR<JournalRanksCreateWithoutInFieldOfResearchInput, JournalRanksUncheckedCreateWithoutInFieldOfResearchInput>
  }

  export type JournalRanksCreateManyInFieldOfResearchInputEnvelope = {
    data: JournalRanksCreateManyInFieldOfResearchInput | JournalRanksCreateManyInFieldOfResearchInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceRanksCreateWithoutInFieldOfResearchInput = {
    id?: string
    year: number
    byRank: RanksCreateNestedOneWithoutConferenceRanksInput
    belongsTo: ConferencesCreateNestedOneWithoutRanksInput
  }

  export type ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput = {
    id?: string
    year: number
    conferenceId: string
    rankId: string
  }

  export type ConferenceRanksCreateOrConnectWithoutInFieldOfResearchInput = {
    where: ConferenceRanksWhereUniqueInput
    create: XOR<ConferenceRanksCreateWithoutInFieldOfResearchInput, ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput>
  }

  export type ConferenceRanksCreateManyInFieldOfResearchInputEnvelope = {
    data: ConferenceRanksCreateManyInFieldOfResearchInput | ConferenceRanksCreateManyInFieldOfResearchInput[]
    skipDuplicates?: boolean
  }

  export type JournalRanksUpsertWithWhereUniqueWithoutInFieldOfResearchInput = {
    where: JournalRanksWhereUniqueInput
    update: XOR<JournalRanksUpdateWithoutInFieldOfResearchInput, JournalRanksUncheckedUpdateWithoutInFieldOfResearchInput>
    create: XOR<JournalRanksCreateWithoutInFieldOfResearchInput, JournalRanksUncheckedCreateWithoutInFieldOfResearchInput>
  }

  export type JournalRanksUpdateWithWhereUniqueWithoutInFieldOfResearchInput = {
    where: JournalRanksWhereUniqueInput
    data: XOR<JournalRanksUpdateWithoutInFieldOfResearchInput, JournalRanksUncheckedUpdateWithoutInFieldOfResearchInput>
  }

  export type JournalRanksUpdateManyWithWhereWithoutInFieldOfResearchInput = {
    where: JournalRanksScalarWhereInput
    data: XOR<JournalRanksUpdateManyMutationInput, JournalRanksUncheckedUpdateManyWithoutInFieldOfResearchInput>
  }

  export type JournalRanksScalarWhereInput = {
    AND?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
    OR?: JournalRanksScalarWhereInput[]
    NOT?: JournalRanksScalarWhereInput | JournalRanksScalarWhereInput[]
    id?: StringFilter<"JournalRanks"> | string
    year?: IntFilter<"JournalRanks"> | number
    journalId?: StringFilter<"JournalRanks"> | string
    fieldOfResearchId?: StringFilter<"JournalRanks"> | string
    rankId?: StringFilter<"JournalRanks"> | string
  }

  export type ConferenceRanksUpsertWithWhereUniqueWithoutInFieldOfResearchInput = {
    where: ConferenceRanksWhereUniqueInput
    update: XOR<ConferenceRanksUpdateWithoutInFieldOfResearchInput, ConferenceRanksUncheckedUpdateWithoutInFieldOfResearchInput>
    create: XOR<ConferenceRanksCreateWithoutInFieldOfResearchInput, ConferenceRanksUncheckedCreateWithoutInFieldOfResearchInput>
  }

  export type ConferenceRanksUpdateWithWhereUniqueWithoutInFieldOfResearchInput = {
    where: ConferenceRanksWhereUniqueInput
    data: XOR<ConferenceRanksUpdateWithoutInFieldOfResearchInput, ConferenceRanksUncheckedUpdateWithoutInFieldOfResearchInput>
  }

  export type ConferenceRanksUpdateManyWithWhereWithoutInFieldOfResearchInput = {
    where: ConferenceRanksScalarWhereInput
    data: XOR<ConferenceRanksUpdateManyMutationInput, ConferenceRanksUncheckedUpdateManyWithoutInFieldOfResearchInput>
  }

  export type ConferenceRanksCreateWithoutByRankInput = {
    id?: string
    year: number
    inFieldOfResearch: FieldOfResearchsCreateNestedOneWithoutConferenceRanksInput
    belongsTo: ConferencesCreateNestedOneWithoutRanksInput
  }

  export type ConferenceRanksUncheckedCreateWithoutByRankInput = {
    id?: string
    year: number
    conferenceId: string
    fieldOfResearchId: string
  }

  export type ConferenceRanksCreateOrConnectWithoutByRankInput = {
    where: ConferenceRanksWhereUniqueInput
    create: XOR<ConferenceRanksCreateWithoutByRankInput, ConferenceRanksUncheckedCreateWithoutByRankInput>
  }

  export type ConferenceRanksCreateManyByRankInputEnvelope = {
    data: ConferenceRanksCreateManyByRankInput | ConferenceRanksCreateManyByRankInput[]
    skipDuplicates?: boolean
  }

  export type JournalRanksCreateWithoutByRankInput = {
    id?: string
    year: number
    inFieldOfResearch: FieldOfResearchsCreateNestedOneWithoutJournalRanksInput
    belongsTo: JournalsCreateNestedOneWithoutJournalRanksInput
  }

  export type JournalRanksUncheckedCreateWithoutByRankInput = {
    id?: string
    year: number
    journalId: string
    fieldOfResearchId: string
  }

  export type JournalRanksCreateOrConnectWithoutByRankInput = {
    where: JournalRanksWhereUniqueInput
    create: XOR<JournalRanksCreateWithoutByRankInput, JournalRanksUncheckedCreateWithoutByRankInput>
  }

  export type JournalRanksCreateManyByRankInputEnvelope = {
    data: JournalRanksCreateManyByRankInput | JournalRanksCreateManyByRankInput[]
    skipDuplicates?: boolean
  }

  export type SourcesCreateWithoutRanksInput = {
    id?: string
    name: string
    link?: string | null
  }

  export type SourcesUncheckedCreateWithoutRanksInput = {
    id?: string
    name: string
    link?: string | null
  }

  export type SourcesCreateOrConnectWithoutRanksInput = {
    where: SourcesWhereUniqueInput
    create: XOR<SourcesCreateWithoutRanksInput, SourcesUncheckedCreateWithoutRanksInput>
  }

  export type ConferenceRanksUpsertWithWhereUniqueWithoutByRankInput = {
    where: ConferenceRanksWhereUniqueInput
    update: XOR<ConferenceRanksUpdateWithoutByRankInput, ConferenceRanksUncheckedUpdateWithoutByRankInput>
    create: XOR<ConferenceRanksCreateWithoutByRankInput, ConferenceRanksUncheckedCreateWithoutByRankInput>
  }

  export type ConferenceRanksUpdateWithWhereUniqueWithoutByRankInput = {
    where: ConferenceRanksWhereUniqueInput
    data: XOR<ConferenceRanksUpdateWithoutByRankInput, ConferenceRanksUncheckedUpdateWithoutByRankInput>
  }

  export type ConferenceRanksUpdateManyWithWhereWithoutByRankInput = {
    where: ConferenceRanksScalarWhereInput
    data: XOR<ConferenceRanksUpdateManyMutationInput, ConferenceRanksUncheckedUpdateManyWithoutByRankInput>
  }

  export type JournalRanksUpsertWithWhereUniqueWithoutByRankInput = {
    where: JournalRanksWhereUniqueInput
    update: XOR<JournalRanksUpdateWithoutByRankInput, JournalRanksUncheckedUpdateWithoutByRankInput>
    create: XOR<JournalRanksCreateWithoutByRankInput, JournalRanksUncheckedCreateWithoutByRankInput>
  }

  export type JournalRanksUpdateWithWhereUniqueWithoutByRankInput = {
    where: JournalRanksWhereUniqueInput
    data: XOR<JournalRanksUpdateWithoutByRankInput, JournalRanksUncheckedUpdateWithoutByRankInput>
  }

  export type JournalRanksUpdateManyWithWhereWithoutByRankInput = {
    where: JournalRanksScalarWhereInput
    data: XOR<JournalRanksUpdateManyMutationInput, JournalRanksUncheckedUpdateManyWithoutByRankInput>
  }

  export type SourcesUpsertWithoutRanksInput = {
    update: XOR<SourcesUpdateWithoutRanksInput, SourcesUncheckedUpdateWithoutRanksInput>
    create: XOR<SourcesCreateWithoutRanksInput, SourcesUncheckedCreateWithoutRanksInput>
    where?: SourcesWhereInput
  }

  export type SourcesUpdateToOneWithWhereWithoutRanksInput = {
    where?: SourcesWhereInput
    data: XOR<SourcesUpdateWithoutRanksInput, SourcesUncheckedUpdateWithoutRanksInput>
  }

  export type SourcesUpdateWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourcesUncheckedUpdateWithoutRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RanksCreateWithoutBelongsToSourceInput = {
    id?: string
    name: string
    value: number
    conferenceRanks?: ConferenceRanksCreateNestedManyWithoutByRankInput
    journalRanks?: JournalRanksCreateNestedManyWithoutByRankInput
  }

  export type RanksUncheckedCreateWithoutBelongsToSourceInput = {
    id?: string
    name: string
    value: number
    conferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutByRankInput
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutByRankInput
  }

  export type RanksCreateOrConnectWithoutBelongsToSourceInput = {
    where: RanksWhereUniqueInput
    create: XOR<RanksCreateWithoutBelongsToSourceInput, RanksUncheckedCreateWithoutBelongsToSourceInput>
  }

  export type RanksCreateManyBelongsToSourceInputEnvelope = {
    data: RanksCreateManyBelongsToSourceInput | RanksCreateManyBelongsToSourceInput[]
    skipDuplicates?: boolean
  }

  export type RanksUpsertWithWhereUniqueWithoutBelongsToSourceInput = {
    where: RanksWhereUniqueInput
    update: XOR<RanksUpdateWithoutBelongsToSourceInput, RanksUncheckedUpdateWithoutBelongsToSourceInput>
    create: XOR<RanksCreateWithoutBelongsToSourceInput, RanksUncheckedCreateWithoutBelongsToSourceInput>
  }

  export type RanksUpdateWithWhereUniqueWithoutBelongsToSourceInput = {
    where: RanksWhereUniqueInput
    data: XOR<RanksUpdateWithoutBelongsToSourceInput, RanksUncheckedUpdateWithoutBelongsToSourceInput>
  }

  export type RanksUpdateManyWithWhereWithoutBelongsToSourceInput = {
    where: RanksScalarWhereInput
    data: XOR<RanksUpdateManyMutationInput, RanksUncheckedUpdateManyWithoutBelongsToSourceInput>
  }

  export type RanksScalarWhereInput = {
    AND?: RanksScalarWhereInput | RanksScalarWhereInput[]
    OR?: RanksScalarWhereInput[]
    NOT?: RanksScalarWhereInput | RanksScalarWhereInput[]
    id?: StringFilter<"Ranks"> | string
    name?: StringFilter<"Ranks"> | string
    value?: IntFilter<"Ranks"> | number
    sourceId?: StringFilter<"Ranks"> | string
  }

  export type TopicsCreateWithoutInJournalTopicsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inConferenceTopics?: ConferenceTopicsCreateNestedManyWithoutInTopicInput
  }

  export type TopicsUncheckedCreateWithoutInJournalTopicsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inConferenceTopics?: ConferenceTopicsUncheckedCreateNestedManyWithoutInTopicInput
  }

  export type TopicsCreateOrConnectWithoutInJournalTopicsInput = {
    where: TopicsWhereUniqueInput
    create: XOR<TopicsCreateWithoutInJournalTopicsInput, TopicsUncheckedCreateWithoutInJournalTopicsInput>
  }

  export type JournalsCreateWithoutTopicsInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    journalRanks?: JournalRanksCreateNestedManyWithoutBelongsToInput
    journalLikes?: JournalLikesCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedJournalsInput
  }

  export type JournalsUncheckedCreateWithoutTopicsInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutBelongsToInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type JournalsCreateOrConnectWithoutTopicsInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutTopicsInput, JournalsUncheckedCreateWithoutTopicsInput>
  }

  export type TopicsUpsertWithoutInJournalTopicsInput = {
    update: XOR<TopicsUpdateWithoutInJournalTopicsInput, TopicsUncheckedUpdateWithoutInJournalTopicsInput>
    create: XOR<TopicsCreateWithoutInJournalTopicsInput, TopicsUncheckedCreateWithoutInJournalTopicsInput>
    where?: TopicsWhereInput
  }

  export type TopicsUpdateToOneWithWhereWithoutInJournalTopicsInput = {
    where?: TopicsWhereInput
    data: XOR<TopicsUpdateWithoutInJournalTopicsInput, TopicsUncheckedUpdateWithoutInJournalTopicsInput>
  }

  export type TopicsUpdateWithoutInJournalTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inConferenceTopics?: ConferenceTopicsUpdateManyWithoutInTopicNestedInput
  }

  export type TopicsUncheckedUpdateWithoutInJournalTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inConferenceTopics?: ConferenceTopicsUncheckedUpdateManyWithoutInTopicNestedInput
  }

  export type JournalsUpsertWithoutTopicsInput = {
    update: XOR<JournalsUpdateWithoutTopicsInput, JournalsUncheckedUpdateWithoutTopicsInput>
    create: XOR<JournalsCreateWithoutTopicsInput, JournalsUncheckedCreateWithoutTopicsInput>
    where?: JournalsWhereInput
  }

  export type JournalsUpdateToOneWithWhereWithoutTopicsInput = {
    where?: JournalsWhereInput
    data: XOR<JournalsUpdateWithoutTopicsInput, JournalsUncheckedUpdateWithoutTopicsInput>
  }

  export type JournalsUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    journalRanks?: JournalRanksUpdateManyWithoutBelongsToNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type FieldOfResearchsCreateWithoutJournalRanksInput = {
    id?: string
    name: string
    code: string
    conferenceRanks?: ConferenceRanksCreateNestedManyWithoutInFieldOfResearchInput
  }

  export type FieldOfResearchsUncheckedCreateWithoutJournalRanksInput = {
    id?: string
    name: string
    code: string
    conferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutInFieldOfResearchInput
  }

  export type FieldOfResearchsCreateOrConnectWithoutJournalRanksInput = {
    where: FieldOfResearchsWhereUniqueInput
    create: XOR<FieldOfResearchsCreateWithoutJournalRanksInput, FieldOfResearchsUncheckedCreateWithoutJournalRanksInput>
  }

  export type RanksCreateWithoutJournalRanksInput = {
    id?: string
    name: string
    value: number
    conferenceRanks?: ConferenceRanksCreateNestedManyWithoutByRankInput
    belongsToSource: SourcesCreateNestedOneWithoutRanksInput
  }

  export type RanksUncheckedCreateWithoutJournalRanksInput = {
    id?: string
    name: string
    value: number
    sourceId: string
    conferenceRanks?: ConferenceRanksUncheckedCreateNestedManyWithoutByRankInput
  }

  export type RanksCreateOrConnectWithoutJournalRanksInput = {
    where: RanksWhereUniqueInput
    create: XOR<RanksCreateWithoutJournalRanksInput, RanksUncheckedCreateWithoutJournalRanksInput>
  }

  export type JournalsCreateWithoutJournalRanksInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    topics?: JournalTopicsCreateNestedManyWithoutInJournalsInput
    journalLikes?: JournalLikesCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedJournalsInput
  }

  export type JournalsUncheckedCreateWithoutJournalRanksInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    topics?: JournalTopicsUncheckedCreateNestedManyWithoutInJournalsInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type JournalsCreateOrConnectWithoutJournalRanksInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutJournalRanksInput, JournalsUncheckedCreateWithoutJournalRanksInput>
  }

  export type FieldOfResearchsUpsertWithoutJournalRanksInput = {
    update: XOR<FieldOfResearchsUpdateWithoutJournalRanksInput, FieldOfResearchsUncheckedUpdateWithoutJournalRanksInput>
    create: XOR<FieldOfResearchsCreateWithoutJournalRanksInput, FieldOfResearchsUncheckedCreateWithoutJournalRanksInput>
    where?: FieldOfResearchsWhereInput
  }

  export type FieldOfResearchsUpdateToOneWithWhereWithoutJournalRanksInput = {
    where?: FieldOfResearchsWhereInput
    data: XOR<FieldOfResearchsUpdateWithoutJournalRanksInput, FieldOfResearchsUncheckedUpdateWithoutJournalRanksInput>
  }

  export type FieldOfResearchsUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    conferenceRanks?: ConferenceRanksUpdateManyWithoutInFieldOfResearchNestedInput
  }

  export type FieldOfResearchsUncheckedUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    conferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutInFieldOfResearchNestedInput
  }

  export type RanksUpsertWithoutJournalRanksInput = {
    update: XOR<RanksUpdateWithoutJournalRanksInput, RanksUncheckedUpdateWithoutJournalRanksInput>
    create: XOR<RanksCreateWithoutJournalRanksInput, RanksUncheckedCreateWithoutJournalRanksInput>
    where?: RanksWhereInput
  }

  export type RanksUpdateToOneWithWhereWithoutJournalRanksInput = {
    where?: RanksWhereInput
    data: XOR<RanksUpdateWithoutJournalRanksInput, RanksUncheckedUpdateWithoutJournalRanksInput>
  }

  export type RanksUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    conferenceRanks?: ConferenceRanksUpdateManyWithoutByRankNestedInput
    belongsToSource?: SourcesUpdateOneRequiredWithoutRanksNestedInput
  }

  export type RanksUncheckedUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    sourceId?: StringFieldUpdateOperationsInput | string
    conferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutByRankNestedInput
  }

  export type JournalsUpsertWithoutJournalRanksInput = {
    update: XOR<JournalsUpdateWithoutJournalRanksInput, JournalsUncheckedUpdateWithoutJournalRanksInput>
    create: XOR<JournalsCreateWithoutJournalRanksInput, JournalsUncheckedCreateWithoutJournalRanksInput>
    where?: JournalsWhereInput
  }

  export type JournalsUpdateToOneWithWhereWithoutJournalRanksInput = {
    where?: JournalsWhereInput
    data: XOR<JournalsUpdateWithoutJournalRanksInput, JournalsUncheckedUpdateWithoutJournalRanksInput>
  }

  export type JournalsUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUpdateManyWithoutInJournalsNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutJournalRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUncheckedUpdateManyWithoutInJournalsNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type JournalTopicsCreateWithoutInJournalsInput = {
    id?: string
    belongsToTopics: TopicsCreateNestedOneWithoutInJournalTopicsInput
  }

  export type JournalTopicsUncheckedCreateWithoutInJournalsInput = {
    id?: string
    topicId: string
  }

  export type JournalTopicsCreateOrConnectWithoutInJournalsInput = {
    where: JournalTopicsWhereUniqueInput
    create: XOR<JournalTopicsCreateWithoutInJournalsInput, JournalTopicsUncheckedCreateWithoutInJournalsInput>
  }

  export type JournalTopicsCreateManyInJournalsInputEnvelope = {
    data: JournalTopicsCreateManyInJournalsInput | JournalTopicsCreateManyInJournalsInput[]
    skipDuplicates?: boolean
  }

  export type JournalRanksCreateWithoutBelongsToInput = {
    id?: string
    year: number
    inFieldOfResearch: FieldOfResearchsCreateNestedOneWithoutJournalRanksInput
    byRank: RanksCreateNestedOneWithoutJournalRanksInput
  }

  export type JournalRanksUncheckedCreateWithoutBelongsToInput = {
    id?: string
    year: number
    fieldOfResearchId: string
    rankId: string
  }

  export type JournalRanksCreateOrConnectWithoutBelongsToInput = {
    where: JournalRanksWhereUniqueInput
    create: XOR<JournalRanksCreateWithoutBelongsToInput, JournalRanksUncheckedCreateWithoutBelongsToInput>
  }

  export type JournalRanksCreateManyBelongsToInputEnvelope = {
    data: JournalRanksCreateManyBelongsToInput | JournalRanksCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type JournalLikesCreateWithoutBelongsToInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    byUser: UsersCreateNestedOneWithoutJournalLikesInput
  }

  export type JournalLikesUncheckedCreateWithoutBelongsToInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalLikesCreateOrConnectWithoutBelongsToInput = {
    where: JournalLikesWhereUniqueInput
    create: XOR<JournalLikesCreateWithoutBelongsToInput, JournalLikesUncheckedCreateWithoutBelongsToInput>
  }

  export type JournalLikesCreateManyBelongsToInputEnvelope = {
    data: JournalLikesCreateManyBelongsToInput | JournalLikesCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type JournalFollowsCreateWithoutBelongsToInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    byUser: UsersCreateNestedOneWithoutJournalFollowsInput
  }

  export type JournalFollowsUncheckedCreateWithoutBelongsToInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalFollowsCreateOrConnectWithoutBelongsToInput = {
    where: JournalFollowsWhereUniqueInput
    create: XOR<JournalFollowsCreateWithoutBelongsToInput, JournalFollowsUncheckedCreateWithoutBelongsToInput>
  }

  export type JournalFollowsCreateManyBelongsToInputEnvelope = {
    data: JournalFollowsCreateManyBelongsToInput | JournalFollowsCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type JournalCrawlJobsCreateWithoutBelongsToInput = {
    id?: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalCrawlJobsUncheckedCreateWithoutBelongsToInput = {
    id?: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalCrawlJobsCreateOrConnectWithoutBelongsToInput = {
    where: JournalCrawlJobsWhereUniqueInput
    create: XOR<JournalCrawlJobsCreateWithoutBelongsToInput, JournalCrawlJobsUncheckedCreateWithoutBelongsToInput>
  }

  export type JournalCrawlJobsCreateManyBelongsToInputEnvelope = {
    data: JournalCrawlJobsCreateManyBelongsToInput | JournalCrawlJobsCreateManyBelongsToInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutCreatedJournalsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutByUserInput
  }

  export type UsersUncheckedCreateWithoutCreatedJournalsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsUncheckedCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsUncheckedCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesUncheckedCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutByUserInput
  }

  export type UsersCreateOrConnectWithoutCreatedJournalsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCreatedJournalsInput, UsersUncheckedCreateWithoutCreatedJournalsInput>
  }

  export type JournalTopicsUpsertWithWhereUniqueWithoutInJournalsInput = {
    where: JournalTopicsWhereUniqueInput
    update: XOR<JournalTopicsUpdateWithoutInJournalsInput, JournalTopicsUncheckedUpdateWithoutInJournalsInput>
    create: XOR<JournalTopicsCreateWithoutInJournalsInput, JournalTopicsUncheckedCreateWithoutInJournalsInput>
  }

  export type JournalTopicsUpdateWithWhereUniqueWithoutInJournalsInput = {
    where: JournalTopicsWhereUniqueInput
    data: XOR<JournalTopicsUpdateWithoutInJournalsInput, JournalTopicsUncheckedUpdateWithoutInJournalsInput>
  }

  export type JournalTopicsUpdateManyWithWhereWithoutInJournalsInput = {
    where: JournalTopicsScalarWhereInput
    data: XOR<JournalTopicsUpdateManyMutationInput, JournalTopicsUncheckedUpdateManyWithoutInJournalsInput>
  }

  export type JournalRanksUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: JournalRanksWhereUniqueInput
    update: XOR<JournalRanksUpdateWithoutBelongsToInput, JournalRanksUncheckedUpdateWithoutBelongsToInput>
    create: XOR<JournalRanksCreateWithoutBelongsToInput, JournalRanksUncheckedCreateWithoutBelongsToInput>
  }

  export type JournalRanksUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: JournalRanksWhereUniqueInput
    data: XOR<JournalRanksUpdateWithoutBelongsToInput, JournalRanksUncheckedUpdateWithoutBelongsToInput>
  }

  export type JournalRanksUpdateManyWithWhereWithoutBelongsToInput = {
    where: JournalRanksScalarWhereInput
    data: XOR<JournalRanksUpdateManyMutationInput, JournalRanksUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type JournalLikesUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: JournalLikesWhereUniqueInput
    update: XOR<JournalLikesUpdateWithoutBelongsToInput, JournalLikesUncheckedUpdateWithoutBelongsToInput>
    create: XOR<JournalLikesCreateWithoutBelongsToInput, JournalLikesUncheckedCreateWithoutBelongsToInput>
  }

  export type JournalLikesUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: JournalLikesWhereUniqueInput
    data: XOR<JournalLikesUpdateWithoutBelongsToInput, JournalLikesUncheckedUpdateWithoutBelongsToInput>
  }

  export type JournalLikesUpdateManyWithWhereWithoutBelongsToInput = {
    where: JournalLikesScalarWhereInput
    data: XOR<JournalLikesUpdateManyMutationInput, JournalLikesUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type JournalLikesScalarWhereInput = {
    AND?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
    OR?: JournalLikesScalarWhereInput[]
    NOT?: JournalLikesScalarWhereInput | JournalLikesScalarWhereInput[]
    id?: StringFilter<"JournalLikes"> | string
    journalId?: StringFilter<"JournalLikes"> | string
    userId?: StringFilter<"JournalLikes"> | string
    createdAt?: DateTimeFilter<"JournalLikes"> | Date | string
    updatedAt?: DateTimeFilter<"JournalLikes"> | Date | string
  }

  export type JournalFollowsUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: JournalFollowsWhereUniqueInput
    update: XOR<JournalFollowsUpdateWithoutBelongsToInput, JournalFollowsUncheckedUpdateWithoutBelongsToInput>
    create: XOR<JournalFollowsCreateWithoutBelongsToInput, JournalFollowsUncheckedCreateWithoutBelongsToInput>
  }

  export type JournalFollowsUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: JournalFollowsWhereUniqueInput
    data: XOR<JournalFollowsUpdateWithoutBelongsToInput, JournalFollowsUncheckedUpdateWithoutBelongsToInput>
  }

  export type JournalFollowsUpdateManyWithWhereWithoutBelongsToInput = {
    where: JournalFollowsScalarWhereInput
    data: XOR<JournalFollowsUpdateManyMutationInput, JournalFollowsUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type JournalFollowsScalarWhereInput = {
    AND?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
    OR?: JournalFollowsScalarWhereInput[]
    NOT?: JournalFollowsScalarWhereInput | JournalFollowsScalarWhereInput[]
    id?: StringFilter<"JournalFollows"> | string
    journalId?: StringFilter<"JournalFollows"> | string
    userId?: StringFilter<"JournalFollows"> | string
    createdAt?: DateTimeFilter<"JournalFollows"> | Date | string
    updatedAt?: DateTimeFilter<"JournalFollows"> | Date | string
  }

  export type JournalCrawlJobsUpsertWithWhereUniqueWithoutBelongsToInput = {
    where: JournalCrawlJobsWhereUniqueInput
    update: XOR<JournalCrawlJobsUpdateWithoutBelongsToInput, JournalCrawlJobsUncheckedUpdateWithoutBelongsToInput>
    create: XOR<JournalCrawlJobsCreateWithoutBelongsToInput, JournalCrawlJobsUncheckedCreateWithoutBelongsToInput>
  }

  export type JournalCrawlJobsUpdateWithWhereUniqueWithoutBelongsToInput = {
    where: JournalCrawlJobsWhereUniqueInput
    data: XOR<JournalCrawlJobsUpdateWithoutBelongsToInput, JournalCrawlJobsUncheckedUpdateWithoutBelongsToInput>
  }

  export type JournalCrawlJobsUpdateManyWithWhereWithoutBelongsToInput = {
    where: JournalCrawlJobsScalarWhereInput
    data: XOR<JournalCrawlJobsUpdateManyMutationInput, JournalCrawlJobsUncheckedUpdateManyWithoutBelongsToInput>
  }

  export type JournalCrawlJobsScalarWhereInput = {
    AND?: JournalCrawlJobsScalarWhereInput | JournalCrawlJobsScalarWhereInput[]
    OR?: JournalCrawlJobsScalarWhereInput[]
    NOT?: JournalCrawlJobsScalarWhereInput | JournalCrawlJobsScalarWhereInput[]
    id?: StringFilter<"JournalCrawlJobs"> | string
    journalId?: StringFilter<"JournalCrawlJobs"> | string
    status?: StringFilter<"JournalCrawlJobs"> | string
    progress?: IntFilter<"JournalCrawlJobs"> | number
    message?: StringFilter<"JournalCrawlJobs"> | string
    createdAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
    updatedAt?: DateTimeFilter<"JournalCrawlJobs"> | Date | string
  }

  export type UsersUpsertWithoutCreatedJournalsInput = {
    update: XOR<UsersUpdateWithoutCreatedJournalsInput, UsersUncheckedUpdateWithoutCreatedJournalsInput>
    create: XOR<UsersCreateWithoutCreatedJournalsInput, UsersUncheckedCreateWithoutCreatedJournalsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCreatedJournalsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCreatedJournalsInput, UsersUncheckedUpdateWithoutCreatedJournalsInput>
  }

  export type UsersUpdateWithoutCreatedJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutByUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutCreatedJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUncheckedUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUncheckedUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutByUserNestedInput
  }

  export type ConferencesCreateWithoutFollowsInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    likes?: ConferenceLikesCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedConferencesInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesUncheckedCreateWithoutFollowsInput = {
    id?: string
    title: string
    acronym: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesCreateOrConnectWithoutFollowsInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutFollowsInput, ConferencesUncheckedCreateWithoutFollowsInput>
  }

  export type UsersCreateWithoutFollowConferenceInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ConferenceLikesCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutByUserInput
  }

  export type UsersUncheckedCreateWithoutFollowConferenceInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsUncheckedCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsUncheckedCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutByUserInput
  }

  export type UsersCreateOrConnectWithoutFollowConferenceInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFollowConferenceInput, UsersUncheckedCreateWithoutFollowConferenceInput>
  }

  export type ConferencesUpsertWithoutFollowsInput = {
    update: XOR<ConferencesUpdateWithoutFollowsInput, ConferencesUncheckedUpdateWithoutFollowsInput>
    create: XOR<ConferencesCreateWithoutFollowsInput, ConferencesUncheckedCreateWithoutFollowsInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutFollowsInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutFollowsInput, ConferencesUncheckedUpdateWithoutFollowsInput>
  }

  export type ConferencesUpdateWithoutFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    likes?: ConferenceLikesUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedConferencesNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    likes?: ConferenceLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type UsersUpsertWithoutFollowConferenceInput = {
    update: XOR<UsersUpdateWithoutFollowConferenceInput, UsersUncheckedUpdateWithoutFollowConferenceInput>
    create: XOR<UsersCreateWithoutFollowConferenceInput, UsersUncheckedCreateWithoutFollowConferenceInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFollowConferenceInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFollowConferenceInput, UsersUncheckedUpdateWithoutFollowConferenceInput>
  }

  export type UsersUpdateWithoutFollowConferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ConferenceLikesUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutByUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutFollowConferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ConferenceLikesUncheckedUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUncheckedUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutByUserNestedInput
  }

  export type ConferencesCreateWithoutLikesInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedConferencesInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesUncheckedCreateWithoutLikesInput = {
    id?: string
    title: string
    acronym: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesCreateOrConnectWithoutLikesInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutLikesInput, ConferencesUncheckedCreateWithoutLikesInput>
  }

  export type UsersCreateWithoutLikesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutByUserInput
  }

  export type UsersUncheckedCreateWithoutLikesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsUncheckedCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsUncheckedCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsUncheckedCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutByUserInput
  }

  export type UsersCreateOrConnectWithoutLikesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutLikesInput, UsersUncheckedCreateWithoutLikesInput>
  }

  export type ConferencesUpsertWithoutLikesInput = {
    update: XOR<ConferencesUpdateWithoutLikesInput, ConferencesUncheckedUpdateWithoutLikesInput>
    create: XOR<ConferencesCreateWithoutLikesInput, ConferencesUncheckedCreateWithoutLikesInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutLikesInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutLikesInput, ConferencesUncheckedUpdateWithoutLikesInput>
  }

  export type ConferencesUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedConferencesNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type UsersUpsertWithoutLikesInput = {
    update: XOR<UsersUpdateWithoutLikesInput, UsersUncheckedUpdateWithoutLikesInput>
    create: XOR<UsersCreateWithoutLikesInput, UsersUncheckedCreateWithoutLikesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutLikesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutLikesInput, UsersUncheckedUpdateWithoutLikesInput>
  }

  export type UsersUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutByUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUncheckedUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUncheckedUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutByUserNestedInput
  }

  export type ConferencesCreateWithoutFeedbacksInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedConferencesInput
  }

  export type ConferencesUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    title: string
    acronym: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesCreateOrConnectWithoutFeedbacksInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutFeedbacksInput, ConferencesUncheckedCreateWithoutFeedbacksInput>
  }

  export type UsersCreateWithoutFeedbacksInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutByUserInput
  }

  export type UsersUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsUncheckedCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsUncheckedCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsUncheckedCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutByUserInput
  }

  export type UsersCreateOrConnectWithoutFeedbacksInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFeedbacksInput, UsersUncheckedCreateWithoutFeedbacksInput>
  }

  export type ConferencesUpsertWithoutFeedbacksInput = {
    update: XOR<ConferencesUpdateWithoutFeedbacksInput, ConferencesUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<ConferencesCreateWithoutFeedbacksInput, ConferencesUncheckedCreateWithoutFeedbacksInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutFeedbacksInput, ConferencesUncheckedUpdateWithoutFeedbacksInput>
  }

  export type ConferencesUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedConferencesNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type UsersUpsertWithoutFeedbacksInput = {
    update: XOR<UsersUpdateWithoutFeedbacksInput, UsersUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UsersCreateWithoutFeedbacksInput, UsersUncheckedCreateWithoutFeedbacksInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFeedbacksInput, UsersUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UsersUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutByUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUncheckedUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUncheckedUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutByUserNestedInput
  }

  export type ConferencesCreateWithoutCalendarsInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedConferencesInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesUncheckedCreateWithoutCalendarsInput = {
    id?: string
    title: string
    acronym: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesCreateOrConnectWithoutCalendarsInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutCalendarsInput, ConferencesUncheckedCreateWithoutCalendarsInput>
  }

  export type UsersCreateWithoutCalendarInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutByUserInput
  }

  export type UsersUncheckedCreateWithoutCalendarInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsUncheckedCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsUncheckedCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutByUserInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutByUserInput
  }

  export type UsersCreateOrConnectWithoutCalendarInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCalendarInput, UsersUncheckedCreateWithoutCalendarInput>
  }

  export type ConferencesUpsertWithoutCalendarsInput = {
    update: XOR<ConferencesUpdateWithoutCalendarsInput, ConferencesUncheckedUpdateWithoutCalendarsInput>
    create: XOR<ConferencesCreateWithoutCalendarsInput, ConferencesUncheckedCreateWithoutCalendarsInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutCalendarsInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutCalendarsInput, ConferencesUncheckedUpdateWithoutCalendarsInput>
  }

  export type ConferencesUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedConferencesNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type UsersUpsertWithoutCalendarInput = {
    update: XOR<UsersUpdateWithoutCalendarInput, UsersUncheckedUpdateWithoutCalendarInput>
    create: XOR<UsersCreateWithoutCalendarInput, UsersUncheckedCreateWithoutCalendarInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCalendarInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCalendarInput, UsersUncheckedUpdateWithoutCalendarInput>
  }

  export type UsersUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutByUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUncheckedUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutByUserNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutByUserNestedInput
  }

  export type JournalsCreateWithoutJournalLikesInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    topics?: JournalTopicsCreateNestedManyWithoutInJournalsInput
    journalRanks?: JournalRanksCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedJournalsInput
  }

  export type JournalsUncheckedCreateWithoutJournalLikesInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    topics?: JournalTopicsUncheckedCreateNestedManyWithoutInJournalsInput
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type JournalsCreateOrConnectWithoutJournalLikesInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutJournalLikesInput, JournalsUncheckedCreateWithoutJournalLikesInput>
  }

  export type UsersCreateWithoutJournalLikesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsCreateNestedManyWithoutCreatedByUserInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutByUserInput
  }

  export type UsersUncheckedCreateWithoutJournalLikesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsUncheckedCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsUncheckedCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsUncheckedCreateNestedManyWithoutCreatedByUserInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutByUserInput
  }

  export type UsersCreateOrConnectWithoutJournalLikesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutJournalLikesInput, UsersUncheckedCreateWithoutJournalLikesInput>
  }

  export type JournalsUpsertWithoutJournalLikesInput = {
    update: XOR<JournalsUpdateWithoutJournalLikesInput, JournalsUncheckedUpdateWithoutJournalLikesInput>
    create: XOR<JournalsCreateWithoutJournalLikesInput, JournalsUncheckedCreateWithoutJournalLikesInput>
    where?: JournalsWhereInput
  }

  export type JournalsUpdateToOneWithWhereWithoutJournalLikesInput = {
    where?: JournalsWhereInput
    data: XOR<JournalsUpdateWithoutJournalLikesInput, JournalsUncheckedUpdateWithoutJournalLikesInput>
  }

  export type JournalsUpdateWithoutJournalLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUpdateManyWithoutInJournalsNestedInput
    journalRanks?: JournalRanksUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutJournalLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUncheckedUpdateManyWithoutInJournalsNestedInput
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type UsersUpsertWithoutJournalLikesInput = {
    update: XOR<UsersUpdateWithoutJournalLikesInput, UsersUncheckedUpdateWithoutJournalLikesInput>
    create: XOR<UsersCreateWithoutJournalLikesInput, UsersUncheckedCreateWithoutJournalLikesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutJournalLikesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutJournalLikesInput, UsersUncheckedUpdateWithoutJournalLikesInput>
  }

  export type UsersUpdateWithoutJournalLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUpdateManyWithoutCreatedByUserNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutByUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutJournalLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUncheckedUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUncheckedUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutByUserNestedInput
  }

  export type JournalsCreateWithoutJournalFollowsInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    topics?: JournalTopicsCreateNestedManyWithoutInJournalsInput
    journalRanks?: JournalRanksCreateNestedManyWithoutBelongsToInput
    journalLikes?: JournalLikesCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedJournalsInput
  }

  export type JournalsUncheckedCreateWithoutJournalFollowsInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    topics?: JournalTopicsUncheckedCreateNestedManyWithoutInJournalsInput
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutBelongsToInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type JournalsCreateOrConnectWithoutJournalFollowsInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutJournalFollowsInput, JournalsUncheckedCreateWithoutJournalFollowsInput>
  }

  export type UsersCreateWithoutJournalFollowsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutByUserInput
  }

  export type UsersUncheckedCreateWithoutJournalFollowsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    dob: Date | string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    followConference?: ConferenceFollowsUncheckedCreateNestedManyWithoutByUserInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutByUserInput
    calendar?: ConferenceCalendarsUncheckedCreateNestedManyWithoutByUserInput
    createdConferences?: ConferencesUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdJournals?: JournalsUncheckedCreateNestedManyWithoutCreatedByUserInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutByUserInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutByUserInput
  }

  export type UsersCreateOrConnectWithoutJournalFollowsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutJournalFollowsInput, UsersUncheckedCreateWithoutJournalFollowsInput>
  }

  export type JournalsUpsertWithoutJournalFollowsInput = {
    update: XOR<JournalsUpdateWithoutJournalFollowsInput, JournalsUncheckedUpdateWithoutJournalFollowsInput>
    create: XOR<JournalsCreateWithoutJournalFollowsInput, JournalsUncheckedCreateWithoutJournalFollowsInput>
    where?: JournalsWhereInput
  }

  export type JournalsUpdateToOneWithWhereWithoutJournalFollowsInput = {
    where?: JournalsWhereInput
    data: XOR<JournalsUpdateWithoutJournalFollowsInput, JournalsUncheckedUpdateWithoutJournalFollowsInput>
  }

  export type JournalsUpdateWithoutJournalFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUpdateManyWithoutInJournalsNestedInput
    journalRanks?: JournalRanksUpdateManyWithoutBelongsToNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutJournalFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUncheckedUpdateManyWithoutInJournalsNestedInput
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type UsersUpsertWithoutJournalFollowsInput = {
    update: XOR<UsersUpdateWithoutJournalFollowsInput, UsersUncheckedUpdateWithoutJournalFollowsInput>
    create: XOR<UsersCreateWithoutJournalFollowsInput, UsersUncheckedCreateWithoutJournalFollowsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutJournalFollowsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutJournalFollowsInput, UsersUncheckedUpdateWithoutJournalFollowsInput>
  }

  export type UsersUpdateWithoutJournalFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutByUserNestedInput
  }

  export type UsersUncheckedUpdateWithoutJournalFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followConference?: ConferenceFollowsUncheckedUpdateManyWithoutByUserNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutByUserNestedInput
    calendar?: ConferenceCalendarsUncheckedUpdateManyWithoutByUserNestedInput
    createdConferences?: ConferencesUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdJournals?: JournalsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutByUserNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutByUserNestedInput
  }

  export type ConferenceFollowsCreateWithoutByUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferencesCreateNestedOneWithoutFollowsInput
  }

  export type ConferenceFollowsUncheckedCreateWithoutByUserInput = {
    id?: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFollowsCreateOrConnectWithoutByUserInput = {
    where: ConferenceFollowsWhereUniqueInput
    create: XOR<ConferenceFollowsCreateWithoutByUserInput, ConferenceFollowsUncheckedCreateWithoutByUserInput>
  }

  export type ConferenceFollowsCreateManyByUserInputEnvelope = {
    data: ConferenceFollowsCreateManyByUserInput | ConferenceFollowsCreateManyByUserInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceLikesCreateWithoutByUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferencesCreateNestedOneWithoutLikesInput
  }

  export type ConferenceLikesUncheckedCreateWithoutByUserInput = {
    id?: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceLikesCreateOrConnectWithoutByUserInput = {
    where: ConferenceLikesWhereUniqueInput
    create: XOR<ConferenceLikesCreateWithoutByUserInput, ConferenceLikesUncheckedCreateWithoutByUserInput>
  }

  export type ConferenceLikesCreateManyByUserInputEnvelope = {
    data: ConferenceLikesCreateManyByUserInput | ConferenceLikesCreateManyByUserInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceCalendarsCreateWithoutByUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferencesCreateNestedOneWithoutCalendarsInput
  }

  export type ConferenceCalendarsUncheckedCreateWithoutByUserInput = {
    id?: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceCalendarsCreateOrConnectWithoutByUserInput = {
    where: ConferenceCalendarsWhereUniqueInput
    create: XOR<ConferenceCalendarsCreateWithoutByUserInput, ConferenceCalendarsUncheckedCreateWithoutByUserInput>
  }

  export type ConferenceCalendarsCreateManyByUserInputEnvelope = {
    data: ConferenceCalendarsCreateManyByUserInput | ConferenceCalendarsCreateManyByUserInput[]
    skipDuplicates?: boolean
  }

  export type ConferencesCreateWithoutCreatedByUserInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsCreateNestedManyWithoutBelongsToInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: ConferenceCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesCreateOrConnectWithoutCreatedByUserInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutCreatedByUserInput, ConferencesUncheckedCreateWithoutCreatedByUserInput>
  }

  export type ConferencesCreateManyCreatedByUserInputEnvelope = {
    data: ConferencesCreateManyCreatedByUserInput | ConferencesCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type JournalsCreateWithoutCreatedByUserInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    topics?: JournalTopicsCreateNestedManyWithoutInJournalsInput
    journalRanks?: JournalRanksCreateNestedManyWithoutBelongsToInput
    journalLikes?: JournalLikesCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsCreateNestedManyWithoutBelongsToInput
  }

  export type JournalsUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    topics?: JournalTopicsUncheckedCreateNestedManyWithoutInJournalsInput
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutBelongsToInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    crawlJobs?: JournalCrawlJobsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type JournalsCreateOrConnectWithoutCreatedByUserInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutCreatedByUserInput, JournalsUncheckedCreateWithoutCreatedByUserInput>
  }

  export type JournalsCreateManyCreatedByUserInputEnvelope = {
    data: JournalsCreateManyCreatedByUserInput | JournalsCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type JournalLikesCreateWithoutByUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: JournalsCreateNestedOneWithoutJournalLikesInput
  }

  export type JournalLikesUncheckedCreateWithoutByUserInput = {
    id?: string
    journalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalLikesCreateOrConnectWithoutByUserInput = {
    where: JournalLikesWhereUniqueInput
    create: XOR<JournalLikesCreateWithoutByUserInput, JournalLikesUncheckedCreateWithoutByUserInput>
  }

  export type JournalLikesCreateManyByUserInputEnvelope = {
    data: JournalLikesCreateManyByUserInput | JournalLikesCreateManyByUserInput[]
    skipDuplicates?: boolean
  }

  export type JournalFollowsCreateWithoutByUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: JournalsCreateNestedOneWithoutJournalFollowsInput
  }

  export type JournalFollowsUncheckedCreateWithoutByUserInput = {
    id?: string
    journalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalFollowsCreateOrConnectWithoutByUserInput = {
    where: JournalFollowsWhereUniqueInput
    create: XOR<JournalFollowsCreateWithoutByUserInput, JournalFollowsUncheckedCreateWithoutByUserInput>
  }

  export type JournalFollowsCreateManyByUserInputEnvelope = {
    data: JournalFollowsCreateManyByUserInput | JournalFollowsCreateManyByUserInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceFeedbacksCreateWithoutByUserInput = {
    id?: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt?: Date | string
    belongsTo: ConferencesCreateNestedOneWithoutFeedbacksInput
  }

  export type ConferenceFeedbacksUncheckedCreateWithoutByUserInput = {
    id?: string
    conferenceId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFeedbacksCreateOrConnectWithoutByUserInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    create: XOR<ConferenceFeedbacksCreateWithoutByUserInput, ConferenceFeedbacksUncheckedCreateWithoutByUserInput>
  }

  export type ConferenceFeedbacksCreateManyByUserInputEnvelope = {
    data: ConferenceFeedbacksCreateManyByUserInput | ConferenceFeedbacksCreateManyByUserInput[]
    skipDuplicates?: boolean
  }

  export type ConferenceFollowsUpsertWithWhereUniqueWithoutByUserInput = {
    where: ConferenceFollowsWhereUniqueInput
    update: XOR<ConferenceFollowsUpdateWithoutByUserInput, ConferenceFollowsUncheckedUpdateWithoutByUserInput>
    create: XOR<ConferenceFollowsCreateWithoutByUserInput, ConferenceFollowsUncheckedCreateWithoutByUserInput>
  }

  export type ConferenceFollowsUpdateWithWhereUniqueWithoutByUserInput = {
    where: ConferenceFollowsWhereUniqueInput
    data: XOR<ConferenceFollowsUpdateWithoutByUserInput, ConferenceFollowsUncheckedUpdateWithoutByUserInput>
  }

  export type ConferenceFollowsUpdateManyWithWhereWithoutByUserInput = {
    where: ConferenceFollowsScalarWhereInput
    data: XOR<ConferenceFollowsUpdateManyMutationInput, ConferenceFollowsUncheckedUpdateManyWithoutByUserInput>
  }

  export type ConferenceLikesUpsertWithWhereUniqueWithoutByUserInput = {
    where: ConferenceLikesWhereUniqueInput
    update: XOR<ConferenceLikesUpdateWithoutByUserInput, ConferenceLikesUncheckedUpdateWithoutByUserInput>
    create: XOR<ConferenceLikesCreateWithoutByUserInput, ConferenceLikesUncheckedCreateWithoutByUserInput>
  }

  export type ConferenceLikesUpdateWithWhereUniqueWithoutByUserInput = {
    where: ConferenceLikesWhereUniqueInput
    data: XOR<ConferenceLikesUpdateWithoutByUserInput, ConferenceLikesUncheckedUpdateWithoutByUserInput>
  }

  export type ConferenceLikesUpdateManyWithWhereWithoutByUserInput = {
    where: ConferenceLikesScalarWhereInput
    data: XOR<ConferenceLikesUpdateManyMutationInput, ConferenceLikesUncheckedUpdateManyWithoutByUserInput>
  }

  export type ConferenceCalendarsUpsertWithWhereUniqueWithoutByUserInput = {
    where: ConferenceCalendarsWhereUniqueInput
    update: XOR<ConferenceCalendarsUpdateWithoutByUserInput, ConferenceCalendarsUncheckedUpdateWithoutByUserInput>
    create: XOR<ConferenceCalendarsCreateWithoutByUserInput, ConferenceCalendarsUncheckedCreateWithoutByUserInput>
  }

  export type ConferenceCalendarsUpdateWithWhereUniqueWithoutByUserInput = {
    where: ConferenceCalendarsWhereUniqueInput
    data: XOR<ConferenceCalendarsUpdateWithoutByUserInput, ConferenceCalendarsUncheckedUpdateWithoutByUserInput>
  }

  export type ConferenceCalendarsUpdateManyWithWhereWithoutByUserInput = {
    where: ConferenceCalendarsScalarWhereInput
    data: XOR<ConferenceCalendarsUpdateManyMutationInput, ConferenceCalendarsUncheckedUpdateManyWithoutByUserInput>
  }

  export type ConferencesUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: ConferencesWhereUniqueInput
    update: XOR<ConferencesUpdateWithoutCreatedByUserInput, ConferencesUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<ConferencesCreateWithoutCreatedByUserInput, ConferencesUncheckedCreateWithoutCreatedByUserInput>
  }

  export type ConferencesUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: ConferencesWhereUniqueInput
    data: XOR<ConferencesUpdateWithoutCreatedByUserInput, ConferencesUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type ConferencesUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: ConferencesScalarWhereInput
    data: XOR<ConferencesUpdateManyMutationInput, ConferencesUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type ConferencesScalarWhereInput = {
    AND?: ConferencesScalarWhereInput | ConferencesScalarWhereInput[]
    OR?: ConferencesScalarWhereInput[]
    NOT?: ConferencesScalarWhereInput | ConferencesScalarWhereInput[]
    id?: StringFilter<"Conferences"> | string
    title?: StringFilter<"Conferences"> | string
    acronym?: StringFilter<"Conferences"> | string
    creatorId?: StringFilter<"Conferences"> | string
    createdAt?: DateTimeFilter<"Conferences"> | Date | string
    updatedAt?: DateTimeFilter<"Conferences"> | Date | string
    status?: StringFilter<"Conferences"> | string
  }

  export type JournalsUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: JournalsWhereUniqueInput
    update: XOR<JournalsUpdateWithoutCreatedByUserInput, JournalsUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<JournalsCreateWithoutCreatedByUserInput, JournalsUncheckedCreateWithoutCreatedByUserInput>
  }

  export type JournalsUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: JournalsWhereUniqueInput
    data: XOR<JournalsUpdateWithoutCreatedByUserInput, JournalsUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type JournalsUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: JournalsScalarWhereInput
    data: XOR<JournalsUpdateManyMutationInput, JournalsUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type JournalsScalarWhereInput = {
    AND?: JournalsScalarWhereInput | JournalsScalarWhereInput[]
    OR?: JournalsScalarWhereInput[]
    NOT?: JournalsScalarWhereInput | JournalsScalarWhereInput[]
    id?: StringFilter<"Journals"> | string
    name?: StringFilter<"Journals"> | string
    issn?: StringFilter<"Journals"> | string
    hIndex?: IntFilter<"Journals"> | number
    publisher?: StringFilter<"Journals"> | string
    nation?: StringFilter<"Journals"> | string
    scope?: StringFilter<"Journals"> | string
    emailSubmission?: StringFilter<"Journals"> | string
    creator?: StringFilter<"Journals"> | string
  }

  export type JournalLikesUpsertWithWhereUniqueWithoutByUserInput = {
    where: JournalLikesWhereUniqueInput
    update: XOR<JournalLikesUpdateWithoutByUserInput, JournalLikesUncheckedUpdateWithoutByUserInput>
    create: XOR<JournalLikesCreateWithoutByUserInput, JournalLikesUncheckedCreateWithoutByUserInput>
  }

  export type JournalLikesUpdateWithWhereUniqueWithoutByUserInput = {
    where: JournalLikesWhereUniqueInput
    data: XOR<JournalLikesUpdateWithoutByUserInput, JournalLikesUncheckedUpdateWithoutByUserInput>
  }

  export type JournalLikesUpdateManyWithWhereWithoutByUserInput = {
    where: JournalLikesScalarWhereInput
    data: XOR<JournalLikesUpdateManyMutationInput, JournalLikesUncheckedUpdateManyWithoutByUserInput>
  }

  export type JournalFollowsUpsertWithWhereUniqueWithoutByUserInput = {
    where: JournalFollowsWhereUniqueInput
    update: XOR<JournalFollowsUpdateWithoutByUserInput, JournalFollowsUncheckedUpdateWithoutByUserInput>
    create: XOR<JournalFollowsCreateWithoutByUserInput, JournalFollowsUncheckedCreateWithoutByUserInput>
  }

  export type JournalFollowsUpdateWithWhereUniqueWithoutByUserInput = {
    where: JournalFollowsWhereUniqueInput
    data: XOR<JournalFollowsUpdateWithoutByUserInput, JournalFollowsUncheckedUpdateWithoutByUserInput>
  }

  export type JournalFollowsUpdateManyWithWhereWithoutByUserInput = {
    where: JournalFollowsScalarWhereInput
    data: XOR<JournalFollowsUpdateManyMutationInput, JournalFollowsUncheckedUpdateManyWithoutByUserInput>
  }

  export type ConferenceFeedbacksUpsertWithWhereUniqueWithoutByUserInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    update: XOR<ConferenceFeedbacksUpdateWithoutByUserInput, ConferenceFeedbacksUncheckedUpdateWithoutByUserInput>
    create: XOR<ConferenceFeedbacksCreateWithoutByUserInput, ConferenceFeedbacksUncheckedCreateWithoutByUserInput>
  }

  export type ConferenceFeedbacksUpdateWithWhereUniqueWithoutByUserInput = {
    where: ConferenceFeedbacksWhereUniqueInput
    data: XOR<ConferenceFeedbacksUpdateWithoutByUserInput, ConferenceFeedbacksUncheckedUpdateWithoutByUserInput>
  }

  export type ConferenceFeedbacksUpdateManyWithWhereWithoutByUserInput = {
    where: ConferenceFeedbacksScalarWhereInput
    data: XOR<ConferenceFeedbacksUpdateManyMutationInput, ConferenceFeedbacksUncheckedUpdateManyWithoutByUserInput>
  }

  export type ConferencesCreateWithoutCrawlJobsInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedConferencesInput
    feedbacks?: ConferenceFeedbacksCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesUncheckedCreateWithoutCrawlJobsInput = {
    id?: string
    title: string
    acronym: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    follows?: ConferenceFollowsUncheckedCreateNestedManyWithoutBelongsToInput
    likes?: ConferenceLikesUncheckedCreateNestedManyWithoutBelongsToInput
    calendars?: ConferenceCalendarsUncheckedCreateNestedManyWithoutBelongsToInput
    organizations?: ConferenceOrganizationsUncheckedCreateNestedManyWithoutBelongsToInput
    ranks?: ConferenceRanksUncheckedCreateNestedManyWithoutBelongsToInput
    feedbacks?: ConferenceFeedbacksUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type ConferencesCreateOrConnectWithoutCrawlJobsInput = {
    where: ConferencesWhereUniqueInput
    create: XOR<ConferencesCreateWithoutCrawlJobsInput, ConferencesUncheckedCreateWithoutCrawlJobsInput>
  }

  export type ConferencesUpsertWithoutCrawlJobsInput = {
    update: XOR<ConferencesUpdateWithoutCrawlJobsInput, ConferencesUncheckedUpdateWithoutCrawlJobsInput>
    create: XOR<ConferencesCreateWithoutCrawlJobsInput, ConferencesUncheckedCreateWithoutCrawlJobsInput>
    where?: ConferencesWhereInput
  }

  export type ConferencesUpdateToOneWithWhereWithoutCrawlJobsInput = {
    where?: ConferencesWhereInput
    data: XOR<ConferencesUpdateWithoutCrawlJobsInput, ConferencesUncheckedUpdateWithoutCrawlJobsInput>
  }

  export type ConferencesUpdateWithoutCrawlJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedConferencesNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutCrawlJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type JournalsCreateWithoutCrawlJobsInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    topics?: JournalTopicsCreateNestedManyWithoutInJournalsInput
    journalRanks?: JournalRanksCreateNestedManyWithoutBelongsToInput
    journalLikes?: JournalLikesCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsCreateNestedManyWithoutBelongsToInput
    createdByUser: UsersCreateNestedOneWithoutCreatedJournalsInput
  }

  export type JournalsUncheckedCreateWithoutCrawlJobsInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
    creator: string
    topics?: JournalTopicsUncheckedCreateNestedManyWithoutInJournalsInput
    journalRanks?: JournalRanksUncheckedCreateNestedManyWithoutBelongsToInput
    journalLikes?: JournalLikesUncheckedCreateNestedManyWithoutBelongsToInput
    journalFollows?: JournalFollowsUncheckedCreateNestedManyWithoutBelongsToInput
  }

  export type JournalsCreateOrConnectWithoutCrawlJobsInput = {
    where: JournalsWhereUniqueInput
    create: XOR<JournalsCreateWithoutCrawlJobsInput, JournalsUncheckedCreateWithoutCrawlJobsInput>
  }

  export type JournalsUpsertWithoutCrawlJobsInput = {
    update: XOR<JournalsUpdateWithoutCrawlJobsInput, JournalsUncheckedUpdateWithoutCrawlJobsInput>
    create: XOR<JournalsCreateWithoutCrawlJobsInput, JournalsUncheckedCreateWithoutCrawlJobsInput>
    where?: JournalsWhereInput
  }

  export type JournalsUpdateToOneWithWhereWithoutCrawlJobsInput = {
    where?: JournalsWhereInput
    data: XOR<JournalsUpdateWithoutCrawlJobsInput, JournalsUncheckedUpdateWithoutCrawlJobsInput>
  }

  export type JournalsUpdateWithoutCrawlJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUpdateManyWithoutInJournalsNestedInput
    journalRanks?: JournalRanksUpdateManyWithoutBelongsToNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutBelongsToNestedInput
    createdByUser?: UsersUpdateOneRequiredWithoutCreatedJournalsNestedInput
  }

  export type JournalsUncheckedUpdateWithoutCrawlJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    creator?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUncheckedUpdateManyWithoutInJournalsNestedInput
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferenceDatesCreateManyBelongsToInput = {
    id?: string
    fromDate: Date | string
    toDate: Date | string
    type: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
  }

  export type LocationsCreateManyBelongsToInput = {
    id?: string
    address?: string | null
    cityStateProvince?: string | null
    country?: string | null
    continent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAvailable: boolean
  }

  export type ConferenceTopicsCreateManyBelongsToInput = {
    id?: string
    topicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceDatesUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceDatesUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceDatesUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationsUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationsUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationsUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityStateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConferenceTopicsUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inTopic?: TopicsUpdateOneRequiredWithoutInConferenceTopicsNestedInput
  }

  export type ConferenceTopicsUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceTopicsUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceTopicsCreateManyInTopicInput = {
    id?: string
    organizeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalTopicsCreateManyBelongsToTopicsInput = {
    id?: string
    journalId: string
  }

  export type ConferenceTopicsUpdateWithoutInTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferenceOrganizationsUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type ConferenceTopicsUncheckedUpdateWithoutInTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceTopicsUncheckedUpdateManyWithoutInTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalTopicsUpdateWithoutBelongsToTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inJournals?: JournalsUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type JournalTopicsUncheckedUpdateWithoutBelongsToTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalTopicsUncheckedUpdateManyWithoutBelongsToTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceFollowsCreateManyBelongsToInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceLikesCreateManyBelongsToInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceCalendarsCreateManyBelongsToInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceOrganizationsCreateManyBelongsToInput = {
    id?: string
    year: number
    accessType: string
    isAvailable: boolean
    publisher: string
    summerize: string
    callForPaper: string
    link: string
    cfpLink: string
    impLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceRanksCreateManyBelongsToInput = {
    id?: string
    year: number
    fieldOfResearchId: string
    rankId: string
  }

  export type ConferenceCrawlJobsCreateManyBelongsToInput = {
    id?: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFeedbacksCreateManyBelongsToInput = {
    id?: string
    creatorId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFollowsUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    byUser?: UsersUpdateOneRequiredWithoutFollowConferenceNestedInput
  }

  export type ConferenceFollowsUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    byUser?: UsersUpdateOneRequiredWithoutLikesNestedInput
  }

  export type ConferenceLikesUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    byUser?: UsersUpdateOneRequiredWithoutCalendarNestedInput
  }

  export type ConferenceCalendarsUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceOrganizationsUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferenceDates?: ConferenceDatesUpdateManyWithoutBelongsToNestedInput
    locations?: LocationsUpdateManyWithoutBelongsToNestedInput
    topics?: ConferenceTopicsUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conferenceDates?: ConferenceDatesUncheckedUpdateManyWithoutBelongsToNestedInput
    locations?: LocationsUncheckedUpdateManyWithoutBelongsToNestedInput
    topics?: ConferenceTopicsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    accessType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    publisher?: StringFieldUpdateOperationsInput | string
    summerize?: StringFieldUpdateOperationsInput | string
    callForPaper?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    cfpLink?: StringFieldUpdateOperationsInput | string
    impLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceRanksUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    inFieldOfResearch?: FieldOfResearchsUpdateOneRequiredWithoutConferenceRanksNestedInput
    byRank?: RanksUpdateOneRequiredWithoutConferenceRanksNestedInput
  }

  export type ConferenceRanksUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceCrawlJobsUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    byUser?: UsersUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type ConferenceFeedbacksUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalRanksCreateManyInFieldOfResearchInput = {
    id?: string
    year: number
    journalId: string
    rankId: string
  }

  export type ConferenceRanksCreateManyInFieldOfResearchInput = {
    id?: string
    year: number
    conferenceId: string
    rankId: string
  }

  export type JournalRanksUpdateWithoutInFieldOfResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    byRank?: RanksUpdateOneRequiredWithoutJournalRanksNestedInput
    belongsTo?: JournalsUpdateOneRequiredWithoutJournalRanksNestedInput
  }

  export type JournalRanksUncheckedUpdateWithoutInFieldOfResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksUncheckedUpdateManyWithoutInFieldOfResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksUpdateWithoutInFieldOfResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    byRank?: RanksUpdateOneRequiredWithoutConferenceRanksNestedInput
    belongsTo?: ConferencesUpdateOneRequiredWithoutRanksNestedInput
  }

  export type ConferenceRanksUncheckedUpdateWithoutInFieldOfResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutInFieldOfResearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksCreateManyByRankInput = {
    id?: string
    year: number
    conferenceId: string
    fieldOfResearchId: string
  }

  export type JournalRanksCreateManyByRankInput = {
    id?: string
    year: number
    journalId: string
    fieldOfResearchId: string
  }

  export type ConferenceRanksUpdateWithoutByRankInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    inFieldOfResearch?: FieldOfResearchsUpdateOneRequiredWithoutConferenceRanksNestedInput
    belongsTo?: ConferencesUpdateOneRequiredWithoutRanksNestedInput
  }

  export type ConferenceRanksUncheckedUpdateWithoutByRankInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
  }

  export type ConferenceRanksUncheckedUpdateManyWithoutByRankInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    conferenceId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksUpdateWithoutByRankInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    inFieldOfResearch?: FieldOfResearchsUpdateOneRequiredWithoutJournalRanksNestedInput
    belongsTo?: JournalsUpdateOneRequiredWithoutJournalRanksNestedInput
  }

  export type JournalRanksUncheckedUpdateWithoutByRankInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksUncheckedUpdateManyWithoutByRankInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    journalId?: StringFieldUpdateOperationsInput | string
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
  }

  export type RanksCreateManyBelongsToSourceInput = {
    id?: string
    name: string
    value: number
  }

  export type RanksUpdateWithoutBelongsToSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    conferenceRanks?: ConferenceRanksUpdateManyWithoutByRankNestedInput
    journalRanks?: JournalRanksUpdateManyWithoutByRankNestedInput
  }

  export type RanksUncheckedUpdateWithoutBelongsToSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    conferenceRanks?: ConferenceRanksUncheckedUpdateManyWithoutByRankNestedInput
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutByRankNestedInput
  }

  export type RanksUncheckedUpdateManyWithoutBelongsToSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type JournalTopicsCreateManyInJournalsInput = {
    id?: string
    topicId: string
  }

  export type JournalRanksCreateManyBelongsToInput = {
    id?: string
    year: number
    fieldOfResearchId: string
    rankId: string
  }

  export type JournalLikesCreateManyBelongsToInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalFollowsCreateManyBelongsToInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalCrawlJobsCreateManyBelongsToInput = {
    id?: string
    status: string
    progress: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalTopicsUpdateWithoutInJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    belongsToTopics?: TopicsUpdateOneRequiredWithoutInJournalTopicsNestedInput
  }

  export type JournalTopicsUncheckedUpdateWithoutInJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalTopicsUncheckedUpdateManyWithoutInJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    inFieldOfResearch?: FieldOfResearchsUpdateOneRequiredWithoutJournalRanksNestedInput
    byRank?: RanksUpdateOneRequiredWithoutJournalRanksNestedInput
  }

  export type JournalRanksUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalRanksUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    fieldOfResearchId?: StringFieldUpdateOperationsInput | string
    rankId?: StringFieldUpdateOperationsInput | string
  }

  export type JournalLikesUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    byUser?: UsersUpdateOneRequiredWithoutJournalLikesNestedInput
  }

  export type JournalLikesUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    byUser?: UsersUpdateOneRequiredWithoutJournalFollowsNestedInput
  }

  export type JournalFollowsUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCrawlJobsUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCrawlJobsUncheckedUpdateWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCrawlJobsUncheckedUpdateManyWithoutBelongsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsCreateManyByUserInput = {
    id?: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceLikesCreateManyByUserInput = {
    id?: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceCalendarsCreateManyByUserInput = {
    id?: string
    conferenceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferencesCreateManyCreatedByUserInput = {
    id?: string
    title: string
    acronym: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
  }

  export type JournalsCreateManyCreatedByUserInput = {
    id?: string
    name: string
    issn: string
    hIndex: number
    publisher: string
    nation: string
    scope: string
    emailSubmission: string
  }

  export type JournalLikesCreateManyByUserInput = {
    id?: string
    journalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalFollowsCreateManyByUserInput = {
    id?: string
    journalId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFeedbacksCreateManyByUserInput = {
    id?: string
    conferenceId: string
    description: string
    star: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConferenceFollowsUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferencesUpdateOneRequiredWithoutFollowsNestedInput
  }

  export type ConferenceFollowsUncheckedUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFollowsUncheckedUpdateManyWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferencesUpdateOneRequiredWithoutLikesNestedInput
  }

  export type ConferenceLikesUncheckedUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceLikesUncheckedUpdateManyWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferencesUpdateOneRequiredWithoutCalendarsNestedInput
  }

  export type ConferenceCalendarsUncheckedUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceCalendarsUncheckedUpdateManyWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferencesUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUpdateManyWithoutBelongsToNestedInput
    feedbacks?: ConferenceFeedbacksUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferencesUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    follows?: ConferenceFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    likes?: ConferenceLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    calendars?: ConferenceCalendarsUncheckedUpdateManyWithoutBelongsToNestedInput
    organizations?: ConferenceOrganizationsUncheckedUpdateManyWithoutBelongsToNestedInput
    ranks?: ConferenceRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: ConferenceCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
    feedbacks?: ConferenceFeedbacksUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type ConferencesUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    acronym?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type JournalsUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUpdateManyWithoutInJournalsNestedInput
    journalRanks?: JournalRanksUpdateManyWithoutBelongsToNestedInput
    journalLikes?: JournalLikesUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUpdateManyWithoutBelongsToNestedInput
  }

  export type JournalsUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
    topics?: JournalTopicsUncheckedUpdateManyWithoutInJournalsNestedInput
    journalRanks?: JournalRanksUncheckedUpdateManyWithoutBelongsToNestedInput
    journalLikes?: JournalLikesUncheckedUpdateManyWithoutBelongsToNestedInput
    journalFollows?: JournalFollowsUncheckedUpdateManyWithoutBelongsToNestedInput
    crawlJobs?: JournalCrawlJobsUncheckedUpdateManyWithoutBelongsToNestedInput
  }

  export type JournalsUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issn?: StringFieldUpdateOperationsInput | string
    hIndex?: IntFieldUpdateOperationsInput | number
    publisher?: StringFieldUpdateOperationsInput | string
    nation?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    emailSubmission?: StringFieldUpdateOperationsInput | string
  }

  export type JournalLikesUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: JournalsUpdateOneRequiredWithoutJournalLikesNestedInput
  }

  export type JournalLikesUncheckedUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLikesUncheckedUpdateManyWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: JournalsUpdateOneRequiredWithoutJournalFollowsNestedInput
  }

  export type JournalFollowsUncheckedUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalFollowsUncheckedUpdateManyWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    belongsTo?: ConferencesUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type ConferenceFeedbacksUncheckedUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConferenceFeedbacksUncheckedUpdateManyWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conferenceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    star?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}